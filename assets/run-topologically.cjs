'use strict';

var fs = require('fs');
var require$$3 = require('path');
var require$$0$2 = require('url');
var require$$0$3 = require('module');
var require$$5 = require('os');
var require$$0$4 = require('process');
var require$$0$5 = require('buffer');
var EventEmitter$1 = require('events');
var util = require('util');
var stream = require('stream');

function _instanceof$y(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
    if (typeof f == "function") {
        var a = function a() {
            if (_instanceof$y(this, a)) {
                return Reflect.construct(f, arguments, this.constructor);
            }
            return f.apply(this, arguments);
        };
        a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {
        value: true
    });
    Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function get() {
                return n[k];
            }
        });
    });
    return a;
}

var eventemitter3 = {
    exports: {}
};

var hasRequiredEventemitter3;
function requireEventemitter3() {
    if (hasRequiredEventemitter3) return eventemitter3.exports;
    hasRequiredEventemitter3 = 1;
    (function(module) {
        var has = Object.prototype.hasOwnProperty, prefix = '~';
        /**
		 * Constructor to create a storage for our `EE` objects.
		 * An `Events` instance is a plain object whose properties are event names.
		 *
		 * @constructor
		 * @private
		 */ function Events() {}
        //
        // We try to not inherit from `Object.prototype`. In some engines creating an
        // instance in this way is faster than calling `Object.create(null)` directly.
        // If `Object.create(null)` is not supported we prefix the event names with a
        // character to make sure that the built-in object properties are not
        // overridden or used as an attack vector.
        //
        if (Object.create) {
            Events.prototype = Object.create(null);
            //
            // This hack is needed because the `__proto__` property is still inherited in
            // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
            //
            if (!new Events().__proto__) prefix = false;
        }
        /**
		 * Representation of a single event listener.
		 *
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
		 * @constructor
		 * @private
		 */ function EE(fn, context, once) {
            this.fn = fn;
            this.context = context;
            this.once = once || false;
        }
        /**
		 * Add a listener for a given event.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} once Specify if the listener is a one-time listener.
		 * @returns {EventEmitter}
		 * @private
		 */ function addListener(emitter, event, fn, context, once) {
            if (typeof fn !== 'function') {
                throw new TypeError('The listener must be a function');
            }
            var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
            if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
            else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
            else emitter._events[evt] = [
                emitter._events[evt],
                listener
            ];
            return emitter;
        }
        /**
		 * Clear event by name.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} evt The Event name.
		 * @private
		 */ function clearEvent(emitter, evt) {
            if (--emitter._eventsCount === 0) emitter._events = new Events();
            else delete emitter._events[evt];
        }
        /**
		 * Minimal `EventEmitter` interface that is molded against the Node.js
		 * `EventEmitter` interface.
		 *
		 * @constructor
		 * @public
		 */ function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
        }
        /**
		 * Return an array listing the events for which the emitter has registered
		 * listeners.
		 *
		 * @returns {Array}
		 * @public
		 */ EventEmitter.prototype.eventNames = function eventNames() {
            var names = [], events, name;
            if (this._eventsCount === 0) return names;
            for(name in events = this._events){
                if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
            }
            if (Object.getOwnPropertySymbols) {
                return names.concat(Object.getOwnPropertySymbols(events));
            }
            return names;
        };
        /**
		 * Return the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Array} The registered listeners.
		 * @public
		 */ EventEmitter.prototype.listeners = function listeners(event) {
            var evt = prefix ? prefix + event : event, handlers = this._events[evt];
            if (!handlers) return [];
            if (handlers.fn) return [
                handlers.fn
            ];
            for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){
                ee[i] = handlers[i].fn;
            }
            return ee;
        };
        /**
		 * Return the number of listeners listening to a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Number} The number of listeners.
		 * @public
		 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
            var evt = prefix ? prefix + event : event, listeners = this._events[evt];
            if (!listeners) return 0;
            if (listeners.fn) return 1;
            return listeners.length;
        };
        /**
		 * Calls each of the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Boolean} `true` if the event had listeners, else `false`.
		 * @public
		 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return false;
            var listeners = this._events[evt], len = arguments.length, args, i;
            if (listeners.fn) {
                if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
                switch(len){
                    case 1:
                        return listeners.fn.call(listeners.context), true;
                    case 2:
                        return listeners.fn.call(listeners.context, a1), true;
                    case 3:
                        return listeners.fn.call(listeners.context, a1, a2), true;
                    case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), true;
                    case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                    case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                }
                for(i = 1, args = new Array(len - 1); i < len; i++){
                    args[i - 1] = arguments[i];
                }
                listeners.fn.apply(listeners.context, args);
            } else {
                var length = listeners.length, j;
                for(i = 0; i < length; i++){
                    if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                    switch(len){
                        case 1:
                            listeners[i].fn.call(listeners[i].context);
                            break;
                        case 2:
                            listeners[i].fn.call(listeners[i].context, a1);
                            break;
                        case 3:
                            listeners[i].fn.call(listeners[i].context, a1, a2);
                            break;
                        case 4:
                            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                            break;
                        default:
                            if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){
                                args[j - 1] = arguments[j];
                            }
                            listeners[i].fn.apply(listeners[i].context, args);
                    }
                }
            }
            return true;
        };
        /**
		 * Add a listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */ EventEmitter.prototype.on = function on(event, fn, context) {
            return addListener(this, event, fn, context, false);
        };
        /**
		 * Add a one-time listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */ EventEmitter.prototype.once = function once(event, fn, context) {
            return addListener(this, event, fn, context, true);
        };
        /**
		 * Remove the listeners of a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn Only remove the listeners that match this function.
		 * @param {*} context Only remove the listeners that have this context.
		 * @param {Boolean} once Only remove one-time listeners.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;
            if (!fn) {
                clearEvent(this, evt);
                return this;
            }
            var listeners = this._events[evt];
            if (listeners.fn) {
                if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                    clearEvent(this, evt);
                }
            } else {
                for(var i = 0, events = [], length = listeners.length; i < length; i++){
                    if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                        events.push(listeners[i]);
                    }
                }
                //
                // Reset the array, or remove it completely if we have no more listeners.
                //
                if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
                else clearEvent(this, evt);
            }
            return this;
        };
        /**
		 * Remove all listeners, or those of the specified event.
		 *
		 * @param {(String|Symbol)} [event] The event name.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;
            if (event) {
                evt = prefix ? prefix + event : event;
                if (this._events[evt]) clearEvent(this, evt);
            } else {
                this._events = new Events();
                this._eventsCount = 0;
            }
            return this;
        };
        //
        // Alias methods names because people roll like that.
        //
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        //
        // Expose the prefix.
        //
        EventEmitter.prefixed = prefix;
        //
        // Allow `EventEmitter` to be imported as module namespace.
        //
        EventEmitter.EventEmitter = EventEmitter;
        //
        // Expose the module.
        //
        {
            module.exports = EventEmitter;
        }
    })(eventemitter3);
    return eventemitter3.exports;
}

var eventemitter3Exports = requireEventemitter3();
var EventEmitter = /*@__PURE__*/ getDefaultExportFromCjs(eventemitter3Exports);

function _assert_this_initialized$j(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator$3(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super$j(_this, derived, args) {
    derived = _get_prototype_of$j(derived);
    return _possible_constructor_return$j(_this, _is_native_reflect_construct$k() ? Reflect.construct(derived, args || [], _get_prototype_of$j(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$H(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct$6(Parent, args, Class) {
    if (_is_native_reflect_construct$k()) {
        _construct$6 = Reflect.construct;
    } else {
        _construct$6 = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of$k(instance, Class.prototype);
            return instance;
        };
    }
    return _construct$6.apply(null, arguments);
}
function _get_prototype_of$j(o) {
    _get_prototype_of$j = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$j(o);
}
function _inherits$j(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$k(subClass, superClass);
}
function _instanceof$x(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _is_native_function$5(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _possible_constructor_return$j(self, call) {
    if (call && (_type_of$O(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$j(self);
}
function _set_prototype_of$k(o, p) {
    _set_prototype_of$k = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$k(o, p);
}
function _type_of$O(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _wrap_native_super$5(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super$5 = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function$5(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct$6(Class, arguments, _get_prototype_of$j(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of$k(Wrapper, Class);
    };
    return _wrap_native_super$5(Class);
}
function _is_native_reflect_construct$k() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$k = function() {
        return !!result;
    })();
}
function _ts_generator$6(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
var TimeoutError = /*#__PURE__*/ function(Error1) {
    _inherits$j(TimeoutError, Error1);
    function TimeoutError(message) {
        _class_call_check$H(this, TimeoutError);
        var _this;
        _this = _call_super$j(this, TimeoutError, [
            message
        ]);
        _this.name = 'TimeoutError';
        return _this;
    }
    return TimeoutError;
}(_wrap_native_super$5(Error));
/**
An error to be thrown when the request is aborted by AbortController.
DOMException is thrown instead of this Error when DOMException is available.
*/ var AbortError = /*#__PURE__*/ function(Error1) {
    _inherits$j(AbortError, Error1);
    function AbortError(message) {
        _class_call_check$H(this, AbortError);
        var _this;
        _this = _call_super$j(this, AbortError);
        _this.name = 'AbortError';
        _this.message = message;
        return _this;
    }
    return AbortError;
}(_wrap_native_super$5(Error));
/**
TODO: Remove AbortError and just throw DOMException when targeting Node 18.
*/ var getDOMException = function(errorMessage) {
    return globalThis.DOMException === undefined ? new AbortError(errorMessage) : new DOMException(errorMessage);
};
/**
TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.
*/ var getAbortedReason = function(signal) {
    var reason = signal.reason === undefined ? getDOMException('This operation was aborted.') : signal.reason;
    return _instanceof$x(reason, Error) ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
    var milliseconds = options.milliseconds, fallback = options.fallback, message = options.message, _options_customTimers = options.customTimers, customTimers = _options_customTimers === undefined ? {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout
    } : _options_customTimers;
    var timer;
    var abortHandler;
    var wrappedPromise = new Promise(function(resolve, reject) {
        if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {
            throw new TypeError("Expected `milliseconds` to be a positive number, got `".concat(milliseconds, "`"));
        }
        if (options.signal) {
            var signal = options.signal;
            if (signal.aborted) {
                reject(getAbortedReason(signal));
            }
            abortHandler = function() {
                reject(getAbortedReason(signal));
            };
            signal.addEventListener('abort', abortHandler, {
                once: true
            });
        }
        if (milliseconds === Number.POSITIVE_INFINITY) {
            promise.then(resolve, reject);
            return;
        }
        // We create the error outside of `setTimeout` to preserve the stack trace.
        var timeoutError = new TimeoutError();
        timer = customTimers.setTimeout.call(undefined, function() {
            if (fallback) {
                try {
                    resolve(fallback());
                } catch (error) {
                    reject(error);
                }
                return;
            }
            if (typeof promise.cancel === 'function') {
                promise.cancel();
            }
            if (message === false) {
                resolve();
            } else if (_instanceof$x(message, Error)) {
                reject(message);
            } else {
                timeoutError.message = message !== null && message !== undefined ? message : "Promise timed out after ".concat(milliseconds, " milliseconds");
                reject(timeoutError);
            }
        }, milliseconds);
        _async_to_generator$3(function() {
            var error;
            return _ts_generator$6(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _state.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        return [
                            4,
                            promise
                        ];
                    case 1:
                        resolve.apply(undefined, [
                            _state.sent()
                        ]);
                        return [
                            3,
                            3
                        ];
                    case 2:
                        error = _state.sent();
                        reject(error);
                        return [
                            3,
                            3
                        ];
                    case 3:
                        return [
                            2
                        ];
                }
            });
        })();
    });
    var cancelablePromise = wrappedPromise.finally(function() {
        cancelablePromise.clear();
        if (abortHandler && options.signal) {
            options.signal.removeEventListener('abort', abortHandler);
        }
    });
    cancelablePromise.clear = function() {
        customTimers.clearTimeout.call(undefined, timer);
        timer = undefined;
    };
    return cancelablePromise;
}

// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
    var first = 0;
    var count = array.length;
    while(count > 0){
        var step = Math.trunc(count / 2);
        var it = first + step;
        if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
        } else {
            count = step;
        }
    }
    return first;
}

function _check_private_redeclaration$4(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get$4(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set$3(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_call_check$G(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _class_extract_field_descriptor$3(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get$3(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor$3(receiver, privateMap, "get");
    return _class_apply_descriptor_get$4(receiver, descriptor);
}
function _class_private_field_init$3(obj, privateMap, value) {
    _check_private_redeclaration$4(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set$3(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor$3(receiver, privateMap, "set");
    _class_apply_descriptor_set$3(receiver, descriptor, value);
    return value;
}
function _defineProperties$d(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$d(Constructor, protoProps, staticProps) {
    _defineProperties$d(Constructor.prototype, protoProps);
    return Constructor;
}
function _define_property$4(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread$3(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$4(target, key, source[key]);
        });
    }
    return target;
}
var _queue$1 = /*#__PURE__*/ new WeakMap();
var PriorityQueue = /*#__PURE__*/ function() {
    function PriorityQueue() {
        _class_call_check$G(this, PriorityQueue);
        _class_private_field_init$3(this, _queue$1, {
            writable: true,
            value: undefined
        });
        _class_private_field_set$3(this, _queue$1, []);
    }
    var _proto = PriorityQueue.prototype;
    _proto.enqueue = function enqueue(run, options) {
        options = _object_spread$3({
            priority: 0
        }, options);
        var element = {
            priority: options.priority,
            run: run
        };
        if (this.size && _class_private_field_get$3(this, _queue$1)[this.size - 1].priority >= options.priority) {
            _class_private_field_get$3(this, _queue$1).push(element);
            return;
        }
        var index = lowerBound(_class_private_field_get$3(this, _queue$1), element, function(a, b) {
            return b.priority - a.priority;
        });
        _class_private_field_get$3(this, _queue$1).splice(index, 0, element);
    };
    _proto.dequeue = function dequeue() {
        var item = _class_private_field_get$3(this, _queue$1).shift();
        return item === null || item === undefined ? undefined : item.run;
    };
    _proto.filter = function filter(options) {
        return _class_private_field_get$3(this, _queue$1).filter(function(element) {
            return element.priority === options.priority;
        }).map(function(element) {
            return element.run;
        });
    };
    _create_class$d(PriorityQueue, [
        {
            key: "size",
            get: function get() {
                return _class_private_field_get$3(this, _queue$1).length;
            }
        }
    ]);
    return PriorityQueue;
}();

function _assert_this_initialized$i(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator$2(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super$i(_this, derived, args) {
    derived = _get_prototype_of$i(derived);
    return _possible_constructor_return$i(_this, _is_native_reflect_construct$j() ? Reflect.construct(derived, [], _get_prototype_of$i(_this).constructor) : derived.apply(_this, args));
}
function _check_private_redeclaration$3(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get$3(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set$2(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_apply_descriptor_update$1(receiver, descriptor) {
    if (descriptor.set) {
        if (!descriptor.get) {
            throw new TypeError("attempted to read set only private field");
        }
        if (!("__destrWrapper" in descriptor)) {
            descriptor.__destrWrapper = {
                set value (v){
                    descriptor.set.call(receiver, v);
                },
                get value () {
                    return descriptor.get.call(receiver);
                }
            };
        }
        return descriptor.__destrWrapper;
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        return descriptor;
    }
}
function _class_call_check$F(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _class_extract_field_descriptor$2(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get$2(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor$2(receiver, privateMap, "get");
    return _class_apply_descriptor_get$3(receiver, descriptor);
}
function _class_private_field_init$2(obj, privateMap, value) {
    _check_private_redeclaration$3(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set$2(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor$2(receiver, privateMap, "set");
    _class_apply_descriptor_set$2(receiver, descriptor, value);
    return value;
}
function _class_private_field_update$1(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor$2(receiver, privateMap, "update");
    return _class_apply_descriptor_update$1(receiver, descriptor);
}
function _class_private_method_get$3(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init$3(obj, privateSet) {
    _check_private_redeclaration$3(obj, privateSet);
    privateSet.add(obj);
}
function _defineProperties$c(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$c(Constructor, protoProps, staticProps) {
    _defineProperties$c(Constructor.prototype, protoProps);
    return Constructor;
}
function _define_property$3(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of$i(o) {
    _get_prototype_of$i = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$i(o);
}
function _inherits$i(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$j(subClass, superClass);
}
function _instanceof$w(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _object_spread$2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$3(target, key, source[key]);
        });
    }
    return target;
}
function _possible_constructor_return$i(self, call) {
    if (call && (_type_of$N(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$i(self);
}
function _set_prototype_of$j(o, p) {
    _set_prototype_of$j = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$j(o, p);
}
function _type_of$N(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$j() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$j = function() {
        return !!result;
    })();
}
function _ts_generator$5(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v1) {
            return step([
                n,
                v1
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
var _carryoverConcurrencyCount = /*#__PURE__*/ new WeakMap(), _isIntervalIgnored = /*#__PURE__*/ new WeakMap(), _intervalCount = /*#__PURE__*/ new WeakMap(), _intervalCap = /*#__PURE__*/ new WeakMap(), _interval = /*#__PURE__*/ new WeakMap(), _intervalEnd = /*#__PURE__*/ new WeakMap(), _intervalId = /*#__PURE__*/ new WeakMap(), _timeoutId = /*#__PURE__*/ new WeakMap(), _queue = /*#__PURE__*/ new WeakMap(), _queueClass = /*#__PURE__*/ new WeakMap(), _pending = /*#__PURE__*/ new WeakMap(), // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
_concurrency = /*#__PURE__*/ new WeakMap(), _isPaused = /*#__PURE__*/ new WeakMap(), _throwOnTimeout = /*#__PURE__*/ new WeakMap(), _doesIntervalAllowAnother = /*#__PURE__*/ new WeakMap(), _doesConcurrentAllowAnother = /*#__PURE__*/ new WeakMap(), _next$1 = /*#__PURE__*/ new WeakSet(), _onResumeInterval = /*#__PURE__*/ new WeakSet(), _isIntervalPaused = /*#__PURE__*/ new WeakMap(), _tryToStartAnother = /*#__PURE__*/ new WeakSet(), _initializeIntervalIfNeeded = /*#__PURE__*/ new WeakSet(), _onInterval = /*#__PURE__*/ new WeakSet(), /**
    Executes all queued functions until it reaches the limit.
    */ _processQueue = /*#__PURE__*/ new WeakSet(), _throwOnAbort = /*#__PURE__*/ new WeakSet(), _onEvent = /*#__PURE__*/ new WeakSet();
var PQueue = /*#__PURE__*/ function(EventEmitter) {
    _inherits$i(PQueue, EventEmitter);
    function PQueue(options) {
        _class_call_check$F(this, PQueue);
        var _this;
        _this = _call_super$i(this, PQueue), _class_private_field_init$2(_this, _doesIntervalAllowAnother, {
            get: get_doesIntervalAllowAnother,
            set: undefined
        }), _class_private_field_init$2(_this, _doesConcurrentAllowAnother, {
            get: get_doesConcurrentAllowAnother,
            set: undefined
        }), _class_private_method_init$3(_this, _next$1), _class_private_method_init$3(_this, _onResumeInterval), _class_private_field_init$2(_this, _isIntervalPaused, {
            get: get_isIntervalPaused,
            set: undefined
        }), _class_private_method_init$3(_this, _tryToStartAnother), _class_private_method_init$3(_this, _initializeIntervalIfNeeded), _class_private_method_init$3(_this, _onInterval), _class_private_method_init$3(_this, _processQueue), _class_private_method_init$3(_this, _throwOnAbort), _class_private_method_init$3(_this, _onEvent), _class_private_field_init$2(_this, _carryoverConcurrencyCount, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _isIntervalIgnored, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _intervalCount, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _intervalCap, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _interval, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _intervalEnd, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _intervalId, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _timeoutId, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _queue, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _queueClass, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _pending, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _concurrency, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _isPaused, {
            writable: true,
            value: undefined
        }), _class_private_field_init$2(_this, _throwOnTimeout, {
            writable: true,
            value: undefined
        }), _class_private_field_set$2(_this, _intervalCount, 0), _class_private_field_set$2(_this, _intervalEnd, 0), _class_private_field_set$2(_this, _pending, 0);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        options = _object_spread$2({
            carryoverConcurrencyCount: false,
            intervalCap: Number.POSITIVE_INFINITY,
            interval: 0,
            concurrency: Number.POSITIVE_INFINITY,
            autoStart: true,
            queueClass: PriorityQueue
        }, options);
        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
            var _options_intervalCap;
            var _options_intervalCap_toString;
            throw new TypeError("Expected `intervalCap` to be a number from 1 and up, got `".concat((_options_intervalCap_toString = (_options_intervalCap = options.intervalCap) === null || _options_intervalCap === undefined ? undefined : _options_intervalCap.toString()) !== null && _options_intervalCap_toString !== undefined ? _options_intervalCap_toString : '', "` (").concat(_type_of$N(options.intervalCap), ")"));
        }
        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
            var _options_interval;
            var _options_interval_toString;
            throw new TypeError("Expected `interval` to be a finite number >= 0, got `".concat((_options_interval_toString = (_options_interval = options.interval) === null || _options_interval === undefined ? undefined : _options_interval.toString()) !== null && _options_interval_toString !== undefined ? _options_interval_toString : '', "` (").concat(_type_of$N(options.interval), ")"));
        }
        _class_private_field_set$2(_this, _carryoverConcurrencyCount, options.carryoverConcurrencyCount);
        _class_private_field_set$2(_this, _isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0);
        _class_private_field_set$2(_this, _intervalCap, options.intervalCap);
        _class_private_field_set$2(_this, _interval, options.interval);
        _class_private_field_set$2(_this, _queue, new options.queueClass());
        _class_private_field_set$2(_this, _queueClass, options.queueClass);
        _this.concurrency = options.concurrency;
        _this.timeout = options.timeout;
        _class_private_field_set$2(_this, _throwOnTimeout, options.throwOnTimeout === true);
        _class_private_field_set$2(_this, _isPaused, options.autoStart === false);
        return _this;
    }
    var _proto = PQueue.prototype;
    _proto.add = function add(function_) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _this = this;
        return _async_to_generator$2(function() {
            return _ts_generator$5(this, function(_state) {
                options = _object_spread$2({
                    timeout: _this.timeout,
                    throwOnTimeout: _class_private_field_get$2(_this, _throwOnTimeout)
                }, options);
                return [
                    2,
                    new Promise(function(resolve, reject) {
                        _class_private_field_get$2(_this, _queue).enqueue(/*#__PURE__*/ _async_to_generator$2(function() {
                            var _options_signal, operation, result, error;
                            return _ts_generator$5(this, function(_state) {
                                switch(_state.label){
                                    case 0:
                                        _class_private_field_update$1(_this, _pending).value++;
                                        _class_private_field_update$1(_this, _intervalCount).value++;
                                        _state.label = 1;
                                    case 1:
                                        _state.trys.push([
                                            1,
                                            3,
                                            4,
                                            5
                                        ]);
                                        (_options_signal = options.signal) === null || _options_signal === undefined ? undefined : _options_signal.throwIfAborted();
                                        operation = function_({
                                            signal: options.signal
                                        });
                                        if (options.timeout) {
                                            operation = pTimeout(Promise.resolve(operation), {
                                                milliseconds: options.timeout
                                            });
                                        }
                                        if (options.signal) {
                                            operation = Promise.race([
                                                operation,
                                                _class_private_method_get$3(_this, _throwOnAbort, throwOnAbort).call(_this, options.signal)
                                            ]);
                                        }
                                        return [
                                            4,
                                            operation
                                        ];
                                    case 2:
                                        result = _state.sent();
                                        resolve(result);
                                        _this.emit('completed', result);
                                        return [
                                            3,
                                            5
                                        ];
                                    case 3:
                                        error = _state.sent();
                                        if (_instanceof$w(error, TimeoutError) && !options.throwOnTimeout) {
                                            resolve();
                                            return [
                                                2
                                            ];
                                        }
                                        reject(error);
                                        _this.emit('error', error);
                                        return [
                                            3,
                                            5
                                        ];
                                    case 4:
                                        _class_private_method_get$3(_this, _next$1, next).call(_this);
                                        return [
                                            7
                                        ];
                                    case 5:
                                        return [
                                            2
                                        ];
                                }
                            });
                        }), options);
                        _this.emit('add');
                        _class_private_method_get$3(_this, _tryToStartAnother, tryToStartAnother).call(_this);
                    })
                ];
            });
        })();
    };
    _proto.addAll = function addAll(functions, options) {
        var _this = this;
        return _async_to_generator$2(function() {
            return _ts_generator$5(this, function(_state) {
                return [
                    2,
                    Promise.all(functions.map(/*#__PURE__*/ function() {
                        var _ref = _async_to_generator$2(function(function_) {
                            return _ts_generator$5(this, function(_state) {
                                return [
                                    2,
                                    _this.add(function_, options)
                                ];
                            });
                        });
                        return function(function_) {
                            return _ref.apply(this, arguments);
                        };
                    }()))
                ];
            });
        })();
    };
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */ _proto.start = function start() {
        if (!_class_private_field_get$2(this, _isPaused)) {
            return this;
        }
        _class_private_field_set$2(this, _isPaused, false);
        _class_private_method_get$3(this, _processQueue, processQueue).call(this);
        return this;
    };
    /**
    Put queue execution on hold.
    */ _proto.pause = function pause() {
        _class_private_field_set$2(this, _isPaused, true);
    };
    /**
    Clear the queue.
    */ _proto.clear = function clear() {
        _class_private_field_set$2(this, _queue, new (_class_private_field_get$2(this, _queueClass))());
    };
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */ _proto.onEmpty = function onEmpty() {
        var _this = this;
        return _async_to_generator$2(function() {
            return _ts_generator$5(this, function(_state) {
                switch(_state.label){
                    case 0:
                        // Instantly resolve if the queue is empty
                        if (_class_private_field_get$2(_this, _queue).size === 0) {
                            return [
                                2
                            ];
                        }
                        return [
                            4,
                            _class_private_method_get$3(_this, _onEvent, onEvent).call(_this, 'empty')
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        })();
    };
    /**
    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.

    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.

    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
    */ _proto.onSizeLessThan = function onSizeLessThan(limit) {
        var _this = this;
        return _async_to_generator$2(function() {
            return _ts_generator$5(this, function(_state) {
                switch(_state.label){
                    case 0:
                        // Instantly resolve if the queue is empty.
                        if (_class_private_field_get$2(_this, _queue).size < limit) {
                            return [
                                2
                            ];
                        }
                        return [
                            4,
                            _class_private_method_get$3(_this, _onEvent, onEvent).call(_this, 'next', function() {
                                return _class_private_field_get$2(_this, _queue).size < limit;
                            })
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        })();
    };
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */ _proto.onIdle = function onIdle() {
        var _this = this;
        return _async_to_generator$2(function() {
            return _ts_generator$5(this, function(_state) {
                switch(_state.label){
                    case 0:
                        // Instantly resolve if none pending and if nothing else is queued
                        if (_class_private_field_get$2(_this, _pending) === 0 && _class_private_field_get$2(_this, _queue).size === 0) {
                            return [
                                2
                            ];
                        }
                        return [
                            4,
                            _class_private_method_get$3(_this, _onEvent, onEvent).call(_this, 'idle')
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        })();
    };
    /**
    Size of the queue, filtered by the given options.

    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */ _proto.sizeBy = function sizeBy(options) {
        // eslint-disable-next-line unicorn/no-array-callback-reference
        return _class_private_field_get$2(this, _queue).filter(options).length;
    };
    _create_class$c(PQueue, [
        {
            key: "concurrency",
            get: function get() {
                return _class_private_field_get$2(this, _concurrency);
            },
            set: function set(newConcurrency) {
                if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
                    throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(newConcurrency, "` (").concat(typeof newConcurrency === "undefined" ? "undefined" : _type_of$N(newConcurrency), ")"));
                }
                _class_private_field_set$2(this, _concurrency, newConcurrency);
                _class_private_method_get$3(this, _processQueue, processQueue).call(this);
            }
        },
        {
            key: "size",
            get: /**
    Size of the queue, the number of queued items waiting to run.
    */ function get() {
                return _class_private_field_get$2(this, _queue).size;
            }
        },
        {
            key: "pending",
            get: /**
    Number of running items (no longer in the queue).
    */ function get() {
                return _class_private_field_get$2(this, _pending);
            }
        },
        {
            key: "isPaused",
            get: /**
    Whether the queue is currently paused.
    */ function get() {
                return _class_private_field_get$2(this, _isPaused);
            }
        }
    ]);
    return PQueue;
}(EventEmitter);
function get_doesIntervalAllowAnother() {
    return _class_private_field_get$2(this, _isIntervalIgnored) || _class_private_field_get$2(this, _intervalCount) < _class_private_field_get$2(this, _intervalCap);
}
function get_doesConcurrentAllowAnother() {
    return _class_private_field_get$2(this, _pending) < _class_private_field_get$2(this, _concurrency);
}
function next() {
    _class_private_field_update$1(this, _pending).value--;
    _class_private_method_get$3(this, _tryToStartAnother, tryToStartAnother).call(this);
    this.emit('next');
}
function onResumeInterval() {
    _class_private_method_get$3(this, _onInterval, onInterval).call(this);
    _class_private_method_get$3(this, _initializeIntervalIfNeeded, initializeIntervalIfNeeded).call(this);
    _class_private_field_set$2(this, _timeoutId, undefined);
}
function get_isIntervalPaused() {
    var _this = this;
    var now = Date.now();
    if (_class_private_field_get$2(this, _intervalId) === undefined) {
        var delay = _class_private_field_get$2(this, _intervalEnd) - now;
        if (delay < 0) {
            // Act as the interval was done
            // We don't need to resume it here because it will be resumed on line 160
            _class_private_field_set$2(this, _intervalCount, _class_private_field_get$2(this, _carryoverConcurrencyCount) ? _class_private_field_get$2(this, _pending) : 0);
        } else {
            // Act as the interval is pending
            if (_class_private_field_get$2(this, _timeoutId) === undefined) {
                _class_private_field_set$2(this, _timeoutId, setTimeout(function() {
                    _class_private_method_get$3(_this, _onResumeInterval, onResumeInterval).call(_this);
                }, delay));
            }
            return true;
        }
    }
    return false;
}
function tryToStartAnother() {
    if (_class_private_field_get$2(this, _queue).size === 0) {
        // We can clear the interval ("pause")
        // Because we can redo it later ("resume")
        if (_class_private_field_get$2(this, _intervalId)) {
            clearInterval(_class_private_field_get$2(this, _intervalId));
        }
        _class_private_field_set$2(this, _intervalId, undefined);
        this.emit('empty');
        if (_class_private_field_get$2(this, _pending) === 0) {
            this.emit('idle');
        }
        return false;
    }
    if (!_class_private_field_get$2(this, _isPaused)) {
        var canInitializeInterval = !_class_private_field_get$2(this, _isIntervalPaused);
        if (_class_private_field_get$2(this, _doesIntervalAllowAnother) && _class_private_field_get$2(this, _doesConcurrentAllowAnother)) {
            var job = _class_private_field_get$2(this, _queue).dequeue();
            if (!job) {
                return false;
            }
            this.emit('active');
            job();
            if (canInitializeInterval) {
                _class_private_method_get$3(this, _initializeIntervalIfNeeded, initializeIntervalIfNeeded).call(this);
            }
            return true;
        }
    }
    return false;
}
function initializeIntervalIfNeeded() {
    var _this = this;
    if (_class_private_field_get$2(this, _isIntervalIgnored) || _class_private_field_get$2(this, _intervalId) !== undefined) {
        return;
    }
    _class_private_field_set$2(this, _intervalId, setInterval(function() {
        _class_private_method_get$3(_this, _onInterval, onInterval).call(_this);
    }, _class_private_field_get$2(this, _interval)));
    _class_private_field_set$2(this, _intervalEnd, Date.now() + _class_private_field_get$2(this, _interval));
}
function onInterval() {
    if (_class_private_field_get$2(this, _intervalCount) === 0 && _class_private_field_get$2(this, _pending) === 0 && _class_private_field_get$2(this, _intervalId)) {
        clearInterval(_class_private_field_get$2(this, _intervalId));
        _class_private_field_set$2(this, _intervalId, undefined);
    }
    _class_private_field_set$2(this, _intervalCount, _class_private_field_get$2(this, _carryoverConcurrencyCount) ? _class_private_field_get$2(this, _pending) : 0);
    _class_private_method_get$3(this, _processQueue, processQueue).call(this);
}
function processQueue() {
    // eslint-disable-next-line no-empty
    while(_class_private_method_get$3(this, _tryToStartAnother, tryToStartAnother).call(this)){}
}
function throwOnAbort(signal) {
    return _throwOnAbort1.apply(this, arguments);
}
function _throwOnAbort1() {
    _throwOnAbort1 = _async_to_generator$2(function(signal) {
        return _ts_generator$5(this, function(_state) {
            return [
                2,
                new Promise(function(_resolve, reject) {
                    signal.addEventListener('abort', function() {
                        reject(signal.reason);
                    }, {
                        once: true
                    });
                })
            ];
        });
    });
    return _throwOnAbort1.apply(this, arguments);
}
function onEvent(event, filter) {
    return _onEvent1.apply(this, arguments);
}
function _onEvent1() {
    _onEvent1 = _async_to_generator$2(function(event, filter) {
        var _this;
        return _ts_generator$5(this, function(_state) {
            _this = this;
            return [
                2,
                new Promise(function(resolve) {
                    var listener = function() {
                        if (filter && !filter()) {
                            return;
                        }
                        _this.off(event, listener);
                        resolve();
                    };
                    _this.on(event, listener);
                })
            ];
        });
    });
    return _onEvent1.apply(this, arguments);
}

var npa$1 = {
    exports: {}
};

/**
 * @module LRUCache
 */ function _array_like_to_array$s(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$j(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes$c(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$s(arr);
}
function _assert_this_initialized$h(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator$1(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super$h(_this, derived, args) {
    derived = _get_prototype_of$h(derived);
    return _possible_constructor_return$h(_this, _is_native_reflect_construct$i() ? Reflect.construct(derived, args, _get_prototype_of$h(_this).constructor) : derived.apply(_this, args));
}
function _check_private_redeclaration$2(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get$2(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set$1(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_apply_descriptor_update(receiver, descriptor) {
    if (descriptor.set) {
        if (!descriptor.get) {
            throw new TypeError("attempted to read set only private field");
        }
        if (!("__destrWrapper" in descriptor)) {
            descriptor.__destrWrapper = {
                set value (v){
                    descriptor.set.call(receiver, v);
                },
                get value () {
                    return descriptor.get.call(receiver);
                }
            };
        }
        return descriptor.__destrWrapper;
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        return descriptor;
    }
}
function _class_call_check$E(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _class_check_private_static_field_descriptor$1(descriptor, action) {
    if (descriptor === undefined) {
        throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
}
function _class_extract_field_descriptor$1(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get$1(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor$1(receiver, privateMap, "get");
    return _class_apply_descriptor_get$2(receiver, descriptor);
}
function _class_private_field_init$1(obj, privateMap, value) {
    _check_private_redeclaration$2(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set$1(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor$1(receiver, privateMap, "set");
    _class_apply_descriptor_set$1(receiver, descriptor, value);
    return value;
}
function _class_private_field_update(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor$1(receiver, privateMap, "update");
    return _class_apply_descriptor_update(receiver, descriptor);
}
function _class_private_method_get$2(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init$2(obj, privateSet) {
    _check_private_redeclaration$2(obj, privateSet);
    privateSet.add(obj);
}
function _class_static_private_field_spec_get$1(receiver, classConstructor, descriptor) {
    _class_check_private_static_access$1(receiver, classConstructor);
    _class_check_private_static_field_descriptor$1(descriptor, "get");
    return _class_apply_descriptor_get$2(receiver, descriptor);
}
function _class_static_private_field_spec_set(receiver, classConstructor, descriptor, value) {
    _class_check_private_static_access$1(receiver, classConstructor);
    _class_check_private_static_field_descriptor$1(descriptor, "set");
    _class_apply_descriptor_set$1(receiver, descriptor, value);
    return value;
}
function _construct$5(Parent, args, Class) {
    if (_is_native_reflect_construct$i()) {
        _construct$5 = Reflect.construct;
    } else {
        _construct$5 = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of$i(instance, Class.prototype);
            return instance;
        };
    }
    return _construct$5.apply(null, arguments);
}
function _defineProperties$b(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$b(Constructor, protoProps, staticProps) {
    _defineProperties$b(Constructor.prototype, protoProps);
    return Constructor;
}
function _define_property$2(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of$h(o) {
    _get_prototype_of$h = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$h(o);
}
function _inherits$h(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$i(subClass, superClass);
}
function _instanceof$v(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _is_native_function$4(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array$e(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit$h(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$j() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread$c() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread$1(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$2(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props$1(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys$1(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _possible_constructor_return$h(self, call) {
    if (call && (_type_of$M(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$h(self);
}
function _set_prototype_of$i(o, p) {
    _set_prototype_of$i = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$i(o, p);
}
function _sliced_to_array$h(arr, i) {
    return _array_with_holes$j(arr) || _iterable_to_array_limit$h(arr, i) || _unsupported_iterable_to_array$s(arr, i) || _non_iterable_rest$j();
}
function _to_consumable_array$c(arr) {
    return _array_without_holes$c(arr) || _iterable_to_array$e(arr) || _unsupported_iterable_to_array$s(arr) || _non_iterable_spread$c();
}
function _type_of$M(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$s(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$s(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$s(o, minLen);
}
function _wrap_native_super$4(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super$4 = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function$4(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct$5(Class, arguments, _get_prototype_of$h(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of$i(Wrapper, Class);
    };
    return _wrap_native_super$4(Class);
}
function _class_check_private_static_access$1(receiver, classConstructor) {
    if (receiver !== classConstructor) {
        throw new TypeError("Private static access of wrong provenance");
    }
}
function _is_native_reflect_construct$i() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$i = function() {
        return !!result;
    })();
}
function _ts_generator$4(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v1) {
            return step([
                n,
                v1
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
var perf = (typeof performance === "undefined" ? "undefined" : _type_of$M(performance)) === 'object' && performance && typeof performance.now === 'function' ? performance : Date;
var warned = new Set();
/* c8 ignore start */ var PROCESS = (typeof process === "undefined" ? "undefined" : _type_of$M(process)) === 'object' && !!process ? process : {};
/* c8 ignore start */ var emitWarning = function(msg, type, code, fn) {
    typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error("[".concat(code, "] ").concat(type, ": ").concat(msg));
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
/* c8 ignore start */ if (typeof AC === 'undefined') {
    var _PROCESS_env;
    //@ts-ignore
    AS = /*#__PURE__*/ function() {
        function AbortSignal() {
            _class_call_check$E(this, AbortSignal);
            this._onabort = [];
            this.aborted = false;
        }
        var _proto = AbortSignal.prototype;
        _proto.addEventListener = function addEventListener(_, fn) {
            this._onabort.push(fn);
        };
        return AbortSignal;
    }();
    //@ts-ignore
    AC = /*#__PURE__*/ function() {
        function AbortController() {
            _class_call_check$E(this, AbortController);
            this.signal = new AS();
            warnACPolyfill();
        }
        var _proto = AbortController.prototype;
        _proto.abort = function abort(reason) {
            var _this_signal_onabort, _this_signal;
            if (this.signal.aborted) return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                //@ts-ignore
                for(var _iterator = this.signal._onabort[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var fn = _step.value;
                    fn(reason);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            (_this_signal_onabort = (_this_signal = this.signal).onabort) === null || _this_signal_onabort === undefined ? undefined : _this_signal_onabort.call(_this_signal, reason);
        };
        return AbortController;
    }();
    var printACPolyfillWarning = ((_PROCESS_env = PROCESS.env) === null || _PROCESS_env === undefined ? undefined : _PROCESS_env.LRU_CACHE_IGNORE_AC_WARNING) !== '1';
    var warnACPolyfill = function() {
        if (!printACPolyfillWarning) return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */ var shouldWarn = function(code) {
    return !warned.has(code);
};
var isPosInt = function(n) {
    return n && n === Math.floor(n) && n > 0 && isFinite(n);
};
/* c8 ignore start */ // This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
var getUintArray = function(max) {
    return !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
};
/* c8 ignore stop */ var ZeroArray = /*#__PURE__*/ function(Array1) {
    _inherits$h(ZeroArray, Array1);
    function ZeroArray(size) {
        _class_call_check$E(this, ZeroArray);
        var _this;
        _this = _call_super$h(this, ZeroArray, [
            size
        ]);
        _this.fill(0);
        return _this;
    }
    return ZeroArray;
}(_wrap_native_super$4(Array));
var Stack = /*#__PURE__*/ function() {
    function Stack(max, HeapCls) {
        _class_call_check$E(this, Stack);
        /* c8 ignore start */ if (!_class_static_private_field_spec_get$1(Stack, Stack, _constructing)) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */ this.heap = new HeapCls(max);
        this.length = 0;
    }
    var _proto = Stack.prototype;
    _proto.push = function push(n) {
        this.heap[this.length++] = n;
    };
    _proto.pop = function pop() {
        return this.heap[--this.length];
    };
    Stack.create = function create(max) {
        var HeapCls = getUintArray(max);
        if (!HeapCls) return [];
        _class_static_private_field_spec_set(Stack, Stack, _constructing, true);
        var s = new Stack(max, HeapCls);
        _class_static_private_field_spec_set(Stack, Stack, _constructing, false);
        return s;
    };
    return Stack;
}();
// private constructor
var _constructing = {
    writable: true,
    value: false
};
var prop;
var // options that cannot be changed without disaster
_max = /*#__PURE__*/ new WeakMap(), _maxSize = /*#__PURE__*/ new WeakMap(), _dispose = /*#__PURE__*/ new WeakMap(), _disposeAfter = /*#__PURE__*/ new WeakMap(), _fetchMethod = /*#__PURE__*/ new WeakMap(), _memoMethod = /*#__PURE__*/ new WeakMap(), // computed properties
_size = /*#__PURE__*/ new WeakMap(), _calculatedSize = /*#__PURE__*/ new WeakMap(), _keyMap = /*#__PURE__*/ new WeakMap(), _keyList = /*#__PURE__*/ new WeakMap(), _valList = /*#__PURE__*/ new WeakMap(), _next = /*#__PURE__*/ new WeakMap(), _prev = /*#__PURE__*/ new WeakMap(), _head = /*#__PURE__*/ new WeakMap(), _tail = /*#__PURE__*/ new WeakMap(), _free = /*#__PURE__*/ new WeakMap(), _disposed = /*#__PURE__*/ new WeakMap(), _sizes = /*#__PURE__*/ new WeakMap(), _starts = /*#__PURE__*/ new WeakMap(), _ttls = /*#__PURE__*/ new WeakMap(), _hasDispose = /*#__PURE__*/ new WeakMap(), _hasFetchMethod = /*#__PURE__*/ new WeakMap(), _hasDisposeAfter = /*#__PURE__*/ new WeakMap(), _initializeTTLTracking = /*#__PURE__*/ new WeakSet(), // conditionally set private methods related to TTL
_updateItemAge = /*#__PURE__*/ new WeakMap(), _statusTTL = /*#__PURE__*/ new WeakMap(), _setItemTTL = /*#__PURE__*/ new WeakMap(), /* c8 ignore stop */ _isStale = /*#__PURE__*/ new WeakMap(), _initializeSizeTracking = /*#__PURE__*/ new WeakSet(), _removeItemSize = /*#__PURE__*/ new WeakMap(), _addItemSize = /*#__PURE__*/ new WeakMap(), _requireSize = /*#__PURE__*/ new WeakMap(), _indexes = /*#__PURE__*/ new WeakSet(), _rindexes = /*#__PURE__*/ new WeakSet(), _isValidIndex = /*#__PURE__*/ new WeakSet(), _evict = /*#__PURE__*/ new WeakSet(), _backgroundFetch = /*#__PURE__*/ new WeakSet(), _isBackgroundFetch = /*#__PURE__*/ new WeakSet(), _connect = /*#__PURE__*/ new WeakSet(), _moveToTail = /*#__PURE__*/ new WeakSet(), _delete = /*#__PURE__*/ new WeakSet(), _clear = /*#__PURE__*/ new WeakSet();
var _Symbol_iterator = Symbol.iterator;
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */ var LRUCache = /*#__PURE__*/ function() {
    function LRUCache(options) {
        _class_call_check$E(this, LRUCache);
        _class_private_method_init$2(this, _initializeTTLTracking);
        _class_private_method_init$2(this, _initializeSizeTracking);
        _class_private_method_init$2(this, _indexes);
        _class_private_method_init$2(this, _rindexes);
        _class_private_method_init$2(this, _isValidIndex);
        _class_private_method_init$2(this, _evict);
        _class_private_method_init$2(this, _backgroundFetch);
        _class_private_method_init$2(this, _isBackgroundFetch);
        _class_private_method_init$2(this, _connect);
        _class_private_method_init$2(this, _moveToTail);
        _class_private_method_init$2(this, _delete);
        _class_private_method_init$2(this, _clear);
        _class_private_field_init$1(this, _max, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _maxSize, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _dispose, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _disposeAfter, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _fetchMethod, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _memoMethod, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _size, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _calculatedSize, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _keyMap, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _keyList, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _valList, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _next, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _prev, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _head, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _tail, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _free, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _disposed, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _sizes, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _starts, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _ttls, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _hasDispose, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _hasFetchMethod, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _hasDisposeAfter, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _updateItemAge, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _statusTTL, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _setItemTTL, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _isStale, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _removeItemSize, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _addItemSize, {
            writable: true,
            value: undefined
        });
        _class_private_field_init$1(this, _requireSize, {
            writable: true,
            value: undefined
        });
        _class_private_field_set$1(this, _updateItemAge, function() {});
        _class_private_field_set$1(this, _statusTTL, function() {});
        _class_private_field_set$1(this, _setItemTTL, function() {});
        _class_private_field_set$1(this, _isStale, function() {
            return false;
        });
        _class_private_field_set$1(this, _removeItemSize, function(_i) {});
        _class_private_field_set$1(this, _addItemSize, function(_i, _s, _st) {});
        _class_private_field_set$1(this, _requireSize, function(_k, _v, size, sizeCalculation) {
            if (size || sizeCalculation) {
                throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
            }
            return 0;
        });
        /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */ this[prop] = 'LRUCache';
        var _options_max = options.max, max = _options_max === undefined ? 0 : _options_max, ttl = options.ttl, _options_ttlResolution = options.ttlResolution, ttlResolution = _options_ttlResolution === undefined ? 1 : _options_ttlResolution, ttlAutopurge = options.ttlAutopurge, updateAgeOnGet = options.updateAgeOnGet, updateAgeOnHas = options.updateAgeOnHas, allowStale = options.allowStale, dispose = options.dispose, disposeAfter = options.disposeAfter, noDisposeOnSet = options.noDisposeOnSet, noUpdateTTL = options.noUpdateTTL, _options_maxSize = options.maxSize, maxSize = _options_maxSize === undefined ? 0 : _options_maxSize, _options_maxEntrySize = options.maxEntrySize, maxEntrySize = _options_maxEntrySize === undefined ? 0 : _options_maxEntrySize, sizeCalculation = options.sizeCalculation, fetchMethod = options.fetchMethod, memoMethod = options.memoMethod, noDeleteOnFetchRejection = options.noDeleteOnFetchRejection, noDeleteOnStaleGet = options.noDeleteOnStaleGet, allowStaleOnFetchRejection = options.allowStaleOnFetchRejection, allowStaleOnFetchAbort = options.allowStaleOnFetchAbort, ignoreFetchAbort = options.ignoreFetchAbort;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        var UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        _class_private_field_set$1(this, _max, max);
        _class_private_field_set$1(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || _class_private_field_get$1(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!_class_private_field_get$1(this, _maxSize) && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined && typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        _class_private_field_set$1(this, _memoMethod, memoMethod);
        if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        _class_private_field_set$1(this, _fetchMethod, fetchMethod);
        _class_private_field_set$1(this, _hasFetchMethod, !!fetchMethod);
        _class_private_field_set$1(this, _keyMap, new Map());
        _class_private_field_set$1(this, _keyList, new Array(max).fill(undefined));
        _class_private_field_set$1(this, _valList, new Array(max).fill(undefined));
        _class_private_field_set$1(this, _next, new UintArray(max));
        _class_private_field_set$1(this, _prev, new UintArray(max));
        _class_private_field_set$1(this, _head, 0);
        _class_private_field_set$1(this, _tail, 0);
        _class_private_field_set$1(this, _free, Stack.create(max));
        _class_private_field_set$1(this, _size, 0);
        _class_private_field_set$1(this, _calculatedSize, 0);
        if (typeof dispose === 'function') {
            _class_private_field_set$1(this, _dispose, dispose);
        }
        if (typeof disposeAfter === 'function') {
            _class_private_field_set$1(this, _disposeAfter, disposeAfter);
            _class_private_field_set$1(this, _disposed, []);
        } else {
            _class_private_field_set$1(this, _disposeAfter, undefined);
            _class_private_field_set$1(this, _disposed, undefined);
        }
        _class_private_field_set$1(this, _hasDispose, !!_class_private_field_get$1(this, _dispose));
        _class_private_field_set$1(this, _hasDisposeAfter, !!_class_private_field_get$1(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (_class_private_field_get$1(this, _maxSize) !== 0) {
                if (!isPosInt(_class_private_field_get$1(this, _maxSize))) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            _class_private_method_get$2(this, _initializeSizeTracking, initializeSizeTracking).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            _class_private_method_get$2(this, _initializeTTLTracking, initializeTTLTracking).call(this);
        }
        // do not allow completely unbounded caches
        if (_class_private_field_get$1(this, _max) === 0 && this.ttl === 0 && _class_private_field_get$1(this, _maxSize) === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !_class_private_field_get$1(this, _max) && !_class_private_field_get$1(this, _maxSize)) {
            var code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                var msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    var _proto = LRUCache.prototype;
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */ _proto.getRemainingTTL = function getRemainingTTL(key) {
        return _class_private_field_get$1(this, _keyMap).has(key) ? Infinity : 0;
    };
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */ _proto.entries = function entries() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, err;
        return _ts_generator$4(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        6,
                        7,
                        8
                    ]);
                    _iterator = _class_private_method_get$2(this, _indexes, indexes).call(this)[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        5
                    ];
                    i = _step.value;
                    if (!(_class_private_field_get$1(this, _valList)[i] !== undefined && _class_private_field_get$1(this, _keyList)[i] !== undefined && !_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get$1(this, _valList)[i]))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        [
                            _class_private_field_get$1(this, _keyList)[i],
                            _class_private_field_get$1(this, _valList)[i]
                        ]
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 5:
                    return [
                        3,
                        8
                    ];
                case 6:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        8
                    ];
                case 7:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    };
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */ _proto.rentries = function rentries() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, err;
        return _ts_generator$4(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        6,
                        7,
                        8
                    ]);
                    _iterator = _class_private_method_get$2(this, _rindexes, rindexes).call(this)[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        5
                    ];
                    i = _step.value;
                    if (!(_class_private_field_get$1(this, _valList)[i] !== undefined && _class_private_field_get$1(this, _keyList)[i] !== undefined && !_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get$1(this, _valList)[i]))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        [
                            _class_private_field_get$1(this, _keyList)[i],
                            _class_private_field_get$1(this, _valList)[i]
                        ]
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 5:
                    return [
                        3,
                        8
                    ];
                case 6:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        8
                    ];
                case 7:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    };
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */ _proto.keys = function keys() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, k, err;
        return _ts_generator$4(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        6,
                        7,
                        8
                    ]);
                    _iterator = _class_private_method_get$2(this, _indexes, indexes).call(this)[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        5
                    ];
                    i = _step.value;
                    k = _class_private_field_get$1(this, _keyList)[i];
                    if (!(k !== undefined && !_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get$1(this, _valList)[i]))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        k
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 5:
                    return [
                        3,
                        8
                    ];
                case 6:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        8
                    ];
                case 7:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    };
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */ _proto.rkeys = function rkeys() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, k, err;
        return _ts_generator$4(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        6,
                        7,
                        8
                    ]);
                    _iterator = _class_private_method_get$2(this, _rindexes, rindexes).call(this)[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        5
                    ];
                    i = _step.value;
                    k = _class_private_field_get$1(this, _keyList)[i];
                    if (!(k !== undefined && !_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get$1(this, _valList)[i]))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        k
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 5:
                    return [
                        3,
                        8
                    ];
                case 6:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        8
                    ];
                case 7:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    };
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */ _proto.values = function values() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, v1, err;
        return _ts_generator$4(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        6,
                        7,
                        8
                    ]);
                    _iterator = _class_private_method_get$2(this, _indexes, indexes).call(this)[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        5
                    ];
                    i = _step.value;
                    v1 = _class_private_field_get$1(this, _valList)[i];
                    if (!(v1 !== undefined && !_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get$1(this, _valList)[i]))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        _class_private_field_get$1(this, _valList)[i]
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 5:
                    return [
                        3,
                        8
                    ];
                case 6:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        8
                    ];
                case 7:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    };
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */ _proto.rvalues = function rvalues() {
        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, v1, err;
        return _ts_generator$4(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        6,
                        7,
                        8
                    ]);
                    _iterator = _class_private_method_get$2(this, _rindexes, rindexes).call(this)[Symbol.iterator]();
                    _state.label = 2;
                case 2:
                    if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                        3,
                        5
                    ];
                    i = _step.value;
                    v1 = _class_private_field_get$1(this, _valList)[i];
                    if (!(v1 !== undefined && !_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, _class_private_field_get$1(this, _valList)[i]))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        _class_private_field_get$1(this, _valList)[i]
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    _iteratorNormalCompletion = true;
                    return [
                        3,
                        2
                    ];
                case 5:
                    return [
                        3,
                        8
                    ];
                case 6:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        8
                    ];
                case 7:
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                    return [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    };
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */ _proto[_Symbol_iterator] = function() {
        return this.entries();
    };
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */ _proto.find = function find(fn) {
        var getOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = _class_private_method_get$2(this, _indexes, indexes).call(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var i = _step.value;
                var v1 = _class_private_field_get$1(this, _valList)[i];
                var value = _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
                if (value === undefined) continue;
                if (fn(value, _class_private_field_get$1(this, _keyList)[i], this)) {
                    return this.get(_class_private_field_get$1(this, _keyList)[i], getOptions);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */ _proto.forEach = function forEach(fn) {
        var thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = _class_private_method_get$2(this, _indexes, indexes).call(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var i = _step.value;
                var v1 = _class_private_field_get$1(this, _valList)[i];
                var value = _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
                if (value === undefined) continue;
                fn.call(thisp, value, _class_private_field_get$1(this, _keyList)[i], this);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */ _proto.rforEach = function rforEach(fn) {
        var thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = _class_private_method_get$2(this, _rindexes, rindexes).call(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var i = _step.value;
                var v1 = _class_private_field_get$1(this, _valList)[i];
                var value = _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
                if (value === undefined) continue;
                fn.call(thisp, value, _class_private_field_get$1(this, _keyList)[i], this);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */ _proto.purgeStale = function purgeStale() {
        var deleted = false;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = _class_private_method_get$2(this, _rindexes, rindexes).call(this, {
                allowStale: true
            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var i = _step.value;
                if (_class_private_field_get$1(this, _isStale).call(this, i)) {
                    _class_private_method_get$2(this, _delete, __delete).call(this, _class_private_field_get$1(this, _keyList)[i], 'expire');
                    deleted = true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return deleted;
    };
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */ _proto.info = function info(key) {
        var i = _class_private_field_get$1(this, _keyMap).get(key);
        if (i === undefined) return undefined;
        var v1 = _class_private_field_get$1(this, _valList)[i];
        var value = _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
        if (value === undefined) return undefined;
        var entry = {
            value: value
        };
        if (_class_private_field_get$1(this, _ttls) && _class_private_field_get$1(this, _starts)) {
            var ttl = _class_private_field_get$1(this, _ttls)[i];
            var start = _class_private_field_get$1(this, _starts)[i];
            if (ttl && start) {
                var remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (_class_private_field_get$1(this, _sizes)) {
            entry.size = _class_private_field_get$1(this, _sizes)[i];
        }
        return entry;
    };
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */ _proto.dump = function dump() {
        var arr = [];
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = _class_private_method_get$2(this, _indexes, indexes).call(this, {
                allowStale: true
            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var i = _step.value;
                var key = _class_private_field_get$1(this, _keyList)[i];
                var v1 = _class_private_field_get$1(this, _valList)[i];
                var value = _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
                if (value === undefined || key === undefined) continue;
                var entry = {
                    value: value
                };
                if (_class_private_field_get$1(this, _ttls) && _class_private_field_get$1(this, _starts)) {
                    entry.ttl = _class_private_field_get$1(this, _ttls)[i];
                    // always dump the start relative to a portable timestamp
                    // it's ok for this to be a bit slow, it's a rare operation.
                    var age = perf.now() - _class_private_field_get$1(this, _starts)[i];
                    entry.start = Math.floor(Date.now() - age);
                }
                if (_class_private_field_get$1(this, _sizes)) {
                    entry.size = _class_private_field_get$1(this, _sizes)[i];
                }
                arr.unshift([
                    key,
                    entry
                ]);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return arr;
    };
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */ _proto.load = function load(arr) {
        this.clear();
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array$h(_step.value, 2), key = _step_value[0], entry = _step_value[1];
                if (entry.start) {
                    // entry.start is a portable timestamp, but we may be using
                    // node's performance.now(), so calculate the offset, so that
                    // we get the intended remaining TTL, no matter how long it's
                    // been on ice.
                    //
                    // it's ok for this to be a bit slow, it's a rare operation.
                    var age = Date.now() - entry.start;
                    entry.start = perf.now() - age;
                }
                this.set(key, entry.value, entry);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */ _proto.set = function set(k, v1) {
        var setOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _this, _this1, _this2, _this3, _this4, _this5;
        if (v1 === undefined) {
            this.delete(k);
            return this;
        }
        var _setOptions_ttl = setOptions.ttl, ttl = _setOptions_ttl === undefined ? this.ttl : _setOptions_ttl, start = setOptions.start, _setOptions_noDisposeOnSet = setOptions.noDisposeOnSet, noDisposeOnSet = _setOptions_noDisposeOnSet === undefined ? this.noDisposeOnSet : _setOptions_noDisposeOnSet, _setOptions_sizeCalculation = setOptions.sizeCalculation, sizeCalculation = _setOptions_sizeCalculation === undefined ? this.sizeCalculation : _setOptions_sizeCalculation, status = setOptions.status;
        var _setOptions_noUpdateTTL = setOptions.noUpdateTTL, noUpdateTTL = _setOptions_noUpdateTTL === undefined ? this.noUpdateTTL : _setOptions_noUpdateTTL;
        var size = _class_private_field_get$1(this, _requireSize).call(this, k, v1, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            _class_private_method_get$2(this, _delete, __delete).call(this, k, 'set');
            return this;
        }
        var index = _class_private_field_get$1(this, _size) === 0 ? undefined : _class_private_field_get$1(this, _keyMap).get(k);
        if (index === undefined) {
            // addition
            index = _class_private_field_get$1(this, _size) === 0 ? _class_private_field_get$1(this, _tail) : _class_private_field_get$1(this, _free).length !== 0 ? _class_private_field_get$1(this, _free).pop() : _class_private_field_get$1(this, _size) === _class_private_field_get$1(this, _max) ? _class_private_method_get$2(this, _evict, evict).call(this, false) : _class_private_field_get$1(this, _size);
            _class_private_field_get$1(this, _keyList)[index] = k;
            _class_private_field_get$1(this, _valList)[index] = v1;
            _class_private_field_get$1(this, _keyMap).set(k, index);
            _class_private_field_get$1(this, _next)[_class_private_field_get$1(this, _tail)] = index;
            _class_private_field_get$1(this, _prev)[index] = _class_private_field_get$1(this, _tail);
            _class_private_field_set$1(this, _tail, index);
            _class_private_field_update(this, _size).value++;
            _class_private_field_get$1(this, _addItemSize).call(this, index, size, status);
            if (status) status.set = 'add';
            noUpdateTTL = false;
        } else {
            // update
            _class_private_method_get$2(this, _moveToTail, moveToTail).call(this, index);
            var oldVal = _class_private_field_get$1(this, _valList)[index];
            if (v1 !== oldVal) {
                if (_class_private_field_get$1(this, _hasFetchMethod) && _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    var s = oldVal.__staleWhileFetching;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (_class_private_field_get$1(this, _hasDispose)) {
                            (_this = _class_private_field_get$1(_this1 = this, _dispose)) === null || _this === undefined ? undefined : _this.call(_this1, s, k, 'set');
                        }
                        if (_class_private_field_get$1(this, _hasDisposeAfter)) {
                            var _$_class_private_field_get;
                            (_$_class_private_field_get = _class_private_field_get$1(this, _disposed)) === null || _$_class_private_field_get === undefined ? undefined : _$_class_private_field_get.push([
                                s,
                                k,
                                'set'
                            ]);
                        }
                    }
                } else if (!noDisposeOnSet) {
                    if (_class_private_field_get$1(this, _hasDispose)) {
                        (_this2 = _class_private_field_get$1(_this3 = this, _dispose)) === null || _this2 === undefined ? undefined : _this2.call(_this3, oldVal, k, 'set');
                    }
                    if (_class_private_field_get$1(this, _hasDisposeAfter)) {
                        var _$_class_private_field_get1;
                        (_$_class_private_field_get1 = _class_private_field_get$1(this, _disposed)) === null || _$_class_private_field_get1 === undefined ? undefined : _$_class_private_field_get1.push([
                            oldVal,
                            k,
                            'set'
                        ]);
                    }
                }
                _class_private_field_get$1(this, _removeItemSize).call(this, index);
                _class_private_field_get$1(this, _addItemSize).call(this, index, size, status);
                _class_private_field_get$1(this, _valList)[index] = v1;
                if (status) {
                    status.set = 'replace';
                    var oldValue = oldVal && _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== undefined) status.oldValue = oldValue;
                }
            } else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !_class_private_field_get$1(this, _ttls)) {
            _class_private_method_get$2(this, _initializeTTLTracking, initializeTTLTracking).call(this);
        }
        if (_class_private_field_get$1(this, _ttls)) {
            if (!noUpdateTTL) {
                _class_private_field_get$1(this, _setItemTTL).call(this, index, ttl, start);
            }
            if (status) _class_private_field_get$1(this, _statusTTL).call(this, status, index);
        }
        if (!noDisposeOnSet && _class_private_field_get$1(this, _hasDisposeAfter) && _class_private_field_get$1(this, _disposed)) {
            var dt = _class_private_field_get$1(this, _disposed);
            var task;
            while(task = dt === null || dt === undefined ? undefined : dt.shift()){
                var _this6;
                (_this4 = _class_private_field_get$1(_this5 = this, _disposeAfter)) === null || _this4 === undefined ? undefined : (_this6 = _this4).call.apply(_this6, [
                    _this5
                ].concat(_to_consumable_array$c(task)));
            }
        }
        return this;
    };
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */ _proto.pop = function pop() {
        var _this, _this1;
        try {
            while(_class_private_field_get$1(this, _size)){
                var val = _class_private_field_get$1(this, _valList)[_class_private_field_get$1(this, _head)];
                _class_private_method_get$2(this, _evict, evict).call(this, true);
                if (_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                } else if (val !== undefined) {
                    return val;
                }
            }
        } finally{
            if (_class_private_field_get$1(this, _hasDisposeAfter) && _class_private_field_get$1(this, _disposed)) {
                var dt = _class_private_field_get$1(this, _disposed);
                var task;
                while(task = dt === null || dt === undefined ? undefined : dt.shift()){
                    var _this2;
                    (_this = _class_private_field_get$1(_this1 = this, _disposeAfter)) === null || _this === undefined ? undefined : (_this2 = _this).call.apply(_this2, [
                        _this1
                    ].concat(_to_consumable_array$c(task)));
                }
            }
        }
    };
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */ _proto.has = function has(k) {
        var hasOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _hasOptions_updateAgeOnHas = hasOptions.updateAgeOnHas, updateAgeOnHas = _hasOptions_updateAgeOnHas === undefined ? this.updateAgeOnHas : _hasOptions_updateAgeOnHas, status = hasOptions.status;
        var index = _class_private_field_get$1(this, _keyMap).get(k);
        if (index !== undefined) {
            var v1 = _class_private_field_get$1(this, _valList)[index];
            if (_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) && v1.__staleWhileFetching === undefined) {
                return false;
            }
            if (!_class_private_field_get$1(this, _isStale).call(this, index)) {
                if (updateAgeOnHas) {
                    _class_private_field_get$1(this, _updateItemAge).call(this, index);
                }
                if (status) {
                    status.has = 'hit';
                    _class_private_field_get$1(this, _statusTTL).call(this, status, index);
                }
                return true;
            } else if (status) {
                status.has = 'stale';
                _class_private_field_get$1(this, _statusTTL).call(this, status, index);
            }
        } else if (status) {
            status.has = 'miss';
        }
        return false;
    };
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */ _proto.peek = function peek(k) {
        var peekOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _peekOptions_allowStale = peekOptions.allowStale, allowStale = _peekOptions_allowStale === undefined ? this.allowStale : _peekOptions_allowStale;
        var index = _class_private_field_get$1(this, _keyMap).get(k);
        if (index === undefined || !allowStale && _class_private_field_get$1(this, _isStale).call(this, index)) {
            return;
        }
        var v1 = _class_private_field_get$1(this, _valList)[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1) ? v1.__staleWhileFetching : v1;
    };
    _proto.fetch = function fetch(k) {
        var fetchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _this = this;
        return _async_to_generator$1(function() {
            var _fetchOptions_allowStale, // get options
            allowStale, _fetchOptions_updateAgeOnGet, updateAgeOnGet, _fetchOptions_noDeleteOnStaleGet, noDeleteOnStaleGet, _fetchOptions_ttl, // set options
            ttl, _fetchOptions_noDisposeOnSet, noDisposeOnSet, _fetchOptions_size, size, _fetchOptions_sizeCalculation, sizeCalculation, _fetchOptions_noUpdateTTL, noUpdateTTL, _fetchOptions_noDeleteOnFetchRejection, // fetch exclusive options
            noDeleteOnFetchRejection, _fetchOptions_allowStaleOnFetchRejection, allowStaleOnFetchRejection, _fetchOptions_ignoreFetchAbort, ignoreFetchAbort, _fetchOptions_allowStaleOnFetchAbort, allowStaleOnFetchAbort, context, _fetchOptions_forceRefresh, forceRefresh, status, signal, options, index, p, v1, stale, isStale, p1, hasStale, staleVal;
            return _ts_generator$4(this, function(_state) {
                _fetchOptions_allowStale = fetchOptions.allowStale, allowStale = _fetchOptions_allowStale === undefined ? _this.allowStale : _fetchOptions_allowStale, _fetchOptions_updateAgeOnGet = fetchOptions.updateAgeOnGet, updateAgeOnGet = _fetchOptions_updateAgeOnGet === undefined ? _this.updateAgeOnGet : _fetchOptions_updateAgeOnGet, _fetchOptions_noDeleteOnStaleGet = fetchOptions.noDeleteOnStaleGet, noDeleteOnStaleGet = _fetchOptions_noDeleteOnStaleGet === undefined ? _this.noDeleteOnStaleGet : _fetchOptions_noDeleteOnStaleGet, _fetchOptions_ttl = fetchOptions.ttl, ttl = _fetchOptions_ttl === undefined ? _this.ttl : _fetchOptions_ttl, _fetchOptions_noDisposeOnSet = fetchOptions.noDisposeOnSet, noDisposeOnSet = _fetchOptions_noDisposeOnSet === undefined ? _this.noDisposeOnSet : _fetchOptions_noDisposeOnSet, _fetchOptions_size = fetchOptions.size, size = _fetchOptions_size === undefined ? 0 : _fetchOptions_size, _fetchOptions_sizeCalculation = fetchOptions.sizeCalculation, sizeCalculation = _fetchOptions_sizeCalculation === undefined ? _this.sizeCalculation : _fetchOptions_sizeCalculation, _fetchOptions_noUpdateTTL = fetchOptions.noUpdateTTL, noUpdateTTL = _fetchOptions_noUpdateTTL === undefined ? _this.noUpdateTTL : _fetchOptions_noUpdateTTL, _fetchOptions_noDeleteOnFetchRejection = fetchOptions.noDeleteOnFetchRejection, noDeleteOnFetchRejection = _fetchOptions_noDeleteOnFetchRejection === undefined ? _this.noDeleteOnFetchRejection : _fetchOptions_noDeleteOnFetchRejection, _fetchOptions_allowStaleOnFetchRejection = fetchOptions.allowStaleOnFetchRejection, allowStaleOnFetchRejection = _fetchOptions_allowStaleOnFetchRejection === undefined ? _this.allowStaleOnFetchRejection : _fetchOptions_allowStaleOnFetchRejection, _fetchOptions_ignoreFetchAbort = fetchOptions.ignoreFetchAbort, ignoreFetchAbort = _fetchOptions_ignoreFetchAbort === undefined ? _this.ignoreFetchAbort : _fetchOptions_ignoreFetchAbort, _fetchOptions_allowStaleOnFetchAbort = fetchOptions.allowStaleOnFetchAbort, allowStaleOnFetchAbort = _fetchOptions_allowStaleOnFetchAbort === undefined ? _this.allowStaleOnFetchAbort : _fetchOptions_allowStaleOnFetchAbort, context = fetchOptions.context, _fetchOptions_forceRefresh = fetchOptions.forceRefresh, forceRefresh = _fetchOptions_forceRefresh === undefined ? false : _fetchOptions_forceRefresh, status = fetchOptions.status, signal = fetchOptions.signal;
                if (!_class_private_field_get$1(_this, _hasFetchMethod)) {
                    if (status) status.fetch = 'get';
                    return [
                        2,
                        _this.get(k, {
                            allowStale: allowStale,
                            updateAgeOnGet: updateAgeOnGet,
                            noDeleteOnStaleGet: noDeleteOnStaleGet,
                            status: status
                        })
                    ];
                }
                options = {
                    allowStale: allowStale,
                    updateAgeOnGet: updateAgeOnGet,
                    noDeleteOnStaleGet: noDeleteOnStaleGet,
                    ttl: ttl,
                    noDisposeOnSet: noDisposeOnSet,
                    size: size,
                    sizeCalculation: sizeCalculation,
                    noUpdateTTL: noUpdateTTL,
                    noDeleteOnFetchRejection: noDeleteOnFetchRejection,
                    allowStaleOnFetchRejection: allowStaleOnFetchRejection,
                    allowStaleOnFetchAbort: allowStaleOnFetchAbort,
                    ignoreFetchAbort: ignoreFetchAbort,
                    status: status,
                    signal: signal
                };
                index = _class_private_field_get$1(_this, _keyMap).get(k);
                if (index === undefined) {
                    if (status) status.fetch = 'miss';
                    p = _class_private_method_get$2(_this, _backgroundFetch, backgroundFetch).call(_this, k, index, options, context);
                    return [
                        2,
                        p.__returned = p
                    ];
                } else {
                    // in cache, maybe already fetching
                    v1 = _class_private_field_get$1(_this, _valList)[index];
                    if (_class_private_method_get$2(_this, _isBackgroundFetch, isBackgroundFetch).call(_this, v1)) {
                        stale = allowStale && v1.__staleWhileFetching !== undefined;
                        if (status) {
                            status.fetch = 'inflight';
                            if (stale) status.returnedStale = true;
                        }
                        return [
                            2,
                            stale ? v1.__staleWhileFetching : v1.__returned = v1
                        ];
                    }
                    // if we force a refresh, that means do NOT serve the cached value,
                    // unless we are already in the process of refreshing the cache.
                    isStale = _class_private_field_get$1(_this, _isStale).call(_this, index);
                    if (!forceRefresh && !isStale) {
                        if (status) status.fetch = 'hit';
                        _class_private_method_get$2(_this, _moveToTail, moveToTail).call(_this, index);
                        if (updateAgeOnGet) {
                            _class_private_field_get$1(_this, _updateItemAge).call(_this, index);
                        }
                        if (status) _class_private_field_get$1(_this, _statusTTL).call(_this, status, index);
                        return [
                            2,
                            v1
                        ];
                    }
                    // ok, it is stale or a forced refresh, and not already fetching.
                    // refresh the cache.
                    p1 = _class_private_method_get$2(_this, _backgroundFetch, backgroundFetch).call(_this, k, index, options, context);
                    hasStale = p1.__staleWhileFetching !== undefined;
                    staleVal = hasStale && allowStale;
                    if (status) {
                        status.fetch = isStale ? 'stale' : 'refresh';
                        if (staleVal && isStale) status.returnedStale = true;
                    }
                    return [
                        2,
                        staleVal ? p1.__staleWhileFetching : p1.__returned = p1
                    ];
                }
            });
        })();
    };
    _proto.forceFetch = function forceFetch(k) {
        var fetchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _this = this;
        return _async_to_generator$1(function() {
            var v1;
            return _ts_generator$4(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            _this.fetch(k, fetchOptions)
                        ];
                    case 1:
                        v1 = _state.sent();
                        if (v1 === undefined) throw new Error('fetch() returned undefined');
                        return [
                            2,
                            v1
                        ];
                }
            });
        })();
    };
    _proto.memo = function memo(k) {
        var memoOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var memoMethod = _class_private_field_get$1(this, _memoMethod);
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        var context = memoOptions.context, forceRefresh = memoOptions.forceRefresh, options = _object_without_properties(memoOptions, [
            "context",
            "forceRefresh"
        ]);
        var v1 = this.get(k, options);
        if (!forceRefresh && v1 !== undefined) return v1;
        var vv = memoMethod(k, v1, {
            options: options,
            context: context
        });
        this.set(k, vv, options);
        return vv;
    };
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */ _proto.get = function get(k) {
        var getOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _getOptions_allowStale = getOptions.allowStale, allowStale = _getOptions_allowStale === undefined ? this.allowStale : _getOptions_allowStale, _getOptions_updateAgeOnGet = getOptions.updateAgeOnGet, updateAgeOnGet = _getOptions_updateAgeOnGet === undefined ? this.updateAgeOnGet : _getOptions_updateAgeOnGet, _getOptions_noDeleteOnStaleGet = getOptions.noDeleteOnStaleGet, noDeleteOnStaleGet = _getOptions_noDeleteOnStaleGet === undefined ? this.noDeleteOnStaleGet : _getOptions_noDeleteOnStaleGet, status = getOptions.status;
        var index = _class_private_field_get$1(this, _keyMap).get(k);
        if (index !== undefined) {
            var value = _class_private_field_get$1(this, _valList)[index];
            var fetching = _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, value);
            if (status) _class_private_field_get$1(this, _statusTTL).call(this, status, index);
            if (_class_private_field_get$1(this, _isStale).call(this, index)) {
                if (status) status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        _class_private_method_get$2(this, _delete, __delete).call(this, k, 'expire');
                    }
                    if (status && allowStale) status.returnedStale = true;
                    return allowStale ? value : undefined;
                } else {
                    if (status && allowStale && value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            } else {
                if (status) status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                _class_private_method_get$2(this, _moveToTail, moveToTail).call(this, index);
                if (updateAgeOnGet) {
                    _class_private_field_get$1(this, _updateItemAge).call(this, index);
                }
                return value;
            }
        } else if (status) {
            status.get = 'miss';
        }
    };
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */ _proto.delete = function _delete1(k) {
        return _class_private_method_get$2(this, _delete, __delete).call(this, k, 'delete');
    };
    /**
     * Clear the cache entirely, throwing away all values.
     */ _proto.clear = function clear1() {
        return _class_private_method_get$2(this, _clear, clear).call(this, 'delete');
    };
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */ LRUCache.unsafeExposeInternals = function unsafeExposeInternals(c) {
        return {
            // properties
            starts: _class_private_field_get$1(c, _starts),
            ttls: _class_private_field_get$1(c, _ttls),
            sizes: _class_private_field_get$1(c, _sizes),
            keyMap: _class_private_field_get$1(c, _keyMap),
            keyList: _class_private_field_get$1(c, _keyList),
            valList: _class_private_field_get$1(c, _valList),
            next: _class_private_field_get$1(c, _next),
            prev: _class_private_field_get$1(c, _prev),
            get head () {
                return _class_private_field_get$1(c, _head);
            },
            get tail () {
                return _class_private_field_get$1(c, _tail);
            },
            free: _class_private_field_get$1(c, _free),
            // methods
            isBackgroundFetch: function(p) {
                return _class_private_method_get$2(c, _isBackgroundFetch, isBackgroundFetch).call(c, p);
            },
            backgroundFetch: function(k, index, options, context) {
                return _class_private_method_get$2(c, _backgroundFetch, backgroundFetch).call(c, k, index, options, context);
            },
            moveToTail: function(index) {
                return _class_private_method_get$2(c, _moveToTail, moveToTail).call(c, index);
            },
            indexes: function(options) {
                return _class_private_method_get$2(c, _indexes, indexes).call(c, options);
            },
            rindexes: function(options) {
                return _class_private_method_get$2(c, _rindexes, rindexes).call(c, options);
            },
            isStale: function(index) {
                return _class_private_field_get$1(c, _isStale).call(c, index);
            }
        };
    };
    _create_class$b(LRUCache, [
        {
            key: "max",
            get: // Protected read-only members
            /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _max);
            }
        },
        {
            key: "maxSize",
            get: /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _maxSize);
            }
        },
        {
            key: "calculatedSize",
            get: /**
     * The total computed size of items in the cache (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _calculatedSize);
            }
        },
        {
            key: "size",
            get: /**
     * The number of items stored in the cache (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _size);
            }
        },
        {
            key: "fetchMethod",
            get: /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _fetchMethod);
            }
        },
        {
            key: "memoMethod",
            get: function get() {
                return _class_private_field_get$1(this, _memoMethod);
            }
        },
        {
            key: "dispose",
            get: /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _dispose);
            }
        },
        {
            key: "disposeAfter",
            get: /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */ function get() {
                return _class_private_field_get$1(this, _disposeAfter);
            }
        }
    ]);
    return LRUCache;
} 
();
prop = Symbol.toStringTag;
function initializeTTLTracking() {
    var _this = this;
    var _this1 = this;
    var ttls = new ZeroArray(_class_private_field_get$1(this, _max));
    var starts = new ZeroArray(_class_private_field_get$1(this, _max));
    _class_private_field_set$1(this, _ttls, ttls);
    _class_private_field_set$1(this, _starts, starts);
    _class_private_field_set$1(this, _setItemTTL, function(index, ttl) {
        var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : perf.now();
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && _this1.ttlAutopurge) {
            var t = setTimeout(function() {
                if (_class_private_field_get$1(_this1, _isStale).call(_this1, index)) {
                    _class_private_method_get$2(_this1, _delete, __delete).call(_this1, _class_private_field_get$1(_this1, _keyList)[index], 'expire');
                }
            }, ttl + 1);
            // unref() not supported on all platforms
            /* c8 ignore start */ if (t.unref) {
                t.unref();
            }
        /* c8 ignore stop */ }
    });
    _class_private_field_set$1(this, _updateItemAge, function(index) {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    });
    _class_private_field_set$1(this, _statusTTL, function(status, index) {
        if (ttls[index]) {
            var ttl = ttls[index];
            var start = starts[index];
            /* c8 ignore next */ if (!ttl || !start) return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            var age = status.now - start;
            status.remainingTTL = ttl - age;
        }
    });
    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    var cachedNow = 0;
    var getNow = function() {
        var n = perf.now();
        if (_this.ttlResolution > 0) {
            cachedNow = n;
            var t = setTimeout(function() {
                return cachedNow = 0;
            }, _this.ttlResolution);
            // not available on all platforms
            /* c8 ignore start */ if (t.unref) {
                t.unref();
            }
        /* c8 ignore stop */ }
        return n;
    };
    this.getRemainingTTL = function(key) {
        var index = _class_private_field_get$1(_this, _keyMap).get(key);
        if (index === undefined) {
            return 0;
        }
        var ttl = ttls[index];
        var start = starts[index];
        if (!ttl || !start) {
            return Infinity;
        }
        var age = (cachedNow || getNow()) - start;
        return ttl - age;
    };
    _class_private_field_set$1(this, _isStale, function(index) {
        var s = starts[index];
        var t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
    });
}
function initializeSizeTracking() {
    var _this = this;
    var sizes = new ZeroArray(_class_private_field_get$1(this, _max));
    _class_private_field_set$1(this, _calculatedSize, 0);
    _class_private_field_set$1(this, _sizes, sizes);
    _class_private_field_set$1(this, _removeItemSize, function(index) {
        _class_private_field_set$1(_this, _calculatedSize, _class_private_field_get$1(_this, _calculatedSize) - sizes[index]);
        sizes[index] = 0;
    });
    _class_private_field_set$1(this, _requireSize, function(k, v1, size, sizeCalculation) {
        // provisionally accept background fetches.
        // actual value size will be checked when they return.
        if (_class_private_method_get$2(_this, _isBackgroundFetch, isBackgroundFetch).call(_this, v1)) {
            return 0;
        }
        if (!isPosInt(size)) {
            if (sizeCalculation) {
                if (typeof sizeCalculation !== 'function') {
                    throw new TypeError('sizeCalculation must be a function');
                }
                size = sizeCalculation(v1, k);
                if (!isPosInt(size)) {
                    throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                }
            } else {
                throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');
            }
        }
        return size;
    });
    _class_private_field_set$1(this, _addItemSize, function(index, size, status) {
        sizes[index] = size;
        if (_class_private_field_get$1(_this, _maxSize)) {
            var maxSize = _class_private_field_get$1(_this, _maxSize) - sizes[index];
            while(_class_private_field_get$1(_this, _calculatedSize) > maxSize){
                _class_private_method_get$2(_this, _evict, evict).call(_this, true);
            }
        }
        _class_private_field_set$1(_this, _calculatedSize, _class_private_field_get$1(_this, _calculatedSize) + sizes[index]);
        if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = _class_private_field_get$1(_this, _calculatedSize);
        }
    });
}
function indexes() {
    var _ref, _ref_allowStale, allowStale, i;
    var _arguments = arguments;
    return _ts_generator$4(this, function(_state) {
        switch(_state.label){
            case 0:
                _ref = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {}, _ref_allowStale = _ref.allowStale, allowStale = _ref_allowStale === undefined ? this.allowStale : _ref_allowStale;
                if (!_class_private_field_get$1(this, _size)) return [
                    3,
                    5
                ];
                i = _class_private_field_get$1(this, _tail);
                _state.label = 1;
            case 1:
                if (!_class_private_method_get$2(this, _isValidIndex, isValidIndex).call(this, i)) {
                    return [
                        3,
                        5
                    ];
                }
                if (!(allowStale || !_class_private_field_get$1(this, _isStale).call(this, i))) return [
                    3,
                    3
                ];
                return [
                    4,
                    i
                ];
            case 2:
                _state.sent();
                _state.label = 3;
            case 3:
                if (i === _class_private_field_get$1(this, _head)) {
                    return [
                        3,
                        5
                    ];
                } else {
                    i = _class_private_field_get$1(this, _prev)[i];
                }
                _state.label = 4;
            case 4:
                return [
                    3,
                    1
                ];
            case 5:
                return [
                    2
                ];
        }
    });
}
function rindexes() {
    var _ref, _ref_allowStale, allowStale, i;
    var _arguments = arguments;
    return _ts_generator$4(this, function(_state) {
        switch(_state.label){
            case 0:
                _ref = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {}, _ref_allowStale = _ref.allowStale, allowStale = _ref_allowStale === undefined ? this.allowStale : _ref_allowStale;
                if (!_class_private_field_get$1(this, _size)) return [
                    3,
                    5
                ];
                i = _class_private_field_get$1(this, _head);
                _state.label = 1;
            case 1:
                if (!_class_private_method_get$2(this, _isValidIndex, isValidIndex).call(this, i)) {
                    return [
                        3,
                        5
                    ];
                }
                if (!(allowStale || !_class_private_field_get$1(this, _isStale).call(this, i))) return [
                    3,
                    3
                ];
                return [
                    4,
                    i
                ];
            case 2:
                _state.sent();
                _state.label = 3;
            case 3:
                if (i === _class_private_field_get$1(this, _tail)) {
                    return [
                        3,
                        5
                    ];
                } else {
                    i = _class_private_field_get$1(this, _next)[i];
                }
                _state.label = 4;
            case 4:
                return [
                    3,
                    1
                ];
            case 5:
                return [
                    2
                ];
        }
    });
}
function isValidIndex(index) {
    return index !== undefined && _class_private_field_get$1(this, _keyMap).get(_class_private_field_get$1(this, _keyList)[index]) === index;
}
function evict(free) {
    var _this, _this1;
    var head = _class_private_field_get$1(this, _head);
    var k = _class_private_field_get$1(this, _keyList)[head];
    var v1 = _class_private_field_get$1(this, _valList)[head];
    if (_class_private_field_get$1(this, _hasFetchMethod) && _class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1)) {
        v1.__abortController.abort(new Error('evicted'));
    } else if (_class_private_field_get$1(this, _hasDispose) || _class_private_field_get$1(this, _hasDisposeAfter)) {
        if (_class_private_field_get$1(this, _hasDispose)) {
            (_this = _class_private_field_get$1(_this1 = this, _dispose)) === null || _this === undefined ? undefined : _this.call(_this1, v1, k, 'evict');
        }
        if (_class_private_field_get$1(this, _hasDisposeAfter)) {
            var _$_class_private_field_get;
            (_$_class_private_field_get = _class_private_field_get$1(this, _disposed)) === null || _$_class_private_field_get === undefined ? undefined : _$_class_private_field_get.push([
                v1,
                k,
                'evict'
            ]);
        }
    }
    _class_private_field_get$1(this, _removeItemSize).call(this, head);
    // if we aren't about to use the index, then null these out
    if (free) {
        _class_private_field_get$1(this, _keyList)[head] = undefined;
        _class_private_field_get$1(this, _valList)[head] = undefined;
        _class_private_field_get$1(this, _free).push(head);
    }
    if (_class_private_field_get$1(this, _size) === 1) {
        _class_private_field_set$1(this, _head, _class_private_field_set$1(this, _tail, 0));
        _class_private_field_get$1(this, _free).length = 0;
    } else {
        _class_private_field_set$1(this, _head, _class_private_field_get$1(this, _next)[head]);
    }
    _class_private_field_get$1(this, _keyMap).delete(k);
    _class_private_field_update(this, _size).value--;
    return head;
}
function backgroundFetch(k, index, options, context) {
    var _this = this;
    var _this1 = this;
    var _this2, _this3;
    var v1 = index === undefined ? undefined : _class_private_field_get$1(this, _valList)[index];
    if (_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1)) {
        return v1;
    }
    var ac = new AC();
    var signal = options.signal;
    // when/if our AC signals, then stop listening to theirs.
    signal === null || signal === undefined ? undefined : signal.addEventListener('abort', function() {
        return ac.abort(signal.reason);
    }, {
        signal: ac.signal
    });
    var fetchOpts = {
        signal: ac.signal,
        options: options,
        context: context
    };
    var cb = function(v1) {
        var updateCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var aborted = ac.signal.aborted;
        var ignoreAbort = options.ignoreFetchAbort && v1 !== undefined;
        if (options.status) {
            if (aborted && !updateCache) {
                options.status.fetchAborted = true;
                options.status.fetchError = ac.signal.reason;
                if (ignoreAbort) options.status.fetchAbortIgnored = true;
            } else {
                options.status.fetchResolved = true;
            }
        }
        if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
        }
        // either we didn't abort, and are still here, or we did, and ignored
        var bf = p;
        if (_class_private_field_get$1(_this1, _valList)[index] === p) {
            if (v1 === undefined) {
                if (bf.__staleWhileFetching) {
                    _class_private_field_get$1(_this1, _valList)[index] = bf.__staleWhileFetching;
                } else {
                    _class_private_method_get$2(_this1, _delete, __delete).call(_this1, k, 'fetch');
                }
            } else {
                if (options.status) options.status.fetchUpdated = true;
                _this1.set(k, v1, fetchOpts.options);
            }
        }
        return v1;
    };
    var eb = function(er) {
        if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
        }
        return fetchFail(er);
    };
    var fetchFail = function(er) {
        var aborted = ac.signal.aborted;
        var allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        var allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        var noDelete = allowStale || options.noDeleteOnFetchRejection;
        var bf = p;
        if (_class_private_field_get$1(_this, _valList)[index] === p) {
            // if we allow stale on fetch rejections, then we need to ensure that
            // the stale value is not removed from the cache when the fetch fails.
            var del = !noDelete || bf.__staleWhileFetching === undefined;
            if (del) {
                _class_private_method_get$2(_this, _delete, __delete).call(_this, k, 'fetch');
            } else if (!allowStaleAborted) {
                // still replace the *promise* with the stale value,
                // since we are done with the promise at this point.
                // leave it untouched if we're still waiting for an
                // aborted background fetch that hasn't yet returned.
                _class_private_field_get$1(_this, _valList)[index] = bf.__staleWhileFetching;
            }
        }
        if (allowStale) {
            if (options.status && bf.__staleWhileFetching !== undefined) {
                options.status.returnedStale = true;
            }
            return bf.__staleWhileFetching;
        } else if (bf.__returned === bf) {
            throw er;
        }
    };
    var pcall = function(res, rej) {
        var fmp = (_this2 = _class_private_field_get$1(_this3 = _this, _fetchMethod)) === null || _this2 === undefined ? undefined : _this2.call(_this3, k, v1, fetchOpts);
        if (fmp && _instanceof$v(fmp, Promise)) {
            fmp.then(function(v1) {
                return res(v1 === undefined ? undefined : v1);
            }, rej);
        }
        // ignored, we go until we finish, regardless.
        // defer check until we are actually aborting,
        // so fetchMethod can override.
        ac.signal.addEventListener('abort', function() {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                res(undefined);
                // when it eventually resolves, update the cache.
                if (options.allowStaleOnFetchAbort) {
                    res = function(v1) {
                        return cb(v1, true);
                    };
                }
            }
        });
    };
    if (options.status) options.status.fetchDispatched = true;
    var p = new Promise(pcall).then(cb, eb);
    var bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v1,
        __returned: undefined
    });
    if (index === undefined) {
        // internal, don't expose status.
        this.set(k, bf, _object_spread_props$1(_object_spread$1({}, fetchOpts.options), {
            status: undefined
        }));
        index = _class_private_field_get$1(this, _keyMap).get(k);
    } else {
        _class_private_field_get$1(this, _valList)[index] = bf;
    }
    return bf;
}
function isBackgroundFetch(p) {
    if (!_class_private_field_get$1(this, _hasFetchMethod)) return false;
    var b = p;
    return !!b && _instanceof$v(b, Promise) && b.hasOwnProperty('__staleWhileFetching') && _instanceof$v(b.__abortController, AC);
}
function connect(p, n) {
    _class_private_field_get$1(this, _prev)[n] = p;
    _class_private_field_get$1(this, _next)[p] = n;
}
function moveToTail(index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== _class_private_field_get$1(this, _tail)) {
        if (index === _class_private_field_get$1(this, _head)) {
            _class_private_field_set$1(this, _head, _class_private_field_get$1(this, _next)[index]);
        } else {
            _class_private_method_get$2(this, _connect, connect).call(this, _class_private_field_get$1(this, _prev)[index], _class_private_field_get$1(this, _next)[index]);
        }
        _class_private_method_get$2(this, _connect, connect).call(this, _class_private_field_get$1(this, _tail), index);
        _class_private_field_set$1(this, _tail, index);
    }
}
function __delete(k, reason) {
    var _$_class_private_field_get;
    var _this, _this1, _this2, _this3;
    var deleted = false;
    if (_class_private_field_get$1(this, _size) !== 0) {
        var index = _class_private_field_get$1(this, _keyMap).get(k);
        if (index !== undefined) {
            deleted = true;
            if (_class_private_field_get$1(this, _size) === 1) {
                _class_private_method_get$2(this, _clear, clear).call(this, reason);
            } else {
                _class_private_field_get$1(this, _removeItemSize).call(this, index);
                var v1 = _class_private_field_get$1(this, _valList)[index];
                if (_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1)) {
                    v1.__abortController.abort(new Error('deleted'));
                } else if (_class_private_field_get$1(this, _hasDispose) || _class_private_field_get$1(this, _hasDisposeAfter)) {
                    if (_class_private_field_get$1(this, _hasDispose)) {
                        (_this = _class_private_field_get$1(_this1 = this, _dispose)) === null || _this === undefined ? undefined : _this.call(_this1, v1, k, reason);
                    }
                    if (_class_private_field_get$1(this, _hasDisposeAfter)) {
                        var _$_class_private_field_get1;
                        (_$_class_private_field_get1 = _class_private_field_get$1(this, _disposed)) === null || _$_class_private_field_get1 === undefined ? undefined : _$_class_private_field_get1.push([
                            v1,
                            k,
                            reason
                        ]);
                    }
                }
                _class_private_field_get$1(this, _keyMap).delete(k);
                _class_private_field_get$1(this, _keyList)[index] = undefined;
                _class_private_field_get$1(this, _valList)[index] = undefined;
                if (index === _class_private_field_get$1(this, _tail)) {
                    _class_private_field_set$1(this, _tail, _class_private_field_get$1(this, _prev)[index]);
                } else if (index === _class_private_field_get$1(this, _head)) {
                    _class_private_field_set$1(this, _head, _class_private_field_get$1(this, _next)[index]);
                } else {
                    var pi = _class_private_field_get$1(this, _prev)[index];
                    _class_private_field_get$1(this, _next)[pi] = _class_private_field_get$1(this, _next)[index];
                    var ni = _class_private_field_get$1(this, _next)[index];
                    _class_private_field_get$1(this, _prev)[ni] = _class_private_field_get$1(this, _prev)[index];
                }
                _class_private_field_update(this, _size).value--;
                _class_private_field_get$1(this, _free).push(index);
            }
        }
    }
    if (_class_private_field_get$1(this, _hasDisposeAfter) && ((_$_class_private_field_get = _class_private_field_get$1(this, _disposed)) === null || _$_class_private_field_get === undefined ? undefined : _$_class_private_field_get.length)) {
        var dt = _class_private_field_get$1(this, _disposed);
        var task;
        while(task = dt === null || dt === undefined ? undefined : dt.shift()){
            var _this4;
            (_this2 = _class_private_field_get$1(_this3 = this, _disposeAfter)) === null || _this2 === undefined ? undefined : (_this4 = _this2).call.apply(_this4, [
                _this3
            ].concat(_to_consumable_array$c(task)));
        }
    }
    return deleted;
}
function clear(reason) {
    var _this, _this1, _ref, _this2, _this3;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = _class_private_method_get$2(this, _rindexes, rindexes).call(this, {
            allowStale: true
        })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var index = _step.value;
            var v1 = _class_private_field_get$1(this, _valList)[index];
            if (_class_private_method_get$2(this, _isBackgroundFetch, isBackgroundFetch).call(this, v1)) {
                v1.__abortController.abort(new Error('deleted'));
            } else {
                var k = _class_private_field_get$1(this, _keyList)[index];
                if (_class_private_field_get$1(this, _hasDispose)) {
                    (_this = _class_private_field_get$1(_ref = _this1 = this, _dispose)) === null || _this === void 0 ? void 0 : _this.call(_this1, v1, k, reason);
                }
                if (_class_private_field_get$1(this, _hasDisposeAfter)) {
                    var _$_class_private_field_get;
                    (_$_class_private_field_get = _class_private_field_get$1(this, _disposed)) === null || _$_class_private_field_get === void 0 ? void 0 : _$_class_private_field_get.push([
                        v1,
                        k,
                        reason
                    ]);
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    _class_private_field_get$1(this, _keyMap).clear();
    _class_private_field_get$1(this, _valList).fill(undefined);
    _class_private_field_get$1(this, _keyList).fill(undefined);
    if (_class_private_field_get$1(this, _ttls) && _class_private_field_get$1(this, _starts)) {
        _class_private_field_get$1(this, _ttls).fill(0);
        _class_private_field_get$1(this, _starts).fill(0);
    }
    if (_class_private_field_get$1(this, _sizes)) {
        _class_private_field_get$1(this, _sizes).fill(0);
    }
    _class_private_field_set$1(this, _head, 0);
    _class_private_field_set$1(this, _tail, 0);
    _class_private_field_get$1(this, _free).length = 0;
    _class_private_field_set$1(this, _calculatedSize, 0);
    _class_private_field_set$1(this, _size, 0);
    if (_class_private_field_get$1(this, _hasDisposeAfter) && _class_private_field_get$1(this, _disposed)) {
        var dt = _class_private_field_get$1(this, _disposed);
        var task;
        while(task = dt === null || dt === undefined ? undefined : dt.shift()){
            var _this4;
            (_this2 = _class_private_field_get$1(_this3 = this, _disposeAfter)) === null || _this2 === undefined ? undefined : (_this4 = _this2).call.apply(_this4, [
                _this3
            ].concat(_to_consumable_array$c(task)));
        }
    }
}

var esm = /*#__PURE__*/Object.freeze({
	__proto__: null,
	LRUCache: LRUCache
});

var require$$0$1 = /*@__PURE__*/ getAugmentedNamespace(esm);

/* eslint-disable max-len */ function _array_like_to_array$r(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$i(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$g(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$i() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$g(arr, i) {
    return _array_with_holes$i(arr) || _iterable_to_array_limit$g(arr, i) || _unsupported_iterable_to_array$r(arr, i) || _non_iterable_rest$i();
}
function _unsupported_iterable_to_array$r(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$r(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$r(o, minLen);
}
var hosts_1;
var hasRequiredHosts;
function requireHosts() {
    if (hasRequiredHosts) return hosts_1;
    hasRequiredHosts = 1;
    var maybeJoin = function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return args.every(function(arg) {
            return arg;
        }) ? args.join('') : '';
    };
    var maybeEncode = function(arg) {
        return arg ? encodeURIComponent(arg) : '';
    };
    var formatHashFragment = function(f) {
        return f.toLowerCase().replace(/^\W+|\/|\W+$/g, '').replace(/\W+/g, '-');
    };
    var defaults = {
        sshtemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "git@".concat(domain, ":").concat(user, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        sshurltemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "git+ssh://git@".concat(domain, "/").concat(user, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        edittemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, editpath = param.editpath, path = param.path;
            return "https://".concat(domain, "/").concat(user, "/").concat(project).concat(maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path));
        },
        browsetemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, treepath = param.treepath;
            return "https://".concat(domain, "/").concat(user, "/").concat(project).concat(maybeJoin('/', treepath, '/', maybeEncode(committish)));
        },
        browsetreetemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, treepath = param.treepath, path = param.path, fragment = param.fragment, hashformat = param.hashformat;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/").concat(treepath, "/").concat(maybeEncode(committish || 'HEAD'), "/").concat(path).concat(maybeJoin('#', hashformat(fragment || '')));
        },
        browseblobtemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, blobpath = param.blobpath, path = param.path, fragment = param.fragment, hashformat = param.hashformat;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/").concat(blobpath, "/").concat(maybeEncode(committish || 'HEAD'), "/").concat(path).concat(maybeJoin('#', hashformat(fragment || '')));
        },
        docstemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, treepath = param.treepath, committish = param.committish;
            return "https://".concat(domain, "/").concat(user, "/").concat(project).concat(maybeJoin('/', treepath, '/', maybeEncode(committish)), "#readme");
        },
        httpstemplate: function(param) {
            var auth = param.auth, domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "git+https://".concat(maybeJoin(auth, '@')).concat(domain, "/").concat(user, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        filetemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, path = param.path;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/raw/").concat(maybeEncode(committish || 'HEAD'), "/").concat(path);
        },
        shortcuttemplate: function(param) {
            var type = param.type, user = param.user, project = param.project, committish = param.committish;
            return "".concat(type, ":").concat(user, "/").concat(project).concat(maybeJoin('#', committish));
        },
        pathtemplate: function(param) {
            var user = param.user, project = param.project, committish = param.committish;
            return "".concat(user, "/").concat(project).concat(maybeJoin('#', committish));
        },
        bugstemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/issues");
        },
        hashformat: formatHashFragment
    };
    var hosts = {};
    hosts.github = {
        // First two are insecure and generally shouldn't be used any more, but
        // they are still supported.
        protocols: [
            'git:',
            'http:',
            'git+ssh:',
            'git+https:',
            'ssh:',
            'https:'
        ],
        domain: 'github.com',
        treepath: 'tree',
        blobpath: 'blob',
        editpath: 'edit',
        filetemplate: function(param) {
            var auth = param.auth, user = param.user, project = param.project, committish = param.committish, path = param.path;
            return "https://".concat(maybeJoin(auth, '@'), "raw.githubusercontent.com/").concat(user, "/").concat(project, "/").concat(maybeEncode(committish || 'HEAD'), "/").concat(path);
        },
        gittemplate: function(param) {
            var auth = param.auth, domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "git://".concat(maybeJoin(auth, '@')).concat(domain, "/").concat(user, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        tarballtemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "https://codeload.".concat(domain, "/").concat(user, "/").concat(project, "/tar.gz/").concat(maybeEncode(committish || 'HEAD'));
        },
        extract: function(url) {
            var _url_pathname_split = _sliced_to_array$g(url.pathname.split('/', 5), 5), user = _url_pathname_split[1], project = _url_pathname_split[2], type = _url_pathname_split[3], committish = _url_pathname_split[4];
            if (type && type !== 'tree') {
                return;
            }
            if (!type) {
                committish = url.hash.slice(1);
            }
            if (project && project.endsWith('.git')) {
                project = project.slice(0, -4);
            }
            if (!user || !project) {
                return;
            }
            return {
                user: user,
                project: project,
                committish: committish
            };
        }
    };
    hosts.bitbucket = {
        protocols: [
            'git+ssh:',
            'git+https:',
            'ssh:',
            'https:'
        ],
        domain: 'bitbucket.org',
        treepath: 'src',
        blobpath: 'src',
        editpath: '?mode=edit',
        edittemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, treepath = param.treepath, path = param.path, editpath = param.editpath;
            return "https://".concat(domain, "/").concat(user, "/").concat(project).concat(maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath));
        },
        tarballtemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/get/").concat(maybeEncode(committish || 'HEAD'), ".tar.gz");
        },
        extract: function(url) {
            var _url_pathname_split = _sliced_to_array$g(url.pathname.split('/', 4), 4), user = _url_pathname_split[1], project = _url_pathname_split[2], aux = _url_pathname_split[3];
            if ([
                'get'
            ].includes(aux)) {
                return;
            }
            if (project && project.endsWith('.git')) {
                project = project.slice(0, -4);
            }
            if (!user || !project) {
                return;
            }
            return {
                user: user,
                project: project,
                committish: url.hash.slice(1)
            };
        }
    };
    hosts.gitlab = {
        protocols: [
            'git+ssh:',
            'git+https:',
            'ssh:',
            'https:'
        ],
        domain: 'gitlab.com',
        treepath: 'tree',
        blobpath: 'tree',
        editpath: '-/edit',
        httpstemplate: function(param) {
            var auth = param.auth, domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "git+https://".concat(maybeJoin(auth, '@')).concat(domain, "/").concat(user, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        tarballtemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/repository/archive.tar.gz?ref=").concat(maybeEncode(committish || 'HEAD'));
        },
        extract: function(url) {
            var path = url.pathname.slice(1);
            if (path.includes('/-/') || path.includes('/archive.tar.gz')) {
                return;
            }
            var segments = path.split('/');
            var project = segments.pop();
            if (project.endsWith('.git')) {
                project = project.slice(0, -4);
            }
            var user = segments.join('/');
            if (!user || !project) {
                return;
            }
            return {
                user: user,
                project: project,
                committish: url.hash.slice(1)
            };
        }
    };
    hosts.gist = {
        protocols: [
            'git:',
            'git+ssh:',
            'git+https:',
            'ssh:',
            'https:'
        ],
        domain: 'gist.github.com',
        editpath: 'edit',
        sshtemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish;
            return "git@".concat(domain, ":").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        sshurltemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish;
            return "git+ssh://git@".concat(domain, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        edittemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, editpath = param.editpath;
            return "https://".concat(domain, "/").concat(user, "/").concat(project).concat(maybeJoin('/', maybeEncode(committish)), "/").concat(editpath);
        },
        browsetemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish;
            return "https://".concat(domain, "/").concat(project).concat(maybeJoin('/', maybeEncode(committish)));
        },
        browsetreetemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish, path = param.path, hashformat = param.hashformat;
            return "https://".concat(domain, "/").concat(project).concat(maybeJoin('/', maybeEncode(committish))).concat(maybeJoin('#', hashformat(path)));
        },
        browseblobtemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish, path = param.path, hashformat = param.hashformat;
            return "https://".concat(domain, "/").concat(project).concat(maybeJoin('/', maybeEncode(committish))).concat(maybeJoin('#', hashformat(path)));
        },
        docstemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish;
            return "https://".concat(domain, "/").concat(project).concat(maybeJoin('/', maybeEncode(committish)));
        },
        httpstemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish;
            return "git+https://".concat(domain, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        filetemplate: function(param) {
            var user = param.user, project = param.project, committish = param.committish, path = param.path;
            return "https://gist.githubusercontent.com/".concat(user, "/").concat(project, "/raw").concat(maybeJoin('/', maybeEncode(committish)), "/").concat(path);
        },
        shortcuttemplate: function(param) {
            var type = param.type, project = param.project, committish = param.committish;
            return "".concat(type, ":").concat(project).concat(maybeJoin('#', committish));
        },
        pathtemplate: function(param) {
            var project = param.project, committish = param.committish;
            return "".concat(project).concat(maybeJoin('#', committish));
        },
        bugstemplate: function(param) {
            var domain = param.domain, project = param.project;
            return "https://".concat(domain, "/").concat(project);
        },
        gittemplate: function(param) {
            var domain = param.domain, project = param.project, committish = param.committish;
            return "git://".concat(domain, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        tarballtemplate: function(param) {
            var project = param.project, committish = param.committish;
            return "https://codeload.github.com/gist/".concat(project, "/tar.gz/").concat(maybeEncode(committish || 'HEAD'));
        },
        extract: function(url) {
            var _url_pathname_split = _sliced_to_array$g(url.pathname.split('/', 4), 4), user = _url_pathname_split[1], project = _url_pathname_split[2], aux = _url_pathname_split[3];
            if (aux === 'raw') {
                return;
            }
            if (!project) {
                if (!user) {
                    return;
                }
                project = user;
                user = null;
            }
            if (project.endsWith('.git')) {
                project = project.slice(0, -4);
            }
            return {
                user: user,
                project: project,
                committish: url.hash.slice(1)
            };
        },
        hashformat: function hashformat(fragment) {
            return fragment && 'file-' + formatHashFragment(fragment);
        }
    };
    hosts.sourcehut = {
        protocols: [
            'git+ssh:',
            'https:'
        ],
        domain: 'git.sr.ht',
        treepath: 'tree',
        blobpath: 'tree',
        filetemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish, path = param.path;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/blob/").concat(maybeEncode(committish) || 'HEAD', "/").concat(path);
        },
        httpstemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, ".git").concat(maybeJoin('#', committish));
        },
        tarballtemplate: function(param) {
            var domain = param.domain, user = param.user, project = param.project, committish = param.committish;
            return "https://".concat(domain, "/").concat(user, "/").concat(project, "/archive/").concat(maybeEncode(committish) || 'HEAD', ".tar.gz");
        },
        bugstemplate: function() {
            return null;
        },
        extract: function(url) {
            var _url_pathname_split = _sliced_to_array$g(url.pathname.split('/', 4), 4), user = _url_pathname_split[1], project = _url_pathname_split[2], aux = _url_pathname_split[3];
            // tarball url
            if ([
                'archive'
            ].includes(aux)) {
                return;
            }
            if (project && project.endsWith('.git')) {
                project = project.slice(0, -4);
            }
            if (!user || !project) {
                return;
            }
            return {
                user: user,
                project: project,
                committish: url.hash.slice(1)
            };
        }
    };
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.entries(hosts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array$g(_step.value, 2), name = _step_value[0], host = _step_value[1];
            hosts[name] = Object.assign({}, defaults, host);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    hosts_1 = hosts;
    return hosts_1;
}

var parseUrl;
var hasRequiredParseUrl;
function requireParseUrl() {
    if (hasRequiredParseUrl) return parseUrl;
    hasRequiredParseUrl = 1;
    var url = require$$0$2;
    var lastIndexOfBefore = function(str, char, beforeChar) {
        var startPosition = str.indexOf(beforeChar);
        return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);
    };
    var safeUrl = function(u) {
        try {
            return new url.URL(u);
        } catch (e) {
        // this fn should never throw
        }
    };
    // accepts input like git:github.com:user/repo and inserts the // after the first :
    var correctProtocol = function(arg, protocols) {
        var firstColon = arg.indexOf(':');
        var proto = arg.slice(0, firstColon + 1);
        if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
            return arg;
        }
        var firstAt = arg.indexOf('@');
        if (firstAt > -1) {
            if (firstAt > firstColon) {
                return "git+ssh://".concat(arg);
            } else {
                return arg;
            }
        }
        var doubleSlash = arg.indexOf('//');
        if (doubleSlash === firstColon + 1) {
            return arg;
        }
        return "".concat(arg.slice(0, firstColon + 1), "//").concat(arg.slice(firstColon + 1));
    };
    // attempt to correct an scp style url so that it will parse with `new URL()`
    var correctUrl = function(giturl) {
        // ignore @ that come after the first hash since the denotes the start
        // of a committish which can contain @ characters
        var firstAt = lastIndexOfBefore(giturl, '@', '#');
        // ignore colons that come after the hash since that could include colons such as:
        // git@github.com:user/package-2#semver:^1.0.0
        var lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#');
        if (lastColonBeforeHash > firstAt) {
            // the last : comes after the first @ (or there is no @)
            // like it would in:
            // proto://hostname.com:user/repo
            // username@hostname.com:user/repo
            // :password@hostname.com:user/repo
            // username:password@hostname.com:user/repo
            // proto://username@hostname.com:user/repo
            // proto://:password@hostname.com:user/repo
            // proto://username:password@hostname.com:user/repo
            // then we replace the last : with a / to create a valid path
            giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1);
        }
        if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {
            // we have no : at all
            // as it would be in:
            // username@hostname.com/user/repo
            // then we prepend a protocol
            giturl = "git+ssh://".concat(giturl);
        }
        return giturl;
    };
    parseUrl = function(giturl, protocols) {
        var withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
        return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
    };
    return parseUrl;
}

function _instanceof$u(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var fromUrl;
var hasRequiredFromUrl;
function requireFromUrl() {
    if (hasRequiredFromUrl) return fromUrl;
    hasRequiredFromUrl = 1;
    var parseUrl = requireParseUrl();
    // look for github shorthand inputs, such as npm/cli
    var isGitHubShorthand = function(arg) {
        // it cannot contain whitespace before the first #
        // it cannot start with a / because that's probably an absolute file path
        // but it must include a slash since repos are username/repository
        // it cannot start with a . because that's probably a relative file path
        // it cannot start with an @ because that's a scoped package if it passes the other tests
        // it cannot contain a : before a # because that tells us that there's a protocol
        // a second / may not exist before a #
        var firstHash = arg.indexOf('#');
        var firstSlash = arg.indexOf('/');
        var secondSlash = arg.indexOf('/', firstSlash + 1);
        var firstColon = arg.indexOf(':');
        var firstSpace = /\s/.exec(arg);
        var firstAt = arg.indexOf('@');
        var spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
        var atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
        var colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
        var secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
        var hasSlash = firstSlash > 0;
        // if a # is found, what we really want to know is that the character
        // immediately before # is not a /
        var doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');
        var doesNotStartWithDot = !arg.startsWith('.');
        return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
    };
    fromUrl = function(giturl, opts, param) {
        var gitHosts = param.gitHosts, protocols = param.protocols;
        var _protocols_parsed_protocol;
        if (!giturl) {
            return;
        }
        var correctedUrl = isGitHubShorthand(giturl) ? "github:".concat(giturl) : giturl;
        var parsed = parseUrl(correctedUrl, protocols);
        if (!parsed) {
            return;
        }
        var gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
        var gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname];
        var gitHostName = gitHostShortcut || gitHostDomain;
        if (!gitHostName) {
            return;
        }
        var gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
        var auth = null;
        if (((_protocols_parsed_protocol = protocols[parsed.protocol]) === null || _protocols_parsed_protocol === undefined ? undefined : _protocols_parsed_protocol.auth) && (parsed.username || parsed.password)) {
            auth = "".concat(parsed.username).concat(parsed.password ? ':' + parsed.password : '');
        }
        var committish = null;
        var user = null;
        var project = null;
        var defaultRepresentation = null;
        try {
            if (gitHostShortcut) {
                var pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;
                var firstAt = pathname.indexOf('@');
                // we ignore auth for shortcuts, so just trim it out
                if (firstAt > -1) {
                    pathname = pathname.slice(firstAt + 1);
                }
                var lastSlash = pathname.lastIndexOf('/');
                if (lastSlash > -1) {
                    user = decodeURIComponent(pathname.slice(0, lastSlash));
                    // we want nulls only, never empty strings
                    if (!user) {
                        user = null;
                    }
                    project = decodeURIComponent(pathname.slice(lastSlash + 1));
                } else {
                    project = decodeURIComponent(pathname);
                }
                if (project.endsWith('.git')) {
                    project = project.slice(0, -4);
                }
                if (parsed.hash) {
                    committish = decodeURIComponent(parsed.hash.slice(1));
                }
                defaultRepresentation = 'shortcut';
            } else {
                var _protocols_parsed_protocol1;
                if (!gitHostInfo.protocols.includes(parsed.protocol)) {
                    return;
                }
                var segments = gitHostInfo.extract(parsed);
                if (!segments) {
                    return;
                }
                user = segments.user && decodeURIComponent(segments.user);
                project = decodeURIComponent(segments.project);
                committish = decodeURIComponent(segments.committish);
                defaultRepresentation = ((_protocols_parsed_protocol1 = protocols[parsed.protocol]) === null || _protocols_parsed_protocol1 === void 0 ? void 0 : _protocols_parsed_protocol1.name) || parsed.protocol.slice(0, -1);
            }
        } catch (err) {
            /* istanbul ignore else */ if (_instanceof$u(err, URIError)) {
                return;
            } else {
                throw err;
            }
        }
        return [
            gitHostName,
            user,
            auth,
            project,
            committish,
            defaultRepresentation,
            opts
        ];
    };
    return fromUrl;
}

function _array_like_to_array$q(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$h(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes$b(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$q(arr);
}
function _check_private_redeclaration$1(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get$1(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_call_check$D(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _class_check_private_static_field_descriptor(descriptor, action) {
    if (descriptor === undefined) {
        throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
}
function _class_private_method_get$1(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init$1(obj, privateSet) {
    _check_private_redeclaration$1(obj, privateSet);
    privateSet.add(obj);
}
function _class_static_private_field_spec_get(receiver, classConstructor, descriptor) {
    _class_check_private_static_access(receiver, classConstructor);
    _class_check_private_static_field_descriptor(descriptor, "get");
    return _class_apply_descriptor_get$1(receiver, descriptor);
}
function _construct$4(Parent, args, Class) {
    if (_is_native_reflect_construct$h()) {
        _construct$4 = Reflect.construct;
    } else {
        _construct$4 = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of$h(instance, Class.prototype);
            return instance;
        };
    }
    return _construct$4.apply(null, arguments);
}
function _define_property$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array$d(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit$f(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$h() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread$b() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$1(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _set_prototype_of$h(o, p) {
    _set_prototype_of$h = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$h(o, p);
}
function _sliced_to_array$f(arr, i) {
    return _array_with_holes$h(arr) || _iterable_to_array_limit$f(arr, i) || _unsupported_iterable_to_array$q(arr, i) || _non_iterable_rest$h();
}
function _to_consumable_array$b(arr) {
    return _array_without_holes$b(arr) || _iterable_to_array$d(arr) || _unsupported_iterable_to_array$q(arr) || _non_iterable_spread$b();
}
function _unsupported_iterable_to_array$q(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$q(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$q(o, minLen);
}
function _class_check_private_static_access(receiver, classConstructor) {
    if (receiver !== classConstructor) {
        throw new TypeError("Private static access of wrong provenance");
    }
}
function _is_native_reflect_construct$h() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$h = function() {
        return !!result;
    })();
}
var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
    if (hasRequiredLib$2) return lib$2;
    hasRequiredLib$2 = 1;
    var LRUCache = require$$0$1.LRUCache;
    var hosts = requireHosts();
    var fromUrl = requireFromUrl();
    var parseUrl = requireParseUrl();
    var cache = new LRUCache({
        max: 1000
    });
    var _fill = /*#__PURE__*/ new WeakSet();
    var GitHost = /*#__PURE__*/ function() {
        function GitHost(type, user, auth, project, committish, defaultRepresentation) {
            var opts = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
            _class_call_check$D(this, GitHost);
            _class_private_method_init$1(this, _fill);
            Object.assign(this, _class_static_private_field_spec_get(GitHost, GitHost, _gitHosts)[type], {
                type: type,
                user: user,
                auth: auth,
                project: project,
                committish: committish,
                default: defaultRepresentation,
                opts: opts
            });
        }
        var _proto = GitHost.prototype;
        _proto.hash = function hash() {
            return this.committish ? "#".concat(this.committish) : '';
        };
        _proto.ssh = function ssh(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.sshtemplate, opts);
        };
        _proto.sshurl = function sshurl(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.sshurltemplate, opts);
        };
        _proto.browse = function browse(path) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            // not a string, treat path as opts
            if (typeof path !== 'string') {
                return _class_private_method_get$1(this, _fill, fill).call(this, this.browsetemplate, path);
            }
            if (typeof args[0] !== 'string') {
                return _class_private_method_get$1(this, _fill, fill).call(this, this.browsetreetemplate, _object_spread_props(_object_spread({}, args[0]), {
                    path: path
                }));
            }
            return _class_private_method_get$1(this, _fill, fill).call(this, this.browsetreetemplate, _object_spread_props(_object_spread({}, args[1]), {
                fragment: args[0],
                path: path
            }));
        };
        // If the path is known to be a file, then browseFile should be used. For some hosts
        // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
        // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
        // path will redirect to a specific commit. Using the `/blob/` path avoids this and
        // does not redirect to a different commit.
        _proto.browseFile = function browseFile(path) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            if (typeof args[0] !== 'string') {
                return _class_private_method_get$1(this, _fill, fill).call(this, this.browseblobtemplate, _object_spread_props(_object_spread({}, args[0]), {
                    path: path
                }));
            }
            return _class_private_method_get$1(this, _fill, fill).call(this, this.browseblobtemplate, _object_spread_props(_object_spread({}, args[1]), {
                fragment: args[0],
                path: path
            }));
        };
        _proto.docs = function docs(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.docstemplate, opts);
        };
        _proto.bugs = function bugs(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.bugstemplate, opts);
        };
        _proto.https = function https(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.httpstemplate, opts);
        };
        _proto.git = function git(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.gittemplate, opts);
        };
        _proto.shortcut = function shortcut(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.shortcuttemplate, opts);
        };
        _proto.path = function path(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.pathtemplate, opts);
        };
        _proto.tarball = function tarball(opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.tarballtemplate, _object_spread_props(_object_spread({}, opts), {
                noCommittish: false
            }));
        };
        _proto.file = function file(path, opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.filetemplate, _object_spread_props(_object_spread({}, opts), {
                path: path
            }));
        };
        _proto.edit = function edit(path, opts) {
            return _class_private_method_get$1(this, _fill, fill).call(this, this.edittemplate, _object_spread_props(_object_spread({}, opts), {
                path: path
            }));
        };
        _proto.getDefaultRepresentation = function getDefaultRepresentation() {
            return this.default;
        };
        _proto.toString = function toString(opts) {
            if (this.default && typeof this[this.default] === 'function') {
                return this[this.default](opts);
            }
            return this.sshurl(opts);
        };
        GitHost.addHost = function addHost(name, host) {
            _class_static_private_field_spec_get(GitHost, GitHost, _gitHosts)[name] = host;
            _class_static_private_field_spec_get(GitHost, GitHost, _gitHosts).byDomain[host.domain] = name;
            _class_static_private_field_spec_get(GitHost, GitHost, _gitHosts).byShortcut["".concat(name, ":")] = name;
            _class_static_private_field_spec_get(GitHost, GitHost, _protocols)["".concat(name, ":")] = {
                name: name
            };
        };
        GitHost.fromUrl = function fromUrl1(giturl, opts) {
            if (typeof giturl !== 'string') {
                return;
            }
            var key = giturl + JSON.stringify(opts || {});
            if (!cache.has(key)) {
                var hostArgs = fromUrl(giturl, opts, {
                    gitHosts: _class_static_private_field_spec_get(GitHost, GitHost, _gitHosts),
                    protocols: _class_static_private_field_spec_get(GitHost, GitHost, _protocols)
                });
                cache.set(key, hostArgs ? _construct$4(GitHost, _to_consumable_array$b(hostArgs)) : undefined);
            }
            return cache.get(key);
        };
        GitHost.parseUrl = function parseUrl1(url) {
            return parseUrl(url);
        };
        return GitHost;
    }();
    var _gitHosts = {
        writable: true,
        value: {
            byShortcut: {},
            byDomain: {}
        }
    };
    var _protocols = {
        writable: true,
        value: {
            'git+ssh:': {
                name: 'sshurl'
            },
            'ssh:': {
                name: 'sshurl'
            },
            'git+https:': {
                name: 'https',
                auth: true
            },
            'git:': {
                auth: true
            },
            'http:': {
                auth: true
            },
            'https:': {
                auth: true
            },
            'git+http:': {
                auth: true
            }
        }
    };
    function fill(template, opts) {
        if (typeof template !== 'function') {
            return null;
        }
        var options = _object_spread({}, this, this.opts, opts);
        // the path should always be set so we don't end up with 'undefined' in urls
        if (!options.path) {
            options.path = '';
        }
        // template functions will insert the leading slash themselves
        if (options.path.startsWith('/')) {
            options.path = options.path.slice(1);
        }
        if (options.noCommittish) {
            options.committish = null;
        }
        var result = template(options);
        return options.noGitPlus && result.startsWith('git+') ? result.slice(4) : result;
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.entries(hosts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array$f(_step.value, 2), name = _step_value[0], host = _step_value[1];
            GitHost.addHost(name, host);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    lib$2 = GitHost;
    return lib$2;
}

var re$1 = {
    exports: {}
};

var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
    if (hasRequiredConstants$1) return constants$1;
    hasRequiredConstants$1 = 1;
    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    var SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
    // Max safe segment length for coercion.
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    // Max safe length for a build identifier. The max length minus 6 characters for
    // the shortest version with a build 0.0.0+BUILD.
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
        'major',
        'premajor',
        'minor',
        'preminor',
        'patch',
        'prepatch',
        'prerelease'
    ];
    constants$1 = {
        MAX_LENGTH: MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
        RELEASE_TYPES: RELEASE_TYPES,
        SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
    };
    return constants$1;
}

function _array_like_to_array$p(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$a(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$p(arr);
}
function _iterable_to_array$c(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$a() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array$a(arr) {
    return _array_without_holes$a(arr) || _iterable_to_array$c(arr) || _unsupported_iterable_to_array$p(arr) || _non_iterable_spread$a();
}
function _type_of$L(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$p(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$p(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$p(o, minLen);
}
var debug_1$1;
var hasRequiredDebug$1;
function requireDebug$1() {
    var _console;
    if (hasRequiredDebug$1) return debug_1$1;
    hasRequiredDebug$1 = 1;
    var debug = (typeof process === "undefined" ? "undefined" : _type_of$L(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return (_console = console).error.apply(_console, [
            'SEMVER'
        ].concat(_to_consumable_array$a(args)));
    } : function() {};
    debug_1$1 = debug;
    return debug_1$1;
}

function _array_like_to_array$o(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$g(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$e(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$g() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$e(arr, i) {
    return _array_with_holes$g(arr) || _iterable_to_array_limit$e(arr, i) || _unsupported_iterable_to_array$o(arr, i) || _non_iterable_rest$g();
}
function _unsupported_iterable_to_array$o(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$o(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$o(o, minLen);
}
var hasRequiredRe$1;
function requireRe$1() {
    if (hasRequiredRe$1) return re$1.exports;
    hasRequiredRe$1 = 1;
    (function(module, exports) {
        var _require$$0 = requireConstants$1(), MAX_SAFE_COMPONENT_LENGTH = _require$$0.MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH = _require$$0.MAX_SAFE_BUILD_LENGTH, MAX_LENGTH = _require$$0.MAX_LENGTH;
        var debug = requireDebug$1();
        exports = module.exports = {};
        // The actual regexps go on exports.re
        var re = exports.re = [];
        var safeRe = exports.safeRe = [];
        var src = exports.src = [];
        var t = exports.t = {};
        var R = 0;
        var LETTERDASHNUMBER = '[a-zA-Z0-9-]';
        // Replace some greedy regex tokens to prevent regex dos issues. These regex are
        // used internally via the safeRe object since all inputs in this library get
        // normalized first to trim and collapse all extra whitespace. The original
        // regexes are exported for userland consumption and lower level usage. A
        // future breaking change could export the safer regex only with a note that
        // all input should have extra whitespace removed.
        var safeRegexReplacements = [
            [
                '\\s',
                1
            ],
            [
                '\\d',
                MAX_LENGTH
            ],
            [
                LETTERDASHNUMBER,
                MAX_SAFE_BUILD_LENGTH
            ]
        ];
        var makeSafeRegex = function(value) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = safeRegexReplacements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array$e(_step.value, 2), token = _step_value[0], max = _step_value[1];
                    value = value.split("".concat(token, "*")).join("".concat(token, "{0,").concat(max, "}")).split("".concat(token, "+")).join("".concat(token, "{1,").concat(max, "}"));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return value;
        };
        var createToken = function(name, value, isGlobal) {
            var safe = makeSafeRegex(value);
            var index = R++;
            debug(name, index, value);
            t[name] = index;
            src[index] = value;
            re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
            safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
        };
        // The following Regular Expressions can be used for tokenizing,
        // validating, and parsing SemVer version strings.
        // ## Numeric Identifier
        // A single `0`, or a non-zero digit followed by zero or more digits.
        createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
        createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
        // ## Non-numeric Identifier
        // Zero or more digits, followed by a letter or hyphen, and then zero or
        // more letters, digits, or hyphens.
        createToken('NONNUMERICIDENTIFIER', "\\d*[a-zA-Z-]".concat(LETTERDASHNUMBER, "*"));
        // ## Main Version
        // Three dot-separated numeric identifiers.
        createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
        createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")"));
        // ## Pre-release Version Identifier
        // A numeric identifier, or a non-numeric identifier.
        createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
        createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
        // ## Pre-release Version
        // Hyphen, followed by one or more dot-separated pre-release version
        // identifiers.
        createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
        createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))"));
        // ## Build Metadata Identifier
        // Any combination of digits, letters, or hyphens.
        createToken('BUILDIDENTIFIER', "".concat(LETTERDASHNUMBER, "+"));
        // ## Build Metadata
        // Plus sign, followed by one or more period-separated build metadata
        // identifiers.
        createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))"));
        // ## Full Version String
        // A main version, followed optionally by a pre-release version and
        // build metadata.
        // Note that the only major, minor, patch, and pre-release sections of
        // the version string are capturing groups.  The build metadata is not a
        // capturing group, because it should not ever be used in version
        // comparison.
        createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
        createToken('FULL', "^".concat(src[t.FULLPLAIN], "$"));
        // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
        // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
        // common in the npm registry.
        createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
        createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
        createToken('GTLT', '((?:<|>)?=?)');
        // Something like "2.*" or "1.2.x".
        // Note that "x.x" is a valid xRange identifer, meaning "any version"
        // Only the first item is strictly required.
        createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
        createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
        createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
        createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
        createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
        createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$"));
        // Coercion.
        // Extract anything that could conceivably be a part of a valid semver
        createToken('COERCEPLAIN', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?"));
        createToken('COERCE', "".concat(src[t.COERCEPLAIN], "(?:$|[^\\d])"));
        createToken('COERCEFULL', src[t.COERCEPLAIN] + "(?:".concat(src[t.PRERELEASE], ")?") + "(?:".concat(src[t.BUILD], ")?") + "(?:$|[^\\d])");
        createToken('COERCERTL', src[t.COERCE], true);
        createToken('COERCERTLFULL', src[t.COERCEFULL], true);
        // Tilde ranges.
        // Meaning is "reasonably at or greater than"
        createToken('LONETILDE', '(?:~>?)');
        createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
        exports.tildeTrimReplace = '$1~';
        createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
        createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$"));
        // Caret ranges.
        // Meaning is "at least and backwards compatible with"
        createToken('LONECARET', '(?:\\^)');
        createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
        exports.caretTrimReplace = '$1^';
        createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
        createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$"));
        // A simple gt/lt/eq thing, or just "" to indicate "any version"
        createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
        createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$"));
        // An expression to strip any whitespace between the gtlt and the thing
        // it modifies, so that `> 1.2.3` ==> `>1.2.3`
        createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
        exports.comparatorTrimReplace = '$1$2$3';
        // Something like `1.2.3 - 1.2.4`
        // Note that these all use the loose form, because they'll be
        // checked against either the strict or loose comparator form
        // later.
        createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
        createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$");
        // Star ranges basically just allow anything at all.
        createToken('STAR', '(<|>)?=?\\s*\\*');
        // >=0.0.0 is like a star
        createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
        createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    })(re$1, re$1.exports);
    return re$1.exports;
}

function _type_of$K(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var parseOptions_1$1;
var hasRequiredParseOptions$1;
function requireParseOptions$1() {
    if (hasRequiredParseOptions$1) return parseOptions_1$1;
    hasRequiredParseOptions$1 = 1;
    // parse out just the options we care about
    var looseOption = Object.freeze({
        loose: true
    });
    var emptyOpts = Object.freeze({});
    var parseOptions = function(options) {
        if (!options) {
            return emptyOpts;
        }
        if ((typeof options === "undefined" ? "undefined" : _type_of$K(options)) !== 'object') {
            return looseOption;
        }
        return options;
    };
    parseOptions_1$1 = parseOptions;
    return parseOptions_1$1;
}

var identifiers$1;
var hasRequiredIdentifiers$1;
function requireIdentifiers$1() {
    if (hasRequiredIdentifiers$1) return identifiers$1;
    hasRequiredIdentifiers$1 = 1;
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = function(a, b) {
        var anum = numeric.test(a);
        var bnum = numeric.test(b);
        if (anum && bnum) {
            a = +a;
            b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = function(a, b) {
        return compareIdentifiers(b, a);
    };
    identifiers$1 = {
        compareIdentifiers: compareIdentifiers,
        rcompareIdentifiers: rcompareIdentifiers
    };
    return identifiers$1;
}

function _class_call_check$C(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _instanceof$t(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _type_of$J(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var semver$4;
var hasRequiredSemver$3;
function requireSemver$3() {
    if (hasRequiredSemver$3) return semver$4;
    hasRequiredSemver$3 = 1;
    var debug = requireDebug$1();
    var _require$$1 = requireConstants$1(), MAX_LENGTH = _require$$1.MAX_LENGTH, MAX_SAFE_INTEGER = _require$$1.MAX_SAFE_INTEGER;
    var _require$$2 = requireRe$1(), re = _require$$2.safeRe, t = _require$$2.t;
    var parseOptions = requireParseOptions$1();
    var compareIdentifiers = requireIdentifiers$1().compareIdentifiers;
    var SemVer = /*#__PURE__*/ function() {
        function SemVer(version, options) {
            _class_call_check$C(this, SemVer);
            options = parseOptions(options);
            if (_instanceof$t(version, SemVer)) {
                if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                    return version;
                } else {
                    version = version.version;
                }
            } else if (typeof version !== 'string') {
                throw new TypeError('Invalid version. Must be a string. Got type "'.concat(typeof version === "undefined" ? "undefined" : _type_of$J(version), '".'));
            }
            if (version.length > MAX_LENGTH) {
                throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
            }
            debug('SemVer', version, options);
            this.options = options;
            this.loose = !!options.loose;
            // this isn't actually relevant for versions, but keep it so that we
            // don't run into trouble passing this.options around.
            this.includePrerelease = !!options.includePrerelease;
            var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
            if (!m) {
                throw new TypeError("Invalid Version: ".concat(version));
            }
            this.raw = version;
            // these are actually numbers
            this.major = +m[1];
            this.minor = +m[2];
            this.patch = +m[3];
            if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
                throw new TypeError('Invalid major version');
            }
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
                throw new TypeError('Invalid minor version');
            }
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
                throw new TypeError('Invalid patch version');
            }
            // numberify any prerelease numeric ids
            if (!m[4]) {
                this.prerelease = [];
            } else {
                this.prerelease = m[4].split('.').map(function(id) {
                    if (/^[0-9]+$/.test(id)) {
                        var num = +id;
                        if (num >= 0 && num < MAX_SAFE_INTEGER) {
                            return num;
                        }
                    }
                    return id;
                });
            }
            this.build = m[5] ? m[5].split('.') : [];
            this.format();
        }
        var _proto = SemVer.prototype;
        _proto.format = function format() {
            this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
            if (this.prerelease.length) {
                this.version += "-".concat(this.prerelease.join('.'));
            }
            return this.version;
        };
        _proto.toString = function toString() {
            return this.version;
        };
        _proto.compare = function compare(other) {
            debug('SemVer.compare', this.version, this.options, other);
            if (!_instanceof$t(other, SemVer)) {
                if (typeof other === 'string' && other === this.version) {
                    return 0;
                }
                other = new SemVer(other, this.options);
            }
            if (other.version === this.version) {
                return 0;
            }
            return this.compareMain(other) || this.comparePre(other);
        };
        _proto.compareMain = function compareMain(other) {
            if (!_instanceof$t(other, SemVer)) {
                other = new SemVer(other, this.options);
            }
            return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        };
        _proto.comparePre = function comparePre(other) {
            if (!_instanceof$t(other, SemVer)) {
                other = new SemVer(other, this.options);
            }
            // NOT having a prerelease is > having one
            if (this.prerelease.length && !other.prerelease.length) {
                return -1;
            } else if (!this.prerelease.length && other.prerelease.length) {
                return 1;
            } else if (!this.prerelease.length && !other.prerelease.length) {
                return 0;
            }
            var i = 0;
            do {
                var a = this.prerelease[i];
                var b = other.prerelease[i];
                debug('prerelease compare', i, a, b);
                if (a === undefined && b === undefined) {
                    return 0;
                } else if (b === undefined) {
                    return 1;
                } else if (a === undefined) {
                    return -1;
                } else if (a === b) {
                    continue;
                } else {
                    return compareIdentifiers(a, b);
                }
            }while (++i);
        };
        _proto.compareBuild = function compareBuild(other) {
            if (!_instanceof$t(other, SemVer)) {
                other = new SemVer(other, this.options);
            }
            var i = 0;
            do {
                var a = this.build[i];
                var b = other.build[i];
                debug('build compare', i, a, b);
                if (a === undefined && b === undefined) {
                    return 0;
                } else if (b === undefined) {
                    return 1;
                } else if (a === undefined) {
                    return -1;
                } else if (a === b) {
                    continue;
                } else {
                    return compareIdentifiers(a, b);
                }
            }while (++i);
        };
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        _proto.inc = function inc(release, identifier, identifierBase) {
            switch(release){
                case 'premajor':
                    this.prerelease.length = 0;
                    this.patch = 0;
                    this.minor = 0;
                    this.major++;
                    this.inc('pre', identifier, identifierBase);
                    break;
                case 'preminor':
                    this.prerelease.length = 0;
                    this.patch = 0;
                    this.minor++;
                    this.inc('pre', identifier, identifierBase);
                    break;
                case 'prepatch':
                    // If this is already a prerelease, it will bump to the next version
                    // drop any prereleases that might already exist, since they are not
                    // relevant at this point.
                    this.prerelease.length = 0;
                    this.inc('patch', identifier, identifierBase);
                    this.inc('pre', identifier, identifierBase);
                    break;
                // If the input is a non-prerelease version, this acts the same as
                // prepatch.
                case 'prerelease':
                    if (this.prerelease.length === 0) {
                        this.inc('patch', identifier, identifierBase);
                    }
                    this.inc('pre', identifier, identifierBase);
                    break;
                case 'major':
                    // If this is a pre-major version, bump up to the same major version.
                    // Otherwise increment major.
                    // 1.0.0-5 bumps to 1.0.0
                    // 1.1.0 bumps to 2.0.0
                    if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                        this.major++;
                    }
                    this.minor = 0;
                    this.patch = 0;
                    this.prerelease = [];
                    break;
                case 'minor':
                    // If this is a pre-minor version, bump up to the same minor version.
                    // Otherwise increment minor.
                    // 1.2.0-5 bumps to 1.2.0
                    // 1.2.1 bumps to 1.3.0
                    if (this.patch !== 0 || this.prerelease.length === 0) {
                        this.minor++;
                    }
                    this.patch = 0;
                    this.prerelease = [];
                    break;
                case 'patch':
                    // If this is not a pre-release version, it will increment the patch.
                    // If it is a pre-release it will bump up to the same patch version.
                    // 1.2.0-5 patches to 1.2.0
                    // 1.2.0 patches to 1.2.1
                    if (this.prerelease.length === 0) {
                        this.patch++;
                    }
                    this.prerelease = [];
                    break;
                // This probably shouldn't be used publicly.
                // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
                case 'pre':
                    {
                        var base = Number(identifierBase) ? 1 : 0;
                        if (!identifier && identifierBase === false) {
                            throw new Error('invalid increment argument: identifier is empty');
                        }
                        if (this.prerelease.length === 0) {
                            this.prerelease = [
                                base
                            ];
                        } else {
                            var i = this.prerelease.length;
                            while(--i >= 0){
                                if (typeof this.prerelease[i] === 'number') {
                                    this.prerelease[i]++;
                                    i = -2;
                                }
                            }
                            if (i === -1) {
                                // didn't increment anything
                                if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                    throw new Error('invalid increment argument: identifier already exists');
                                }
                                this.prerelease.push(base);
                            }
                        }
                        if (identifier) {
                            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                            var prerelease = [
                                identifier,
                                base
                            ];
                            if (identifierBase === false) {
                                prerelease = [
                                    identifier
                                ];
                            }
                            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                                if (isNaN(this.prerelease[1])) {
                                    this.prerelease = prerelease;
                                }
                            } else {
                                this.prerelease = prerelease;
                            }
                        }
                        break;
                    }
                default:
                    throw new Error("invalid increment argument: ".concat(release));
            }
            this.raw = this.format();
            if (this.build.length) {
                this.raw += "+".concat(this.build.join('.'));
            }
            return this;
        };
        return SemVer;
    }();
    semver$4 = SemVer;
    return semver$4;
}

function _instanceof$s(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var parse_1$1;
var hasRequiredParse$1;
function requireParse$1() {
    if (hasRequiredParse$1) return parse_1$1;
    hasRequiredParse$1 = 1;
    var SemVer = requireSemver$3();
    var parse = function(version, options) {
        var throwErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (_instanceof$s(version, SemVer)) {
            return version;
        }
        try {
            return new SemVer(version, options);
        } catch (er) {
            if (!throwErrors) {
                return null;
            }
            throw er;
        }
    };
    parse_1$1 = parse;
    return parse_1$1;
}

var valid_1$1;
var hasRequiredValid$3;
function requireValid$3() {
    if (hasRequiredValid$3) return valid_1$1;
    hasRequiredValid$3 = 1;
    var parse = requireParse$1();
    var valid = function(version, options) {
        var v = parse(version, options);
        return v ? v.version : null;
    };
    valid_1$1 = valid;
    return valid_1$1;
}

var clean_1$1;
var hasRequiredClean$1;
function requireClean$1() {
    if (hasRequiredClean$1) return clean_1$1;
    hasRequiredClean$1 = 1;
    var parse = requireParse$1();
    var clean = function(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ''), options);
        return s ? s.version : null;
    };
    clean_1$1 = clean;
    return clean_1$1;
}

function _instanceof$r(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var inc_1$1;
var hasRequiredInc$1;
function requireInc$1() {
    if (hasRequiredInc$1) return inc_1$1;
    hasRequiredInc$1 = 1;
    var SemVer = requireSemver$3();
    var inc = function(version, release, options, identifier, identifierBase) {
        if (typeof options === 'string') {
            identifierBase = identifier;
            identifier = options;
            options = undefined;
        }
        try {
            return new SemVer(_instanceof$r(version, SemVer) ? version.version : version, options).inc(release, identifier, identifierBase).version;
        } catch (er) {
            return null;
        }
    };
    inc_1$1 = inc;
    return inc_1$1;
}

var diff_1$1;
var hasRequiredDiff$1;
function requireDiff$1() {
    if (hasRequiredDiff$1) return diff_1$1;
    hasRequiredDiff$1 = 1;
    var parse = requireParse$1();
    var diff = function(version1, version2) {
        var v1 = parse(version1, null, true);
        var v2 = parse(version2, null, true);
        var comparison = v1.compare(v2);
        if (comparison === 0) {
            return null;
        }
        var v1Higher = comparison > 0;
        var highVersion = v1Higher ? v1 : v2;
        var lowVersion = v1Higher ? v2 : v1;
        var highHasPre = !!highVersion.prerelease.length;
        var lowHasPre = !!lowVersion.prerelease.length;
        if (lowHasPre && !highHasPre) {
            // Going from prerelease -> no prerelease requires some special casing
            // If the low version has only a major, then it will always be a major
            // Some examples:
            // 1.0.0-1 -> 1.0.0
            // 1.0.0-1 -> 1.1.1
            // 1.0.0-1 -> 2.0.0
            if (!lowVersion.patch && !lowVersion.minor) {
                return 'major';
            }
            // Otherwise it can be determined by checking the high version
            if (highVersion.patch) {
                // anything higher than a patch bump would result in the wrong version
                return 'patch';
            }
            if (highVersion.minor) {
                // anything higher than a minor bump would result in the wrong version
                return 'minor';
            }
            // bumping major/minor/patch all have same result
            return 'major';
        }
        // add the `pre` prefix if we are going to a prerelease version
        var prefix = highHasPre ? 'pre' : '';
        if (v1.major !== v2.major) {
            return prefix + 'major';
        }
        if (v1.minor !== v2.minor) {
            return prefix + 'minor';
        }
        if (v1.patch !== v2.patch) {
            return prefix + 'patch';
        }
        // high and low are preleases
        return 'prerelease';
    };
    diff_1$1 = diff;
    return diff_1$1;
}

var major_1$1;
var hasRequiredMajor$1;
function requireMajor$1() {
    if (hasRequiredMajor$1) return major_1$1;
    hasRequiredMajor$1 = 1;
    var SemVer = requireSemver$3();
    var major = function(a, loose) {
        return new SemVer(a, loose).major;
    };
    major_1$1 = major;
    return major_1$1;
}

var minor_1$1;
var hasRequiredMinor$1;
function requireMinor$1() {
    if (hasRequiredMinor$1) return minor_1$1;
    hasRequiredMinor$1 = 1;
    var SemVer = requireSemver$3();
    var minor = function(a, loose) {
        return new SemVer(a, loose).minor;
    };
    minor_1$1 = minor;
    return minor_1$1;
}

var patch_1$1;
var hasRequiredPatch$1;
function requirePatch$1() {
    if (hasRequiredPatch$1) return patch_1$1;
    hasRequiredPatch$1 = 1;
    var SemVer = requireSemver$3();
    var patch = function(a, loose) {
        return new SemVer(a, loose).patch;
    };
    patch_1$1 = patch;
    return patch_1$1;
}

var prerelease_1$1;
var hasRequiredPrerelease$1;
function requirePrerelease$1() {
    if (hasRequiredPrerelease$1) return prerelease_1$1;
    hasRequiredPrerelease$1 = 1;
    var parse = requireParse$1();
    var prerelease = function(version, options) {
        var parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    prerelease_1$1 = prerelease;
    return prerelease_1$1;
}

var compare_1$1;
var hasRequiredCompare$1;
function requireCompare$1() {
    if (hasRequiredCompare$1) return compare_1$1;
    hasRequiredCompare$1 = 1;
    var SemVer = requireSemver$3();
    var compare = function(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose));
    };
    compare_1$1 = compare;
    return compare_1$1;
}

var rcompare_1$1;
var hasRequiredRcompare$1;
function requireRcompare$1() {
    if (hasRequiredRcompare$1) return rcompare_1$1;
    hasRequiredRcompare$1 = 1;
    var compare = requireCompare$1();
    var rcompare = function(a, b, loose) {
        return compare(b, a, loose);
    };
    rcompare_1$1 = rcompare;
    return rcompare_1$1;
}

var compareLoose_1$1;
var hasRequiredCompareLoose$1;
function requireCompareLoose$1() {
    if (hasRequiredCompareLoose$1) return compareLoose_1$1;
    hasRequiredCompareLoose$1 = 1;
    var compare = requireCompare$1();
    var compareLoose = function(a, b) {
        return compare(a, b, true);
    };
    compareLoose_1$1 = compareLoose;
    return compareLoose_1$1;
}

var compareBuild_1$1;
var hasRequiredCompareBuild$1;
function requireCompareBuild$1() {
    if (hasRequiredCompareBuild$1) return compareBuild_1$1;
    hasRequiredCompareBuild$1 = 1;
    var SemVer = requireSemver$3();
    var compareBuild = function(a, b, loose) {
        var versionA = new SemVer(a, loose);
        var versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    compareBuild_1$1 = compareBuild;
    return compareBuild_1$1;
}

var sort_1$1;
var hasRequiredSort$1;
function requireSort$1() {
    if (hasRequiredSort$1) return sort_1$1;
    hasRequiredSort$1 = 1;
    var compareBuild = requireCompareBuild$1();
    var sort = function(list, loose) {
        return list.sort(function(a, b) {
            return compareBuild(a, b, loose);
        });
    };
    sort_1$1 = sort;
    return sort_1$1;
}

var rsort_1$1;
var hasRequiredRsort$1;
function requireRsort$1() {
    if (hasRequiredRsort$1) return rsort_1$1;
    hasRequiredRsort$1 = 1;
    var compareBuild = requireCompareBuild$1();
    var rsort = function(list, loose) {
        return list.sort(function(a, b) {
            return compareBuild(b, a, loose);
        });
    };
    rsort_1$1 = rsort;
    return rsort_1$1;
}

var gt_1$1;
var hasRequiredGt$1;
function requireGt$1() {
    if (hasRequiredGt$1) return gt_1$1;
    hasRequiredGt$1 = 1;
    var compare = requireCompare$1();
    var gt = function(a, b, loose) {
        return compare(a, b, loose) > 0;
    };
    gt_1$1 = gt;
    return gt_1$1;
}

var lt_1$1;
var hasRequiredLt$1;
function requireLt$1() {
    if (hasRequiredLt$1) return lt_1$1;
    hasRequiredLt$1 = 1;
    var compare = requireCompare$1();
    var lt = function(a, b, loose) {
        return compare(a, b, loose) < 0;
    };
    lt_1$1 = lt;
    return lt_1$1;
}

var eq_1$1;
var hasRequiredEq$1;
function requireEq$1() {
    if (hasRequiredEq$1) return eq_1$1;
    hasRequiredEq$1 = 1;
    var compare = requireCompare$1();
    var eq = function(a, b, loose) {
        return compare(a, b, loose) === 0;
    };
    eq_1$1 = eq;
    return eq_1$1;
}

var neq_1$1;
var hasRequiredNeq$1;
function requireNeq$1() {
    if (hasRequiredNeq$1) return neq_1$1;
    hasRequiredNeq$1 = 1;
    var compare = requireCompare$1();
    var neq = function(a, b, loose) {
        return compare(a, b, loose) !== 0;
    };
    neq_1$1 = neq;
    return neq_1$1;
}

var gte_1$1;
var hasRequiredGte$1;
function requireGte$1() {
    if (hasRequiredGte$1) return gte_1$1;
    hasRequiredGte$1 = 1;
    var compare = requireCompare$1();
    var gte = function(a, b, loose) {
        return compare(a, b, loose) >= 0;
    };
    gte_1$1 = gte;
    return gte_1$1;
}

var lte_1$1;
var hasRequiredLte$1;
function requireLte$1() {
    if (hasRequiredLte$1) return lte_1$1;
    hasRequiredLte$1 = 1;
    var compare = requireCompare$1();
    var lte = function(a, b, loose) {
        return compare(a, b, loose) <= 0;
    };
    lte_1$1 = lte;
    return lte_1$1;
}

function _type_of$I(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var cmp_1$1;
var hasRequiredCmp$1;
function requireCmp$1() {
    if (hasRequiredCmp$1) return cmp_1$1;
    hasRequiredCmp$1 = 1;
    var eq = requireEq$1();
    var neq = requireNeq$1();
    var gt = requireGt$1();
    var gte = requireGte$1();
    var lt = requireLt$1();
    var lte = requireLte$1();
    var cmp = function(a, op, b, loose) {
        switch(op){
            case '===':
                if ((typeof a === "undefined" ? "undefined" : _type_of$I(a)) === 'object') {
                    a = a.version;
                }
                if ((typeof b === "undefined" ? "undefined" : _type_of$I(b)) === 'object') {
                    b = b.version;
                }
                return a === b;
            case '!==':
                if ((typeof a === "undefined" ? "undefined" : _type_of$I(a)) === 'object') {
                    a = a.version;
                }
                if ((typeof b === "undefined" ? "undefined" : _type_of$I(b)) === 'object') {
                    b = b.version;
                }
                return a !== b;
            case '':
            case '=':
            case '==':
                return eq(a, b, loose);
            case '!=':
                return neq(a, b, loose);
            case '>':
                return gt(a, b, loose);
            case '>=':
                return gte(a, b, loose);
            case '<':
                return lt(a, b, loose);
            case '<=':
                return lte(a, b, loose);
            default:
                throw new TypeError("Invalid operator: ".concat(op));
        }
    };
    cmp_1$1 = cmp;
    return cmp_1$1;
}

function _instanceof$q(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var coerce_1$1;
var hasRequiredCoerce$1;
function requireCoerce$1() {
    if (hasRequiredCoerce$1) return coerce_1$1;
    hasRequiredCoerce$1 = 1;
    var SemVer = requireSemver$3();
    var parse = requireParse$1();
    var _require$$2 = requireRe$1(), re = _require$$2.safeRe, t = _require$$2.t;
    var coerce = function(version, options) {
        if (_instanceof$q(version, SemVer)) {
            return version;
        }
        if (typeof version === 'number') {
            version = String(version);
        }
        if (typeof version !== 'string') {
            return null;
        }
        options = options || {};
        var match = null;
        if (!options.rtl) {
            match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
        } else {
            // Find the right-most coercible string that does not share
            // a terminus with a more left-ward coercible string.
            // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
            // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
            //
            // Walk through the string checking with a /g regexp
            // Manually set the index so as to pick up overlapping matches.
            // Stop when we get a match that ends at the string end, since no
            // coercible string can be more right-ward without the same terminus.
            var coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
            var next;
            while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
                if (!match || next.index + next[0].length !== match.index + match[0].length) {
                    match = next;
                }
                coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
            }
            // leave it in a clean state
            coerceRtlRegex.lastIndex = -1;
        }
        if (match === null) {
            return null;
        }
        var major = match[2];
        var minor = match[3] || '0';
        var patch = match[4] || '0';
        var prerelease = options.includePrerelease && match[5] ? "-".concat(match[5]) : '';
        var build = options.includePrerelease && match[6] ? "+".concat(match[6]) : '';
        return parse("".concat(major, ".").concat(minor, ".").concat(patch).concat(prerelease).concat(build), options);
    };
    coerce_1$1 = coerce;
    return coerce_1$1;
}

function _class_call_check$B(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var lrucache$1;
var hasRequiredLrucache$1;
function requireLrucache$1() {
    if (hasRequiredLrucache$1) return lrucache$1;
    hasRequiredLrucache$1 = 1;
    var LRUCache = /*#__PURE__*/ function() {
        function LRUCache() {
            _class_call_check$B(this, LRUCache);
            this.max = 1000;
            this.map = new Map();
        }
        var _proto = LRUCache.prototype;
        _proto.get = function get(key) {
            var value = this.map.get(key);
            if (value === undefined) {
                return undefined;
            } else {
                // Remove the key from the map and add it to the end
                this.map.delete(key);
                this.map.set(key, value);
                return value;
            }
        };
        _proto.delete = function _delete(key) {
            return this.map.delete(key);
        };
        _proto.set = function set(key, value) {
            var deleted = this.delete(key);
            if (!deleted && value !== undefined) {
                // If cache is full, delete the least recently used item
                if (this.map.size >= this.max) {
                    var firstKey = this.map.keys().next().value;
                    this.delete(firstKey);
                }
                this.map.set(key, value);
            }
            return this;
        };
        return LRUCache;
    }();
    lrucache$1 = LRUCache;
    return lrucache$1;
}

function _array_like_to_array$n(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$9(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$n(arr);
}
function _class_call_check$A(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$a(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$a(Constructor, protoProps, staticProps) {
    _defineProperties$a(Constructor.prototype, protoProps);
    return Constructor;
}
function _instanceof$p(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array$b(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$9() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array$9(arr) {
    return _array_without_holes$9(arr) || _iterable_to_array$b(arr) || _unsupported_iterable_to_array$n(arr) || _non_iterable_spread$9();
}
function _unsupported_iterable_to_array$n(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$n(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$n(o, minLen);
}
var range$1;
var hasRequiredRange$1;
function requireRange$1() {
    if (hasRequiredRange$1) return range$1;
    hasRequiredRange$1 = 1;
    var SPACE_CHARACTERS = /\s+/g;
    // hoisted class for cyclic dependency
    var Range = /*#__PURE__*/ function() {
        function Range(range, options) {
            var _this = this;
            _class_call_check$A(this, Range);
            options = parseOptions(options);
            if (_instanceof$p(range, Range)) {
                if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                    return range;
                } else {
                    return new Range(range.raw, options);
                }
            }
            if (_instanceof$p(range, Comparator)) {
                // just put it in the set and return
                this.raw = range.value;
                this.set = [
                    [
                        range
                    ]
                ];
                this.formatted = undefined;
                return this;
            }
            this.options = options;
            this.loose = !!options.loose;
            this.includePrerelease = !!options.includePrerelease;
            // First reduce all whitespace as much as possible so we do not have to rely
            // on potentially slow regexes like \s*. This is then stored and used for
            // future error messages as well.
            this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
            // First, split on ||
            this.set = this.raw.split('||')// map the range to a 2d array of comparators
            .map(function(r) {
                return _this.parseRange(r.trim());
            })// throw out any comparator lists that are empty
            // this generally means that it was not a valid range, which is allowed
            // in loose mode, but will still throw if the WHOLE range is invalid.
            .filter(function(c) {
                return c.length;
            });
            if (!this.set.length) {
                throw new TypeError("Invalid SemVer Range: ".concat(this.raw));
            }
            // if we have any that are not the null set, throw out null sets.
            if (this.set.length > 1) {
                // keep the first one, in case they're all null sets
                var first = this.set[0];
                this.set = this.set.filter(function(c) {
                    return !isNullSet(c[0]);
                });
                if (this.set.length === 0) {
                    this.set = [
                        first
                    ];
                } else if (this.set.length > 1) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        // if we have any that are *, then the range is just *
                        for(var _iterator = this.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var c = _step.value;
                            if (c.length === 1 && isAny(c[0])) {
                                this.set = [
                                    c
                                ];
                                break;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            }
            this.formatted = undefined;
        }
        var _proto = Range.prototype;
        _proto.format = function format() {
            return this.range;
        };
        _proto.toString = function toString() {
            return this.range;
        };
        _proto.parseRange = function parseRange(range) {
            var _this = this;
            // memoize range parsing for performance.
            // this is a very hot path, and fully deterministic.
            var memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
            var memoKey = memoOpts + ':' + range;
            var cached = cache.get(memoKey);
            if (cached) {
                return cached;
            }
            var loose = this.options.loose;
            // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
            var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
            range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
            debug('hyphen replace', range);
            // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
            range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
            debug('comparator trim', range);
            // `~ 1.2.3` => `~1.2.3`
            range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
            debug('tilde trim', range);
            // `^ 1.2.3` => `^1.2.3`
            range = range.replace(re[t.CARETTRIM], caretTrimReplace);
            debug('caret trim', range);
            // At this point, the range is completely trimmed and
            // ready to be split into comparators.
            var rangeList = range.split(' ').map(function(comp) {
                return parseComparator(comp, _this.options);
            }).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
            .map(function(comp) {
                return replaceGTE0(comp, _this.options);
            });
            if (loose) {
                // in loose mode, throw out any that are not valid comparators
                rangeList = rangeList.filter(function(comp) {
                    debug('loose invalid filter', comp, _this.options);
                    return !!comp.match(re[t.COMPARATORLOOSE]);
                });
            }
            debug('range list', rangeList);
            // if any comparators are the null set, then replace with JUST null set
            // if more than one comparator, remove any * comparators
            // also, don't include the same comparator more than once
            var rangeMap = new Map();
            var comparators = rangeList.map(function(comp) {
                return new Comparator(comp, _this.options);
            });
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = comparators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var comp = _step.value;
                    if (isNullSet(comp)) {
                        return [
                            comp
                        ];
                    }
                    rangeMap.set(comp.value, comp);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (rangeMap.size > 1 && rangeMap.has('')) {
                rangeMap.delete('');
            }
            var result = _to_consumable_array$9(rangeMap.values());
            cache.set(memoKey, result);
            return result;
        };
        _proto.intersects = function intersects(range, options) {
            if (!_instanceof$p(range, Range)) {
                throw new TypeError('a Range is required');
            }
            return this.set.some(function(thisComparators) {
                return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
                    return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                        return rangeComparators.every(function(rangeComparator) {
                            return thisComparator.intersects(rangeComparator, options);
                        });
                    });
                });
            });
        };
        // if ANY of the sets match ALL of its comparators, then pass
        _proto.test = function test(version) {
            if (!version) {
                return false;
            }
            if (typeof version === 'string') {
                try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
            }
            for(var i = 0; i < this.set.length; i++){
                if (testSet(this.set[i], version, this.options)) {
                    return true;
                }
            }
            return false;
        };
        _create_class$a(Range, [
            {
                key: "range",
                get: function get() {
                    if (this.formatted === undefined) {
                        this.formatted = '';
                        for(var i = 0; i < this.set.length; i++){
                            if (i > 0) {
                                this.formatted += '||';
                            }
                            var comps = this.set[i];
                            for(var k = 0; k < comps.length; k++){
                                if (k > 0) {
                                    this.formatted += ' ';
                                }
                                this.formatted += comps[k].toString().trim();
                            }
                        }
                    }
                    return this.formatted;
                }
            }
        ]);
        return Range;
    }();
    range$1 = Range;
    var LRU = requireLrucache$1();
    var cache = new LRU();
    var parseOptions = requireParseOptions$1();
    var Comparator = requireComparator$1();
    var debug = requireDebug$1();
    var SemVer = requireSemver$3();
    var _require$$5 = requireRe$1(), re = _require$$5.safeRe, t = _require$$5.t, comparatorTrimReplace = _require$$5.comparatorTrimReplace, tildeTrimReplace = _require$$5.tildeTrimReplace, caretTrimReplace = _require$$5.caretTrimReplace;
    var _require$$6 = requireConstants$1(), FLAG_INCLUDE_PRERELEASE = _require$$6.FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE = _require$$6.FLAG_LOOSE;
    var isNullSet = function(c) {
        return c.value === '<0.0.0-0';
    };
    var isAny = function(c) {
        return c.value === '';
    };
    // take a set of comparators and determine whether there
    // exists a version which can satisfy it
    var isSatisfiable = function(comparators, options) {
        var result = true;
        var remainingComparators = comparators.slice();
        var testComparator = remainingComparators.pop();
        while(result && remainingComparators.length){
            result = remainingComparators.every(function(otherComparator) {
                return testComparator.intersects(otherComparator, options);
            });
            testComparator = remainingComparators.pop();
        }
        return result;
    };
    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    var parseComparator = function(comp, options) {
        debug('comp', comp, options);
        comp = replaceCarets(comp, options);
        debug('caret', comp);
        comp = replaceTildes(comp, options);
        debug('tildes', comp);
        comp = replaceXRanges(comp, options);
        debug('xrange', comp);
        comp = replaceStars(comp, options);
        debug('stars', comp);
        return comp;
    };
    var isX = function(id) {
        return !id || id.toLowerCase() === 'x' || id === '*';
    };
    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    // ~0.0.1 --> >=0.0.1 <0.1.0-0
    var replaceTildes = function(comp, options) {
        return comp.trim().split(/\s+/).map(function(c) {
            return replaceTilde(c, options);
        }).join(' ');
    };
    var replaceTilde = function(comp, options) {
        var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, function(_, M, m, p, pr) {
            debug('tilde', comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
                ret = '';
            } else if (isX(m)) {
                ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
            } else if (isX(p)) {
                // ~1.2 == >=1.2.0 <1.3.0-0
                ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
            } else if (pr) {
                debug('replaceTilde pr', pr);
                ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
            } else {
                // ~1.2.3 == >=1.2.3 <1.3.0-0
                ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
            }
            debug('tilde return', ret);
            return ret;
        });
    };
    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    // ^1.2.3 --> >=1.2.3 <2.0.0-0
    // ^1.2.0 --> >=1.2.0 <2.0.0-0
    // ^0.0.1 --> >=0.0.1 <0.0.2-0
    // ^0.1.0 --> >=0.1.0 <0.2.0-0
    var replaceCarets = function(comp, options) {
        return comp.trim().split(/\s+/).map(function(c) {
            return replaceCaret(c, options);
        }).join(' ');
    };
    var replaceCaret = function(comp, options) {
        debug('caret', comp, options);
        var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        var z = options.includePrerelease ? '-0' : '';
        return comp.replace(r, function(_, M, m, p, pr) {
            debug('caret', comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
                ret = '';
            } else if (isX(m)) {
                ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
            } else if (isX(p)) {
                if (M === '0') {
                    ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
                } else {
                    ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
                }
            } else if (pr) {
                debug('replaceCaret pr', pr);
                if (M === '0') {
                    if (m === '0') {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
                    } else {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                } else {
                    ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
                }
            } else {
                debug('no pr');
                if (M === '0') {
                    if (m === '0') {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
                    } else {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                } else {
                    ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
                }
            }
            debug('caret return', ret);
            return ret;
        });
    };
    var replaceXRanges = function(comp, options) {
        debug('replaceXRanges', comp, options);
        return comp.split(/\s+/).map(function(c) {
            return replaceXRange(c, options);
        }).join(' ');
    };
    var replaceXRange = function(comp, options) {
        comp = comp.trim();
        var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
            debug('xRange', comp, ret, gtlt, M, m, p, pr);
            var xM = isX(M);
            var xm = xM || isX(m);
            var xp = xm || isX(p);
            var anyX = xp;
            if (gtlt === '=' && anyX) {
                gtlt = '';
            }
            // if we're including prereleases in the match, then we need
            // to fix this to -0, the lowest possible prerelease value
            pr = options.includePrerelease ? '-0' : '';
            if (xM) {
                if (gtlt === '>' || gtlt === '<') {
                    // nothing is allowed
                    ret = '<0.0.0-0';
                } else {
                    // nothing is forbidden
                    ret = '*';
                }
            } else if (gtlt && anyX) {
                // we know patch is an x, because we have any x at all.
                // replace X with 0
                if (xm) {
                    m = 0;
                }
                p = 0;
                if (gtlt === '>') {
                    // >1 => >=2.0.0
                    // >1.2 => >=1.3.0
                    gtlt = '>=';
                    if (xm) {
                        M = +M + 1;
                        m = 0;
                        p = 0;
                    } else {
                        m = +m + 1;
                        p = 0;
                    }
                } else if (gtlt === '<=') {
                    // <=0.7.x is actually <0.8.0, since any 0.7.x should
                    // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                    gtlt = '<';
                    if (xm) {
                        M = +M + 1;
                    } else {
                        m = +m + 1;
                    }
                }
                if (gtlt === '<') {
                    pr = '-0';
                }
                ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
            } else if (xm) {
                ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
            } else if (xp) {
                ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
            }
            debug('xRange return', ret);
            return ret;
        });
    };
    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    var replaceStars = function(comp, options) {
        debug('replaceStars', comp, options);
        // Looseness is ignored here.  star is always as loose as it gets!
        return comp.trim().replace(re[t.STAR], '');
    };
    var replaceGTE0 = function(comp, options) {
        debug('replaceGTE0', comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
    };
    // This function is passed to string.replace(re[t.HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0-0
    // TODO build?
    var hyphenReplace = function(incPr) {
        return function($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) {
            if (isX(fM)) {
                from = '';
            } else if (isX(fm)) {
                from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
            } else if (isX(fp)) {
                from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
            } else if (fpr) {
                from = ">=".concat(from);
            } else {
                from = ">=".concat(from).concat(incPr ? '-0' : '');
            }
            if (isX(tM)) {
                to = '';
            } else if (isX(tm)) {
                to = "<".concat(+tM + 1, ".0.0-0");
            } else if (isX(tp)) {
                to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
            } else if (tpr) {
                to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
            } else if (incPr) {
                to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
            } else {
                to = "<=".concat(to);
            }
            return "".concat(from, " ").concat(to).trim();
        };
    };
    var testSet = function(set, version, options) {
        for(var i = 0; i < set.length; i++){
            if (!set[i].test(version)) {
                return false;
            }
        }
        if (version.prerelease.length && !options.includePrerelease) {
            // Find the set of versions that are allowed to have prereleases
            // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
            // That should allow `1.2.3-pr.2` to pass.
            // However, `1.2.4-alpha.notready` should NOT be allowed,
            // even though it's within the range set by the comparators.
            for(var i1 = 0; i1 < set.length; i1++){
                debug(set[i1].semver);
                if (set[i1].semver === Comparator.ANY) {
                    continue;
                }
                if (set[i1].semver.prerelease.length > 0) {
                    var allowed = set[i1].semver;
                    if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                        return true;
                    }
                }
            }
            // Version has a -pre, but it's not one of the ones we like.
            return false;
        }
        return true;
    };
    return range$1;
}

function _class_call_check$z(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$9(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$9(Constructor, protoProps, staticProps) {
    _defineProperties$9(Constructor, staticProps);
    return Constructor;
}
function _instanceof$o(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var comparator$1;
var hasRequiredComparator$1;
function requireComparator$1() {
    if (hasRequiredComparator$1) return comparator$1;
    hasRequiredComparator$1 = 1;
    var ANY = Symbol('SemVer ANY');
    // hoisted class for cyclic dependency
    var Comparator = /*#__PURE__*/ function() {
        function Comparator(comp, options) {
            _class_call_check$z(this, Comparator);
            options = parseOptions(options);
            if (_instanceof$o(comp, Comparator)) {
                if (comp.loose === !!options.loose) {
                    return comp;
                } else {
                    comp = comp.value;
                }
            }
            comp = comp.trim().split(/\s+/).join(' ');
            debug('comparator', comp, options);
            this.options = options;
            this.loose = !!options.loose;
            this.parse(comp);
            if (this.semver === ANY) {
                this.value = '';
            } else {
                this.value = this.operator + this.semver.version;
            }
            debug('comp', this);
        }
        var _proto = Comparator.prototype;
        _proto.parse = function parse(comp) {
            var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
            var m = comp.match(r);
            if (!m) {
                throw new TypeError("Invalid comparator: ".concat(comp));
            }
            this.operator = m[1] !== undefined ? m[1] : '';
            if (this.operator === '=') {
                this.operator = '';
            }
            // if it literally is just '>' or '' then allow anything.
            if (!m[2]) {
                this.semver = ANY;
            } else {
                this.semver = new SemVer(m[2], this.options.loose);
            }
        };
        _proto.toString = function toString() {
            return this.value;
        };
        _proto.test = function test(version) {
            debug('Comparator.test', version, this.options.loose);
            if (this.semver === ANY || version === ANY) {
                return true;
            }
            if (typeof version === 'string') {
                try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
            }
            return cmp(version, this.operator, this.semver, this.options);
        };
        _proto.intersects = function intersects(comp, options) {
            if (!_instanceof$o(comp, Comparator)) {
                throw new TypeError('a Comparator is required');
            }
            if (this.operator === '') {
                if (this.value === '') {
                    return true;
                }
                return new Range(comp.value, options).test(this.value);
            } else if (comp.operator === '') {
                if (comp.value === '') {
                    return true;
                }
                return new Range(this.value, options).test(comp.semver);
            }
            options = parseOptions(options);
            // Special cases where nothing can possibly be lower
            if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
                return false;
            }
            if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
                return false;
            }
            // Same direction increasing (> or >=)
            if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
                return true;
            }
            // Same direction decreasing (< or <=)
            if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
                return true;
            }
            // same SemVer and both sides are inclusive (<= or >=)
            if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
                return true;
            }
            // opposite directions less than
            if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
                return true;
            }
            // opposite directions greater than
            if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
                return true;
            }
            return false;
        };
        _create_class$9(Comparator, null, [
            {
                key: "ANY",
                get: function get() {
                    return ANY;
                }
            }
        ]);
        return Comparator;
    }();
    comparator$1 = Comparator;
    var parseOptions = requireParseOptions$1();
    var _require$$1 = requireRe$1(), re = _require$$1.safeRe, t = _require$$1.t;
    var cmp = requireCmp$1();
    var debug = requireDebug$1();
    var SemVer = requireSemver$3();
    var Range = requireRange$1();
    return comparator$1;
}

var satisfies_1$1;
var hasRequiredSatisfies$1;
function requireSatisfies$1() {
    if (hasRequiredSatisfies$1) return satisfies_1$1;
    hasRequiredSatisfies$1 = 1;
    var Range = requireRange$1();
    var satisfies = function(version, range, options) {
        try {
            range = new Range(range, options);
        } catch (er) {
            return false;
        }
        return range.test(version);
    };
    satisfies_1$1 = satisfies;
    return satisfies_1$1;
}

var toComparators_1$1;
var hasRequiredToComparators$1;
function requireToComparators$1() {
    if (hasRequiredToComparators$1) return toComparators_1$1;
    hasRequiredToComparators$1 = 1;
    var Range = requireRange$1();
    // Mostly just for testing and legacy API reasons
    var toComparators = function(range, options) {
        return new Range(range, options).set.map(function(comp) {
            return comp.map(function(c) {
                return c.value;
            }).join(' ').trim().split(' ');
        });
    };
    toComparators_1$1 = toComparators;
    return toComparators_1$1;
}

var maxSatisfying_1$1;
var hasRequiredMaxSatisfying$1;
function requireMaxSatisfying$1() {
    if (hasRequiredMaxSatisfying$1) return maxSatisfying_1$1;
    hasRequiredMaxSatisfying$1 = 1;
    var SemVer = requireSemver$3();
    var Range = requireRange$1();
    var maxSatisfying = function(versions, range, options) {
        var max = null;
        var maxSV = null;
        var rangeObj = null;
        try {
            rangeObj = new Range(range, options);
        } catch (er) {
            return null;
        }
        versions.forEach(function(v) {
            if (rangeObj.test(v)) {
                // satisfies(v, range, options)
                if (!max || maxSV.compare(v) === -1) {
                    // compare(max, v, true)
                    max = v;
                    maxSV = new SemVer(max, options);
                }
            }
        });
        return max;
    };
    maxSatisfying_1$1 = maxSatisfying;
    return maxSatisfying_1$1;
}

var minSatisfying_1$1;
var hasRequiredMinSatisfying$1;
function requireMinSatisfying$1() {
    if (hasRequiredMinSatisfying$1) return minSatisfying_1$1;
    hasRequiredMinSatisfying$1 = 1;
    var SemVer = requireSemver$3();
    var Range = requireRange$1();
    var minSatisfying = function(versions, range, options) {
        var min = null;
        var minSV = null;
        var rangeObj = null;
        try {
            rangeObj = new Range(range, options);
        } catch (er) {
            return null;
        }
        versions.forEach(function(v) {
            if (rangeObj.test(v)) {
                // satisfies(v, range, options)
                if (!min || minSV.compare(v) === 1) {
                    // compare(min, v, true)
                    min = v;
                    minSV = new SemVer(min, options);
                }
            }
        });
        return min;
    };
    minSatisfying_1$1 = minSatisfying;
    return minSatisfying_1$1;
}

var minVersion_1$1;
var hasRequiredMinVersion$1;
function requireMinVersion$1() {
    if (hasRequiredMinVersion$1) return minVersion_1$1;
    hasRequiredMinVersion$1 = 1;
    var SemVer = requireSemver$3();
    var Range = requireRange$1();
    var gt = requireGt$1();
    var minVersion = function(range, loose) {
        var _loop = function(i) {
            var comparators = range.set[i];
            var setMin = null;
            comparators.forEach(function(comparator) {
                // Clone to avoid manipulating the comparator's semver object.
                var compver = new SemVer(comparator.semver.version);
                switch(comparator.operator){
                    case '>':
                        if (compver.prerelease.length === 0) {
                            compver.patch++;
                        } else {
                            compver.prerelease.push(0);
                        }
                        compver.raw = compver.format();
                    /* fallthrough */ case '':
                    case '>=':
                        if (!setMin || gt(compver, setMin)) {
                            setMin = compver;
                        }
                        break;
                    case '<':
                    case '<=':
                        break;
                    /* istanbul ignore next */ default:
                        throw new Error("Unexpected operation: ".concat(comparator.operator));
                }
            });
            if (setMin && (!minver || gt(minver, setMin))) {
                minver = setMin;
            }
        };
        range = new Range(range, loose);
        var minver = new SemVer('0.0.0');
        if (range.test(minver)) {
            return minver;
        }
        minver = new SemVer('0.0.0-0');
        if (range.test(minver)) {
            return minver;
        }
        minver = null;
        for(var i = 0; i < range.set.length; ++i)_loop(i);
        if (minver && range.test(minver)) {
            return minver;
        }
        return null;
    };
    minVersion_1$1 = minVersion;
    return minVersion_1$1;
}

var valid$1;
var hasRequiredValid$2;
function requireValid$2() {
    if (hasRequiredValid$2) return valid$1;
    hasRequiredValid$2 = 1;
    var Range = requireRange$1();
    var validRange = function(range, options) {
        try {
            // Return '*' instead of '' so that truthiness works.
            // This will throw if it's invalid anyway
            return new Range(range, options).range || '*';
        } catch (er) {
            return null;
        }
    };
    valid$1 = validRange;
    return valid$1;
}

function _type_of$H(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var outside_1$1;
var hasRequiredOutside$1;
function requireOutside$1() {
    if (hasRequiredOutside$1) return outside_1$1;
    hasRequiredOutside$1 = 1;
    var SemVer = requireSemver$3();
    var Comparator = requireComparator$1();
    var ANY = Comparator.ANY;
    var Range = requireRange$1();
    var satisfies = requireSatisfies$1();
    var gt = requireGt$1();
    var lt = requireLt$1();
    var lte = requireLte$1();
    var gte = requireGte$1();
    var outside = function(version, range, hilo, options) {
        var _loop = function(i) {
            var comparators = range.set[i];
            var high = null;
            var low = null;
            comparators.forEach(function(comparator) {
                if (comparator.semver === ANY) {
                    comparator = new Comparator('>=0.0.0');
                }
                high = high || comparator;
                low = low || comparator;
                if (gtfn(comparator.semver, high.semver, options)) {
                    high = comparator;
                } else if (ltfn(comparator.semver, low.semver, options)) {
                    low = comparator;
                }
            });
            // If the edge version comparator has a operator then our version
            // isn't outside it
            if (high.operator === comp || high.operator === ecomp) {
                return {
                    v: false
                };
            }
            // If the lowest version comparator has an operator and our version
            // is less than it then it isn't higher than the range
            if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
                return {
                    v: false
                };
            } else if (low.operator === ecomp && ltfn(version, low.semver)) {
                return {
                    v: false
                };
            }
        };
        version = new SemVer(version, options);
        range = new Range(range, options);
        var gtfn, ltefn, ltfn, comp, ecomp;
        switch(hilo){
            case '>':
                gtfn = gt;
                ltefn = lte;
                ltfn = lt;
                comp = '>';
                ecomp = '>=';
                break;
            case '<':
                gtfn = lt;
                ltefn = gte;
                ltfn = gt;
                comp = '<';
                ecomp = '<=';
                break;
            default:
                throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        // If it satisfies the range it is not outside
        if (satisfies(version, range, options)) {
            return false;
        }
        // From now on, variable terms are as if we're in "gtr" mode.
        // but note that everything is flipped for the "ltr" function.
        for(var i = 0; i < range.set.length; ++i){
            var _ret = _loop(i);
            if (_type_of$H(_ret) === "object") return _ret.v;
        }
        return true;
    };
    outside_1$1 = outside;
    return outside_1$1;
}

var gtr_1$1;
var hasRequiredGtr$1;
function requireGtr$1() {
    if (hasRequiredGtr$1) return gtr_1$1;
    hasRequiredGtr$1 = 1;
    // Determine if version is greater than all the versions possible in the range.
    var outside = requireOutside$1();
    var gtr = function(version, range, options) {
        return outside(version, range, '>', options);
    };
    gtr_1$1 = gtr;
    return gtr_1$1;
}

var ltr_1$1;
var hasRequiredLtr$1;
function requireLtr$1() {
    if (hasRequiredLtr$1) return ltr_1$1;
    hasRequiredLtr$1 = 1;
    var outside = requireOutside$1();
    // Determine if version is less than all the versions possible in the range
    var ltr = function(version, range, options) {
        return outside(version, range, '<', options);
    };
    ltr_1$1 = ltr;
    return ltr_1$1;
}

var intersects_1$1;
var hasRequiredIntersects$1;
function requireIntersects$1() {
    if (hasRequiredIntersects$1) return intersects_1$1;
    hasRequiredIntersects$1 = 1;
    var Range = requireRange$1();
    var intersects = function(r1, r2, options) {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2, options);
    };
    intersects_1$1 = intersects;
    return intersects_1$1;
}

function _array_like_to_array$m(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$f(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$d(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$f() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$d(arr, i) {
    return _array_with_holes$f(arr) || _iterable_to_array_limit$d(arr, i) || _unsupported_iterable_to_array$m(arr, i) || _non_iterable_rest$f();
}
function _unsupported_iterable_to_array$m(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$m(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$m(o, minLen);
}
var simplify$1;
var hasRequiredSimplify$1;
function requireSimplify$1() {
    if (hasRequiredSimplify$1) return simplify$1;
    hasRequiredSimplify$1 = 1;
    // given a set of versions and a range, create a "simplified" range
    // that includes the same versions that the original range does
    // If the original range is shorter than the simplified one, return that.
    var satisfies = requireSatisfies$1();
    var compare = requireCompare$1();
    simplify$1 = function(versions, range, options) {
        var set = [];
        var first = null;
        var prev = null;
        var v = versions.sort(function(a, b) {
            return compare(a, b, options);
        });
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = v[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var version = _step.value;
                var included = satisfies(version, range, options);
                if (included) {
                    prev = version;
                    if (!first) {
                        first = version;
                    }
                } else {
                    if (prev) {
                        set.push([
                            first,
                            prev
                        ]);
                    }
                    prev = null;
                    first = null;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (first) {
            set.push([
                first,
                null
            ]);
        }
        var ranges = [];
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = set[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var _step_value = _sliced_to_array$d(_step1.value, 2), min = _step_value[0], max = _step_value[1];
                if (min === max) {
                    ranges.push(min);
                } else if (!max && min === v[0]) {
                    ranges.push('*');
                } else if (!max) {
                    ranges.push(">=".concat(min));
                } else if (min === v[0]) {
                    ranges.push("<=".concat(max));
                } else {
                    ranges.push("".concat(min, " - ").concat(max));
                }
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        var simplified = ranges.join(' || ');
        var original = typeof range.raw === 'string' ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
    };
    return simplify$1;
}

var subset_1$1;
var hasRequiredSubset$1;
function requireSubset$1() {
    if (hasRequiredSubset$1) return subset_1$1;
    hasRequiredSubset$1 = 1;
    var Range = requireRange$1();
    var Comparator = requireComparator$1();
    var ANY = Comparator.ANY;
    var satisfies = requireSatisfies$1();
    var compare = requireCompare$1();
    // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
    // - Every simple range `r1, r2, ...` is a null set, OR
    // - Every simple range `r1, r2, ...` which is not a null set is a subset of
    //   some `R1, R2, ...`
    //
    // Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
    // - If c is only the ANY comparator
    //   - If C is only the ANY comparator, return true
    //   - Else if in prerelease mode, return false
    //   - else replace c with `[>=0.0.0]`
    // - If C is only the ANY comparator
    //   - if in prerelease mode, return true
    //   - else replace C with `[>=0.0.0]`
    // - Let EQ be the set of = comparators in c
    // - If EQ is more than one, return true (null set)
    // - Let GT be the highest > or >= comparator in c
    // - Let LT be the lowest < or <= comparator in c
    // - If GT and LT, and GT.semver > LT.semver, return true (null set)
    // - If any C is a = range, and GT or LT are set, return false
    // - If EQ
    //   - If GT, and EQ does not satisfy GT, return true (null set)
    //   - If LT, and EQ does not satisfy LT, return true (null set)
    //   - If EQ satisfies every C, return true
    //   - Else return false
    // - If GT
    //   - If GT.semver is lower than any > or >= comp in C, return false
    //   - If GT is >=, and GT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the GT.semver tuple, return false
    // - If LT
    //   - If LT.semver is greater than any < or <= comp in C, return false
    //   - If LT is <=, and LT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the LT.semver tuple, return false
    // - Else return true
    var subset = function(sub, dom) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (sub === dom) {
            return true;
        }
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        var sawNonNull = false;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            OUTER: for(var _iterator = sub.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var simpleSub = _step.value;
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = dom.set[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var simpleDom = _step1.value;
                        var isSub = simpleSubset(simpleSub, simpleDom, options);
                        sawNonNull = sawNonNull || isSub !== null;
                        if (isSub) {
                            continue OUTER;
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                // the null set is a subset of everything, but null simple ranges in
                // a complex range should be ignored.  so if we saw a non-null range,
                // then we know this isn't a subset, but if EVERY simple range was null,
                // then it is a subset.
                if (sawNonNull) {
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return true;
    };
    var minimumVersionWithPreRelease = [
        new Comparator('>=0.0.0-0')
    ];
    var minimumVersion = [
        new Comparator('>=0.0.0')
    ];
    var simpleSubset = function(sub, dom, options) {
        if (sub === dom) {
            return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
            if (dom.length === 1 && dom[0].semver === ANY) {
                return true;
            } else if (options.includePrerelease) {
                sub = minimumVersionWithPreRelease;
            } else {
                sub = minimumVersion;
            }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
            if (options.includePrerelease) {
                return true;
            } else {
                dom = minimumVersion;
            }
        }
        var eqSet = new Set();
        var gt, lt;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = sub[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var c = _step.value;
                if (c.operator === '>' || c.operator === '>=') {
                    gt = higherGT(gt, c, options);
                } else if (c.operator === '<' || c.operator === '<=') {
                    lt = lowerLT(lt, c, options);
                } else {
                    eqSet.add(c.semver);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (eqSet.size > 1) {
            return null;
        }
        var gtltComp;
        if (gt && lt) {
            gtltComp = compare(gt.semver, lt.semver, options);
            if (gtltComp > 0) {
                return null;
            } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
                return null;
            }
        }
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            // will iterate one or zero times
            for(var _iterator1 = eqSet[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var eq = _step1.value;
                if (gt && !satisfies(eq, String(gt), options)) {
                    return null;
                }
                if (lt && !satisfies(eq, String(lt), options)) {
                    return null;
                }
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                try {
                    for(var _iterator2 = dom[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                        var c1 = _step2.value;
                        if (!satisfies(eq, String(c1), options)) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                            _iterator2.return();
                        }
                    } finally{
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
                return true;
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        var higher, lower;
        var hasDomLT, hasDomGT;
        // if the subset has a prerelease, we need a comparator in the superset
        // with the same tuple and a prerelease, or it's not a subset
        var needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        var needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        // exception: <1.2.3-0 is the same as <1.2.3
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
            needDomLTPre = false;
        }
        var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
        try {
            for(var _iterator3 = dom[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                var c2 = _step3.value;
                hasDomGT = hasDomGT || c2.operator === '>' || c2.operator === '>=';
                hasDomLT = hasDomLT || c2.operator === '<' || c2.operator === '<=';
                if (gt) {
                    if (needDomGTPre) {
                        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
                            needDomGTPre = false;
                        }
                    }
                    if (c2.operator === '>' || c2.operator === '>=') {
                        higher = higherGT(gt, c2, options);
                        if (higher === c2 && higher !== gt) {
                            return false;
                        }
                    } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c2), options)) {
                        return false;
                    }
                }
                if (lt) {
                    if (needDomLTPre) {
                        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
                            needDomLTPre = false;
                        }
                    }
                    if (c2.operator === '<' || c2.operator === '<=') {
                        lower = lowerLT(lt, c2, options);
                        if (lower === c2 && lower !== lt) {
                            return false;
                        }
                    } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c2), options)) {
                        return false;
                    }
                }
                if (!c2.operator && (lt || gt) && gtltComp !== 0) {
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                    _iterator3.return();
                }
            } finally{
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }
        // if there was a < or >, and nothing in the dom, then must be false
        // UNLESS it was limited by another range in the other direction.
        // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
            return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
            return false;
        }
        // we needed a prerelease range in a specific tuple, but didn't get one
        // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
        // because it includes prereleases in the 1.2.3 tuple
        if (needDomGTPre || needDomLTPre) {
            return false;
        }
        return true;
    };
    // >=1.2.3 is lower than >1.2.3
    var higherGT = function(a, b, options) {
        if (!a) {
            return b;
        }
        var comp = compare(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
    };
    // <=1.2.3 is higher than <1.2.3
    var lowerLT = function(a, b, options) {
        if (!a) {
            return b;
        }
        var comp = compare(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
    };
    subset_1$1 = subset;
    return subset_1$1;
}

var semver$3;
var hasRequiredSemver$2;
function requireSemver$2() {
    if (hasRequiredSemver$2) return semver$3;
    hasRequiredSemver$2 = 1;
    // just pre-load all the stuff that index.js lazily exports
    var internalRe = requireRe$1();
    var constants = requireConstants$1();
    var SemVer = requireSemver$3();
    var identifiers = requireIdentifiers$1();
    var parse = requireParse$1();
    var valid = requireValid$3();
    var clean = requireClean$1();
    var inc = requireInc$1();
    var diff = requireDiff$1();
    var major = requireMajor$1();
    var minor = requireMinor$1();
    var patch = requirePatch$1();
    var prerelease = requirePrerelease$1();
    var compare = requireCompare$1();
    var rcompare = requireRcompare$1();
    var compareLoose = requireCompareLoose$1();
    var compareBuild = requireCompareBuild$1();
    var sort = requireSort$1();
    var rsort = requireRsort$1();
    var gt = requireGt$1();
    var lt = requireLt$1();
    var eq = requireEq$1();
    var neq = requireNeq$1();
    var gte = requireGte$1();
    var lte = requireLte$1();
    var cmp = requireCmp$1();
    var coerce = requireCoerce$1();
    var Comparator = requireComparator$1();
    var Range = requireRange$1();
    var satisfies = requireSatisfies$1();
    var toComparators = requireToComparators$1();
    var maxSatisfying = requireMaxSatisfying$1();
    var minSatisfying = requireMinSatisfying$1();
    var minVersion = requireMinVersion$1();
    var validRange = requireValid$2();
    var outside = requireOutside$1();
    var gtr = requireGtr$1();
    var ltr = requireLtr$1();
    var intersects = requireIntersects$1();
    var simplifyRange = requireSimplify$1();
    var subset = requireSubset$1();
    semver$3 = {
        parse: parse,
        valid: valid,
        clean: clean,
        inc: inc,
        diff: diff,
        major: major,
        minor: minor,
        patch: patch,
        prerelease: prerelease,
        compare: compare,
        rcompare: rcompare,
        compareLoose: compareLoose,
        compareBuild: compareBuild,
        sort: sort,
        rsort: rsort,
        gt: gt,
        lt: lt,
        eq: eq,
        neq: neq,
        gte: gte,
        lte: lte,
        cmp: cmp,
        coerce: coerce,
        Comparator: Comparator,
        Range: Range,
        satisfies: satisfies,
        toComparators: toComparators,
        maxSatisfying: maxSatisfying,
        minSatisfying: minSatisfying,
        minVersion: minVersion,
        validRange: validRange,
        outside: outside,
        gtr: gtr,
        ltr: ltr,
        intersects: intersects,
        simplifyRange: simplifyRange,
        subset: subset,
        SemVer: SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: constants.RELEASE_TYPES,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
    return semver$3;
}

var lib$1;
var hasRequiredLib$1;
function requireLib$1() {
    if (hasRequiredLib$1) return lib$1;
    hasRequiredLib$1 = 1;
    var builtins = require$$0$3.builtinModules;
    var scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$');
    var blacklist = [
        'node_modules',
        'favicon.ico'
    ];
    function validate(name) {
        var warnings = [];
        var errors = [];
        if (name === null) {
            errors.push('name cannot be null');
            return done(warnings, errors);
        }
        if (name === undefined) {
            errors.push('name cannot be undefined');
            return done(warnings, errors);
        }
        if (typeof name !== 'string') {
            errors.push('name must be a string');
            return done(warnings, errors);
        }
        if (!name.length) {
            errors.push('name length must be greater than zero');
        }
        if (name.match(/^\./)) {
            errors.push('name cannot start with a period');
        }
        if (name.match(/^_/)) {
            errors.push('name cannot start with an underscore');
        }
        if (name.trim() !== name) {
            errors.push('name cannot contain leading or trailing spaces');
        }
        // No funny business
        blacklist.forEach(function(blacklistedName) {
            if (name.toLowerCase() === blacklistedName) {
                errors.push(blacklistedName + ' is a blacklisted name');
            }
        });
        // Generate warnings for stuff that used to be allowed
        // core module names like http, events, util, etc
        if (builtins.includes(name.toLowerCase())) {
            warnings.push(name + ' is a core module name');
        }
        if (name.length > 214) {
            warnings.push('name can no longer contain more than 214 characters');
        }
        // mIxeD CaSe nAMEs
        if (name.toLowerCase() !== name) {
            warnings.push('name can no longer contain capital letters');
        }
        if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
            warnings.push('name can no longer contain special characters ("~\'!()*")');
        }
        if (encodeURIComponent(name) !== name) {
            // Maybe it's a scoped package name, like @user/package
            var nameMatch = name.match(scopedPackagePattern);
            if (nameMatch) {
                var user = nameMatch[1];
                var pkg = nameMatch[2];
                if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
                    return done(warnings, errors);
                }
            }
            errors.push('name can only contain URL-friendly characters');
        }
        return done(warnings, errors);
    }
    var done = function done(warnings, errors) {
        var result = {
            validForNewPackages: errors.length === 0 && warnings.length === 0,
            validForOldPackages: errors.length === 0,
            warnings: warnings,
            errors: errors
        };
        if (!result.warnings.length) {
            delete result.warnings;
        }
        if (!result.errors.length) {
            delete result.errors;
        }
        return result;
    };
    lib$1 = validate;
    return lib$1;
}

function _array_like_to_array$l(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$8(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$l(arr);
}
function _iterable_to_array$a(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$8() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array$8(arr) {
    return _array_without_holes$8(arr) || _iterable_to_array$a(arr) || _unsupported_iterable_to_array$l(arr) || _non_iterable_spread$8();
}
function _unsupported_iterable_to_array$l(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$l(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$l(o, minLen);
}
var lib;
var hasRequiredLib;
function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    var META = Symbol('proc-log.meta');
    lib = {
        META: META,
        output: {
            LEVELS: [
                'standard',
                'error',
                'buffer',
                'flush'
            ],
            KEYS: {
                standard: 'standard',
                error: 'error',
                buffer: 'buffer',
                flush: 'flush'
            },
            standard: function standard() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'output',
                    'standard'
                ].concat(_to_consumable_array$8(args)));
            },
            error: function error() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'output',
                    'error'
                ].concat(_to_consumable_array$8(args)));
            },
            buffer: function buffer() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'output',
                    'buffer'
                ].concat(_to_consumable_array$8(args)));
            },
            flush: function flush() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'output',
                    'flush'
                ].concat(_to_consumable_array$8(args)));
            }
        },
        log: {
            LEVELS: [
                'notice',
                'error',
                'warn',
                'info',
                'verbose',
                'http',
                'silly',
                'timing',
                'pause',
                'resume'
            ],
            KEYS: {
                notice: 'notice',
                error: 'error',
                warn: 'warn',
                info: 'info',
                verbose: 'verbose',
                http: 'http',
                silly: 'silly',
                timing: 'timing',
                pause: 'pause',
                resume: 'resume'
            },
            error: function error() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'error'
                ].concat(_to_consumable_array$8(args)));
            },
            notice: function notice() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'notice'
                ].concat(_to_consumable_array$8(args)));
            },
            warn: function warn() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'warn'
                ].concat(_to_consumable_array$8(args)));
            },
            info: function info() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'info'
                ].concat(_to_consumable_array$8(args)));
            },
            verbose: function verbose() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'verbose'
                ].concat(_to_consumable_array$8(args)));
            },
            http: function http() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'http'
                ].concat(_to_consumable_array$8(args)));
            },
            silly: function silly() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'silly'
                ].concat(_to_consumable_array$8(args)));
            },
            timing: function timing() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                return (_process = process).emit.apply(_process, [
                    'log',
                    'timing'
                ].concat(_to_consumable_array$8(args)));
            },
            pause: function pause() {
                return process.emit('log', 'pause');
            },
            resume: function resume() {
                return process.emit('log', 'resume');
            }
        },
        time: {
            LEVELS: [
                'start',
                'end'
            ],
            KEYS: {
                start: 'start',
                end: 'end'
            },
            start: function start(name, fn) {
                process.emit('time', 'start', name);
                function end() {
                    return process.emit('time', 'end', name);
                }
                if (typeof fn === 'function') {
                    var res = fn();
                    if (res && res.finally) {
                        return res.finally(end);
                    }
                    end();
                    return res;
                }
                return end;
            },
            end: function end(name) {
                return process.emit('time', 'end', name);
            }
        },
        input: {
            LEVELS: [
                'start',
                'end',
                'read'
            ],
            KEYS: {
                start: 'start',
                end: 'end',
                read: 'read'
            },
            start: function start(fn) {
                process.emit('input', 'start');
                function end() {
                    return process.emit('input', 'end');
                }
                if (typeof fn === 'function') {
                    var res = fn();
                    if (res && res.finally) {
                        return res.finally(end);
                    }
                    end();
                    return res;
                }
                return end;
            },
            end: function end() {
                return process.emit('input', 'end');
            },
            read: function read() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _process;
                var resolve, reject;
                var promise = new Promise(function(_resolve, _reject) {
                    resolve = _resolve;
                    reject = _reject;
                });
                (_process = process).emit.apply(_process, [
                    'input',
                    'read',
                    resolve,
                    reject
                ].concat(_to_consumable_array$8(args)));
                return promise;
            }
        }
    };
    return lib;
}

function _array_like_to_array$k(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$e(arr) {
    if (Array.isArray(arr)) return arr;
}
function _instanceof$n(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array_limit$c(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$e() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$c(arr, i) {
    return _array_with_holes$e(arr) || _iterable_to_array_limit$c(arr, i) || _unsupported_iterable_to_array$k(arr, i) || _non_iterable_rest$e();
}
function _type_of$G(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$k(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$k(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$k(o, minLen);
}
var hasRequiredNpa;
function requireNpa() {
    if (hasRequiredNpa) return npa$1.exports;
    hasRequiredNpa = 1;
    npa$1.exports = npa;
    npa$1.exports.resolve = resolve;
    npa$1.exports.toPurl = toPurl;
    npa$1.exports.Result = Result;
    var URL = require$$0$2.URL;
    var HostedGit = requireLib$2();
    var semver = requireSemver$2();
    var path = commonjsGlobal.FAKE_WINDOWS ? require$$3.win32 : require$$3;
    var validatePackageName = requireLib$1();
    var homedir = require$$5.homedir;
    var log = requireLib().log;
    var isWindows = process.platform === 'win32' || commonjsGlobal.FAKE_WINDOWS;
    var hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
    var isURL = /^(?:git[+])?[a-z]+:/i;
    var isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i;
    var isFilename = /[.](?:tgz|tar.gz|tar)$/i;
    function npa(arg, where) {
        var name;
        var spec;
        if ((typeof arg === "undefined" ? "undefined" : _type_of$G(arg)) === 'object') {
            if (_instanceof$n(arg, Result) && (!where || where === arg.where)) {
                return arg;
            } else if (arg.name && arg.rawSpec) {
                return npa.resolve(arg.name, arg.rawSpec, where || arg.where);
            } else {
                return npa(arg.raw, where || arg.where);
            }
        }
        var nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');
        var namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
        if (isURL.test(arg)) {
            spec = arg;
        } else if (isGit.test(arg)) {
            spec = "git+ssh://".concat(arg);
        } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {
            spec = arg;
        } else if (nameEndsAt > 0) {
            name = namePart;
            spec = arg.slice(nameEndsAt + 1) || '*';
        } else {
            var valid = validatePackageName(arg);
            if (valid.validForOldPackages) {
                name = arg;
                spec = '*';
            } else {
                spec = arg;
            }
        }
        return resolve(name, spec, where, arg);
    }
    var isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
    function resolve(name, spec, where, arg) {
        var res = new Result({
            raw: arg,
            name: name,
            rawSpec: spec,
            fromArgument: arg != null
        });
        if (name) {
            res.setName(name);
        }
        if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {
            return fromFile(res, where);
        } else if (spec && /^npm:/i.test(spec)) {
            return fromAlias(res, where);
        }
        var hosted = HostedGit.fromUrl(spec, {
            noGitPlus: true,
            noCommittish: true
        });
        if (hosted) {
            return fromHostedGit(res, hosted);
        } else if (spec && isURL.test(spec)) {
            return fromURL(res);
        } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {
            return fromFile(res, where);
        } else {
            return fromRegistry(res);
        }
    }
    var defaultRegistry = 'https://registry.npmjs.org';
    function toPurl(arg) {
        var reg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRegistry;
        var res = npa(arg);
        if (res.type !== 'version') {
            throw invalidPurlType(res.type, res.raw);
        }
        // URI-encode leading @ of scoped packages
        var purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec;
        if (reg !== defaultRegistry) {
            purl += '?repository_url=' + reg;
        }
        return purl;
    }
    function invalidPackageName(name, valid, raw) {
        // eslint-disable-next-line max-len
        var err = new Error('Invalid package name "'.concat(name, '" of package "').concat(raw, '": ').concat(valid.errors.join('; '), "."));
        err.code = 'EINVALIDPACKAGENAME';
        return err;
    }
    function invalidTagName(name, raw) {
        // eslint-disable-next-line max-len
        var err = new Error('Invalid tag name "'.concat(name, '" of package "').concat(raw, '": Tags may not have any characters that encodeURIComponent encodes.'));
        err.code = 'EINVALIDTAGNAME';
        return err;
    }
    function invalidPurlType(type, raw) {
        // eslint-disable-next-line max-len
        var err = new Error('Invalid type "'.concat(type, '" of package "').concat(raw, '": Purl can only be generated for "version" types.'));
        err.code = 'EINVALIDPURLTYPE';
        return err;
    }
    function Result(opts) {
        this.type = opts.type;
        this.registry = opts.registry;
        this.where = opts.where;
        if (opts.raw == null) {
            this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;
        } else {
            this.raw = opts.raw;
        }
        this.name = undefined;
        this.escapedName = undefined;
        this.scope = undefined;
        this.rawSpec = opts.rawSpec || '';
        this.saveSpec = opts.saveSpec;
        this.fetchSpec = opts.fetchSpec;
        if (opts.name) {
            this.setName(opts.name);
        }
        this.gitRange = opts.gitRange;
        this.gitCommittish = opts.gitCommittish;
        this.gitSubdir = opts.gitSubdir;
        this.hosted = opts.hosted;
    }
    Result.prototype.setName = function(name) {
        var valid = validatePackageName(name);
        if (!valid.validForOldPackages) {
            throw invalidPackageName(name, valid, this.raw);
        }
        this.name = name;
        this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined;
        // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar
        this.escapedName = name.replace('/', '%2f');
        return this;
    };
    Result.prototype.toString = function() {
        var full = [];
        if (this.name != null && this.name !== '') {
            full.push(this.name);
        }
        var spec = this.saveSpec || this.fetchSpec || this.rawSpec;
        if (spec != null && spec !== '') {
            full.push(spec);
        }
        return full.length ? full.join('@') : this.raw;
    };
    Result.prototype.toJSON = function() {
        var result = Object.assign({}, this);
        delete result.hosted;
        return result;
    };
    // sets res.gitCommittish, res.gitRange, and res.gitSubdir
    function setGitAttrs(res, committish) {
        if (!committish) {
            res.gitCommittish = null;
            return;
        }
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            // for each :: separated item:
            for(var _iterator = committish.split('::')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var part = _step.value;
                // if the item has no : the n it is a commit-ish
                if (!part.includes(':')) {
                    if (res.gitRange) {
                        throw new Error('cannot override existing semver range with a committish');
                    }
                    if (res.gitCommittish) {
                        throw new Error('cannot override existing committish with a second committish');
                    }
                    res.gitCommittish = part;
                    continue;
                }
                // split on name:value
                var _part_split = _sliced_to_array$c(part.split(':'), 2), name = _part_split[0], value = _part_split[1];
                // if name is semver do semver lookup of ref or tag
                if (name === 'semver') {
                    if (res.gitCommittish) {
                        throw new Error('cannot override existing committish with a semver range');
                    }
                    if (res.gitRange) {
                        throw new Error('cannot override existing semver range with a second semver range');
                    }
                    res.gitRange = decodeURIComponent(value);
                    continue;
                }
                if (name === 'path') {
                    if (res.gitSubdir) {
                        throw new Error('cannot override existing path with a second path');
                    }
                    res.gitSubdir = "/".concat(value);
                    continue;
                }
                log.warn('npm-package-arg', 'ignoring unknown key "'.concat(name, '"'));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    function fromFile(res, where) {
        if (!where) {
            where = process.cwd();
        }
        res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';
        res.where = where;
        // always put the '/' on where when resolving urls, or else
        // file:foo from /path/to/bar goes to /path/to/foo, when we want
        // it to be /path/to/bar/foo
        var specUrl;
        var resolvedUrl;
        var prefix = !/^file:/.test(res.rawSpec) ? 'file:' : '';
        var rawWithPrefix = prefix + res.rawSpec;
        var rawNoPrefix = rawWithPrefix.replace(/^file:/, '');
        try {
            resolvedUrl = new URL(rawWithPrefix, "file://".concat(path.resolve(where), "/"));
            specUrl = new URL(rawWithPrefix);
        } catch (originalError) {
            var er = new Error('Invalid file: URL, must comply with RFC 8089');
            throw Object.assign(er, {
                raw: res.rawSpec,
                spec: res,
                where: where,
                originalError: originalError
            });
        }
        // XXX backwards compatibility lack of compliance with RFC 8089
        if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {
            var rawSpec = res.rawSpec.replace(/^file:\/\//, 'file:///');
            resolvedUrl = new URL(rawSpec, "file://".concat(path.resolve(where), "/"));
            specUrl = new URL(rawSpec);
            rawNoPrefix = rawSpec.replace(/^file:/, '');
        }
        // turn file:/../foo into file:../foo
        // for 1, 2 or 3 leading slashes since we attempted
        // in the previous step to make it a file protocol url with a leading slash
        if (/^\/{1,3}\.\.?(\/|$)/.test(rawNoPrefix)) {
            var rawSpec1 = res.rawSpec.replace(/^file:\/{1,3}/, 'file:');
            resolvedUrl = new URL(rawSpec1, "file://".concat(path.resolve(where), "/"));
            specUrl = new URL(rawSpec1);
            rawNoPrefix = rawSpec1.replace(/^file:/, '');
        }
        // XXX end RFC 8089 violation backwards compatibility section
        // turn /C:/blah into just C:/blah on windows
        var specPath = decodeURIComponent(specUrl.pathname);
        var resolvedPath = decodeURIComponent(resolvedUrl.pathname);
        if (isWindows) {
            specPath = specPath.replace(/^\/+([a-z]:\/)/i, '$1');
            resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, '$1');
        }
        // replace ~ with homedir, but keep the ~ in the saveSpec
        // otherwise, make it relative to where param
        if (/^\/~(\/|$)/.test(specPath)) {
            res.saveSpec = "file:".concat(specPath.substr(1));
            resolvedPath = path.resolve(homedir(), specPath.substr(3));
        } else if (!path.isAbsolute(rawNoPrefix)) {
            res.saveSpec = "file:".concat(path.relative(where, resolvedPath));
        } else {
            res.saveSpec = "file:".concat(path.resolve(resolvedPath));
        }
        res.fetchSpec = path.resolve(where, resolvedPath);
        return res;
    }
    function fromHostedGit(res, hosted) {
        res.type = 'git';
        res.hosted = hosted;
        res.saveSpec = hosted.toString({
            noGitPlus: false,
            noCommittish: false
        });
        res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();
        setGitAttrs(res, hosted.committish);
        return res;
    }
    function unsupportedURLType(protocol, spec) {
        var err = new Error('Unsupported URL Type "'.concat(protocol, '": ').concat(spec));
        err.code = 'EUNSUPPORTEDPROTOCOL';
        return err;
    }
    function fromURL(res) {
        var rawSpec = res.rawSpec;
        res.saveSpec = rawSpec;
        if (rawSpec.startsWith('git+ssh:')) {
            // git ssh specifiers are overloaded to also use scp-style git
            // specifiers, so we have to parse those out and treat them special.
            // They are NOT true URIs, so we can't hand them to URL.
            // This regex looks for things that look like:
            // git+ssh://git@my.custom.git.com:username/project.git#deadbeef
            // ...and various combinations. The username in the beginning is *required*.
            var matched = rawSpec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
            if (matched && !matched[1].match(/:[0-9]+\/?.*$/i)) {
                res.type = 'git';
                setGitAttrs(res, matched[2]);
                res.fetchSpec = matched[1];
                return res;
            }
        } else if (rawSpec.startsWith('git+file://')) {
            // URL can't handle windows paths
            rawSpec = rawSpec.replace(/\\/g, '/');
        }
        var parsedUrl = new URL(rawSpec);
        // check the protocol, and then see if it's git or not
        switch(parsedUrl.protocol){
            case 'git:':
            case 'git+http:':
            case 'git+https:':
            case 'git+rsync:':
            case 'git+ftp:':
            case 'git+file:':
            case 'git+ssh:':
                res.type = 'git';
                setGitAttrs(res, parsedUrl.hash.slice(1));
                if (parsedUrl.protocol === 'git+file:' && /^git\+file:\/\/[a-z]:/i.test(rawSpec)) {
                    // URL can't handle drive letters on windows file paths, the host can't contain a :
                    res.fetchSpec = "git+file://".concat(parsedUrl.host.toLowerCase(), ":").concat(parsedUrl.pathname);
                } else {
                    parsedUrl.hash = '';
                    res.fetchSpec = parsedUrl.toString();
                }
                if (res.fetchSpec.startsWith('git+')) {
                    res.fetchSpec = res.fetchSpec.slice(4);
                }
                break;
            case 'http:':
            case 'https:':
                res.type = 'remote';
                res.fetchSpec = res.saveSpec;
                break;
            default:
                throw unsupportedURLType(parsedUrl.protocol, rawSpec);
        }
        return res;
    }
    function fromAlias(res, where) {
        var subSpec = npa(res.rawSpec.substr(4), where);
        if (subSpec.type === 'alias') {
            throw new Error('nested aliases not supported');
        }
        if (!subSpec.registry) {
            throw new Error('aliases only work for registry deps');
        }
        if (!subSpec.name) {
            throw new Error('aliases must have a name');
        }
        res.subSpec = subSpec;
        res.registry = true;
        res.type = 'alias';
        res.saveSpec = null;
        res.fetchSpec = null;
        return res;
    }
    function fromRegistry(res) {
        res.registry = true;
        var spec = res.rawSpec.trim();
        // no save spec for registry components as we save based on the fetched
        // version, not on the argument so this can't compute that.
        res.saveSpec = null;
        res.fetchSpec = spec;
        var version = semver.valid(spec, true);
        var range = semver.validRange(spec, true);
        if (version) {
            res.type = 'version';
        } else if (range) {
            res.type = 'range';
        } else {
            if (encodeURIComponent(spec) !== spec) {
                throw invalidTagName(spec, res.raw);
            }
            res.type = 'tag';
        }
        return res;
    }
    return npa$1.exports;
}

var npaExports = requireNpa();
var npa = /*@__PURE__*/ getDefaultExportFromCjs(npaExports);

var dist = {};

var composer = {};

var directives = {};

var identity = {};

function _type_of$F(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredIdentity;
function requireIdentity() {
    if (hasRequiredIdentity) return identity;
    hasRequiredIdentity = 1;
    var ALIAS = Symbol.for('yaml.alias');
    var DOC = Symbol.for('yaml.document');
    var MAP = Symbol.for('yaml.map');
    var PAIR = Symbol.for('yaml.pair');
    var SCALAR = Symbol.for('yaml.scalar');
    var SEQ = Symbol.for('yaml.seq');
    var NODE_TYPE = Symbol.for('yaml.node.type');
    var isAlias = function(node) {
        return !!node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object' && node[NODE_TYPE] === ALIAS;
    };
    var isDocument = function(node) {
        return !!node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object' && node[NODE_TYPE] === DOC;
    };
    var isMap = function(node) {
        return !!node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object' && node[NODE_TYPE] === MAP;
    };
    var isPair = function(node) {
        return !!node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object' && node[NODE_TYPE] === PAIR;
    };
    var isScalar = function(node) {
        return !!node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object' && node[NODE_TYPE] === SCALAR;
    };
    var isSeq = function(node) {
        return !!node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object' && node[NODE_TYPE] === SEQ;
    };
    function isCollection(node) {
        if (node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object') switch(node[NODE_TYPE]){
            case MAP:
            case SEQ:
                return true;
        }
        return false;
    }
    function isNode(node) {
        if (node && (typeof node === "undefined" ? "undefined" : _type_of$F(node)) === 'object') switch(node[NODE_TYPE]){
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
        return false;
    }
    var hasAnchor = function(node) {
        return (isScalar(node) || isCollection(node)) && !!node.anchor;
    };
    identity.ALIAS = ALIAS;
    identity.DOC = DOC;
    identity.MAP = MAP;
    identity.NODE_TYPE = NODE_TYPE;
    identity.PAIR = PAIR;
    identity.SCALAR = SCALAR;
    identity.SEQ = SEQ;
    identity.hasAnchor = hasAnchor;
    identity.isAlias = isAlias;
    identity.isCollection = isCollection;
    identity.isDocument = isDocument;
    identity.isMap = isMap;
    identity.isNode = isNode;
    identity.isPair = isPair;
    identity.isScalar = isScalar;
    identity.isSeq = isSeq;
    return identity;
}

var visit = {};

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _type_of$E(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _ts_generator$3(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
var hasRequiredVisit;
function requireVisit() {
    if (hasRequiredVisit) return visit;
    hasRequiredVisit = 1;
    var identity = requireIdentity();
    var BREAK = Symbol('break visit');
    var SKIP = Symbol('skip children');
    var REMOVE = Symbol('remove node');
    /**
	 * Apply a visitor to an AST node or document.
	 *
	 * Walks through the tree (depth-first) starting from `node`, calling a
	 * `visitor` function with three arguments:
	 *   - `key`: For sequence values and map `Pair`, the node's index in the
	 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
	 *     `null` for the root node.
	 *   - `node`: The current node.
	 *   - `path`: The ancestry of the current node.
	 *
	 * The return value of the visitor may be used to control the traversal:
	 *   - `undefined` (default): Do nothing and continue
	 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
	 *     sibling
	 *   - `visit.BREAK`: Terminate traversal completely
	 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
	 *   - `Node`: Replace the current node, then continue by visiting it
	 *   - `number`: While iterating the items of a sequence or map, set the index
	 *     of the next step. This is useful especially if the index of the current
	 *     node has changed.
	 *
	 * If `visitor` is a single function, it will be called with all values
	 * encountered in the tree, including e.g. `null` values. Alternatively,
	 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
	 * `Alias` and `Scalar` node. To define the same visitor function for more than
	 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
	 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
	 * specific defined one will be used for each node.
	 */ function visit$1(node, visitor) {
        var visitor_ = initVisitor(visitor);
        if (identity.isDocument(node)) {
            var cd = visit_(null, node.contents, visitor_, Object.freeze([
                node
            ]));
            if (cd === REMOVE) node.contents = null;
        } else visit_(null, node, visitor_, Object.freeze([]));
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */ visit$1.BREAK = BREAK;
    /** Do not visit the children of the current node */ visit$1.SKIP = SKIP;
    /** Remove the current node */ visit$1.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
        var ctrl = callVisitor(key, node, visitor, path);
        if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
            replaceNode(key, path, ctrl);
            return visit_(key, ctrl, visitor, path);
        }
        if ((typeof ctrl === "undefined" ? "undefined" : _type_of$E(ctrl)) !== 'symbol') {
            if (identity.isCollection(node)) {
                path = Object.freeze(path.concat(node));
                for(var i = 0; i < node.items.length; ++i){
                    var ci = visit_(i, node.items[i], visitor, path);
                    if (typeof ci === 'number') i = ci - 1;
                    else if (ci === BREAK) return BREAK;
                    else if (ci === REMOVE) {
                        node.items.splice(i, 1);
                        i -= 1;
                    }
                }
            } else if (identity.isPair(node)) {
                path = Object.freeze(path.concat(node));
                var ck = visit_('key', node.key, visitor, path);
                if (ck === BREAK) return BREAK;
                else if (ck === REMOVE) node.key = null;
                var cv = visit_('value', node.value, visitor, path);
                if (cv === BREAK) return BREAK;
                else if (cv === REMOVE) node.value = null;
            }
        }
        return ctrl;
    }
    function visitAsync(node, visitor) {
        return _visitAsync.apply(this, arguments);
    }
    function _visitAsync() {
        _visitAsync = /**
	 * Apply an async visitor to an AST node or document.
	 *
	 * Walks through the tree (depth-first) starting from `node`, calling a
	 * `visitor` function with three arguments:
	 *   - `key`: For sequence values and map `Pair`, the node's index in the
	 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
	 *     `null` for the root node.
	 *   - `node`: The current node.
	 *   - `path`: The ancestry of the current node.
	 *
	 * The return value of the visitor may be used to control the traversal:
	 *   - `Promise`: Must resolve to one of the following values
	 *   - `undefined` (default): Do nothing and continue
	 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
	 *     sibling
	 *   - `visit.BREAK`: Terminate traversal completely
	 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
	 *   - `Node`: Replace the current node, then continue by visiting it
	 *   - `number`: While iterating the items of a sequence or map, set the index
	 *     of the next step. This is useful especially if the index of the current
	 *     node has changed.
	 *
	 * If `visitor` is a single function, it will be called with all values
	 * encountered in the tree, including e.g. `null` values. Alternatively,
	 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
	 * `Alias` and `Scalar` node. To define the same visitor function for more than
	 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
	 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
	 * specific defined one will be used for each node.
	 */ _async_to_generator(function(node, visitor) {
            var visitor_, cd;
            return _ts_generator$3(this, function(_state) {
                switch(_state.label){
                    case 0:
                        visitor_ = initVisitor(visitor);
                        if (!identity.isDocument(node)) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            visitAsync_(null, node.contents, visitor_, Object.freeze([
                                node
                            ]))
                        ];
                    case 1:
                        cd = _state.sent();
                        if (cd === REMOVE) node.contents = null;
                        return [
                            3,
                            4
                        ];
                    case 2:
                        return [
                            4,
                            visitAsync_(null, node, visitor_, Object.freeze([]))
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
        return _visitAsync.apply(this, arguments);
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */ visitAsync.BREAK = BREAK;
    /** Do not visit the children of the current node */ visitAsync.SKIP = SKIP;
    /** Remove the current node */ visitAsync.REMOVE = REMOVE;
    function visitAsync_(key, node, visitor, path) {
        return _visitAsync_.apply(this, arguments);
    }
    function _visitAsync_() {
        _visitAsync_ = _async_to_generator(function(key, node, visitor, path) {
            var ctrl, i, ci, ck, cv;
            return _ts_generator$3(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            callVisitor(key, node, visitor, path)
                        ];
                    case 1:
                        ctrl = _state.sent();
                        if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
                            replaceNode(key, path, ctrl);
                            return [
                                2,
                                visitAsync_(key, ctrl, visitor, path)
                            ];
                        }
                        if (!((typeof ctrl === "undefined" ? "undefined" : _type_of$E(ctrl)) !== 'symbol')) return [
                            3,
                            9
                        ];
                        if (!identity.isCollection(node)) return [
                            3,
                            6
                        ];
                        path = Object.freeze(path.concat(node));
                        i = 0;
                        _state.label = 2;
                    case 2:
                        if (!(i < node.items.length)) return [
                            3,
                            5
                        ];
                        return [
                            4,
                            visitAsync_(i, node.items[i], visitor, path)
                        ];
                    case 3:
                        ci = _state.sent();
                        if (typeof ci === 'number') i = ci - 1;
                        else if (ci === BREAK) return [
                            2,
                            BREAK
                        ];
                        else if (ci === REMOVE) {
                            node.items.splice(i, 1);
                            i -= 1;
                        }
                        _state.label = 4;
                    case 4:
                        ++i;
                        return [
                            3,
                            2
                        ];
                    case 5:
                        return [
                            3,
                            9
                        ];
                    case 6:
                        if (!identity.isPair(node)) return [
                            3,
                            9
                        ];
                        path = Object.freeze(path.concat(node));
                        return [
                            4,
                            visitAsync_('key', node.key, visitor, path)
                        ];
                    case 7:
                        ck = _state.sent();
                        if (ck === BREAK) return [
                            2,
                            BREAK
                        ];
                        else if (ck === REMOVE) node.key = null;
                        return [
                            4,
                            visitAsync_('value', node.value, visitor, path)
                        ];
                    case 8:
                        cv = _state.sent();
                        if (cv === BREAK) return [
                            2,
                            BREAK
                        ];
                        else if (cv === REMOVE) node.value = null;
                        _state.label = 9;
                    case 9:
                        return [
                            2,
                            ctrl
                        ];
                }
            });
        });
        return _visitAsync_.apply(this, arguments);
    }
    function initVisitor(visitor) {
        if ((typeof visitor === "undefined" ? "undefined" : _type_of$E(visitor)) === 'object' && (visitor.Collection || visitor.Node || visitor.Value)) {
            return Object.assign({
                Alias: visitor.Node,
                Map: visitor.Node,
                Scalar: visitor.Node,
                Seq: visitor.Node
            }, visitor.Value && {
                Map: visitor.Value,
                Scalar: visitor.Value,
                Seq: visitor.Value
            }, visitor.Collection && {
                Map: visitor.Collection,
                Seq: visitor.Collection
            }, visitor);
        }
        return visitor;
    }
    function callVisitor(key, node, visitor, path) {
        var _visitor_Map, _visitor_Seq, _visitor_Pair, _visitor_Scalar, _visitor_Alias;
        if (typeof visitor === 'function') return visitor(key, node, path);
        if (identity.isMap(node)) return (_visitor_Map = visitor.Map) === null || _visitor_Map === undefined ? undefined : _visitor_Map.call(visitor, key, node, path);
        if (identity.isSeq(node)) return (_visitor_Seq = visitor.Seq) === null || _visitor_Seq === undefined ? undefined : _visitor_Seq.call(visitor, key, node, path);
        if (identity.isPair(node)) return (_visitor_Pair = visitor.Pair) === null || _visitor_Pair === undefined ? undefined : _visitor_Pair.call(visitor, key, node, path);
        if (identity.isScalar(node)) return (_visitor_Scalar = visitor.Scalar) === null || _visitor_Scalar === undefined ? undefined : _visitor_Scalar.call(visitor, key, node, path);
        if (identity.isAlias(node)) return (_visitor_Alias = visitor.Alias) === null || _visitor_Alias === undefined ? undefined : _visitor_Alias.call(visitor, key, node, path);
        return undefined;
    }
    function replaceNode(key, path, node) {
        var parent = path[path.length - 1];
        if (identity.isCollection(parent)) {
            parent.items[key] = node;
        } else if (identity.isPair(parent)) {
            if (key === 'key') parent.key = node;
            else parent.value = node;
        } else if (identity.isDocument(parent)) {
            parent.contents = node;
        } else {
            var pt = identity.isAlias(parent) ? 'alias' : 'scalar';
            throw new Error("Cannot replace node with ".concat(pt, " parent"));
        }
    }
    visit.visit = visit$1;
    visit.visitAsync = visitAsync;
    return visit;
}

function _array_like_to_array$j(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$d(arr) {
    if (Array.isArray(arr)) return arr;
}
function _class_call_check$y(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _iterable_to_array_limit$b(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$d() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$b(arr, i) {
    return _array_with_holes$d(arr) || _iterable_to_array_limit$b(arr, i) || _unsupported_iterable_to_array$j(arr, i) || _non_iterable_rest$d();
}
function _unsupported_iterable_to_array$j(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$j(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$j(o, minLen);
}
var hasRequiredDirectives;
function requireDirectives() {
    if (hasRequiredDirectives) return directives;
    hasRequiredDirectives = 1;
    var identity = requireIdentity();
    var visit = requireVisit();
    var escapeChars = {
        '!': '%21',
        ',': '%2C',
        '[': '%5B',
        ']': '%5D',
        '{': '%7B',
        '}': '%7D'
    };
    var escapeTagName = function(tn) {
        return tn.replace(/[!,[\]{}]/g, function(ch) {
            return escapeChars[ch];
        });
    };
    var Directives = /*#__PURE__*/ function() {
        function Directives(yaml, tags) {
            _class_call_check$y(this, Directives);
            /**
	         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
	         * included in the document's stringified representation.
	         */ this.docStart = null;
            /** The doc-end marker `...`.  */ this.docEnd = false;
            this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
            this.tags = Object.assign({}, Directives.defaultTags, tags);
        }
        var _proto = Directives.prototype;
        _proto.clone = function clone() {
            var copy = new Directives(this.yaml, this.tags);
            copy.docStart = this.docStart;
            return copy;
        };
        /**
	     * During parsing, get a Directives instance for the current document and
	     * update the stream state according to the current version's spec.
	     */ _proto.atDocument = function atDocument() {
            var res = new Directives(this.yaml, this.tags);
            switch(this.yaml.version){
                case '1.1':
                    this.atNextDocument = true;
                    break;
                case '1.2':
                    this.atNextDocument = false;
                    this.yaml = {
                        explicit: Directives.defaultYaml.explicit,
                        version: '1.2'
                    };
                    this.tags = Object.assign({}, Directives.defaultTags);
                    break;
            }
            return res;
        };
        /**
	     * @param onError - May be called even if the action was successful
	     * @returns `true` on success
	     */ _proto.add = function add(line, onError) {
            if (this.atNextDocument) {
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.1'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                this.atNextDocument = false;
            }
            var parts = line.trim().split(/[ \t]+/);
            var name = parts.shift();
            switch(name){
                case '%TAG':
                    {
                        if (parts.length !== 2) {
                            onError(0, '%TAG directive should contain exactly two parts');
                            if (parts.length < 2) return false;
                        }
                        var _parts = _sliced_to_array$b(parts, 2), handle = _parts[0], prefix = _parts[1];
                        this.tags[handle] = prefix;
                        return true;
                    }
                case '%YAML':
                    {
                        this.yaml.explicit = true;
                        if (parts.length !== 1) {
                            onError(0, '%YAML directive should contain exactly one part');
                            return false;
                        }
                        var _parts1 = _sliced_to_array$b(parts, 1), version = _parts1[0];
                        if (version === '1.1' || version === '1.2') {
                            this.yaml.version = version;
                            return true;
                        } else {
                            var isValid = /^\d+\.\d+$/.test(version);
                            onError(6, "Unsupported YAML version ".concat(version), isValid);
                            return false;
                        }
                    }
                default:
                    onError(0, "Unknown directive ".concat(name), true);
                    return false;
            }
        };
        /**
	     * Resolves a tag, matching handles to those defined in %TAG directives.
	     *
	     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
	     *   `'!local'` tag, or `null` if unresolvable.
	     */ _proto.tagName = function tagName(source, onError) {
            if (source === '!') return '!'; // non-specific tag
            if (source[0] !== '!') {
                onError("Not a valid tag: ".concat(source));
                return null;
            }
            if (source[1] === '<') {
                var verbatim = source.slice(2, -1);
                if (verbatim === '!' || verbatim === '!!') {
                    onError("Verbatim tags aren't resolved, so ".concat(source, " is invalid."));
                    return null;
                }
                if (source[source.length - 1] !== '>') onError('Verbatim tags must end with a >');
                return verbatim;
            }
            var _source_match = _sliced_to_array$b(source.match(RegExp("^(.*!)([^!]*)$", "s")), 3), handle = _source_match[1], suffix = _source_match[2];
            if (!suffix) onError("The ".concat(source, " tag has no suffix"));
            var prefix = this.tags[handle];
            if (prefix) {
                try {
                    return prefix + decodeURIComponent(suffix);
                } catch (error) {
                    onError(String(error));
                    return null;
                }
            }
            if (handle === '!') return source; // local tag
            onError("Could not resolve tag: ".concat(source));
            return null;
        };
        /**
	     * Given a fully resolved tag, returns its printable string form,
	     * taking into account current tag prefixes and defaults.
	     */ _proto.tagString = function tagString(tag) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.entries(this.tags)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array$b(_step.value, 2), handle = _step_value[0], prefix = _step_value[1];
                    if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return tag[0] === '!' ? tag : "!<".concat(tag, ">");
        };
        _proto.toString = function toString(doc) {
            var lines = this.yaml.explicit ? [
                "%YAML ".concat(this.yaml.version || '1.2')
            ] : [];
            var tagEntries = Object.entries(this.tags);
            var tagNames;
            if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
                var tags = {};
                visit.visit(doc.contents, function(_key, node) {
                    if (identity.isNode(node) && node.tag) tags[node.tag] = true;
                });
                tagNames = Object.keys(tags);
            } else tagNames = [];
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                var _loop = function() {
                    var _step_value = _sliced_to_array$b(_step.value, 2), handle = _step_value[0], prefix = _step_value[1];
                    if (handle === '!!' && prefix === 'tag:yaml.org,2002:') return "continue";
                    if (!doc || tagNames.some(function(tn) {
                        return tn.startsWith(prefix);
                    })) lines.push("%TAG ".concat(handle, " ").concat(prefix));
                };
                for(var _iterator = tagEntries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return lines.join('\n');
        };
        return Directives;
    }();
    Directives.defaultYaml = {
        explicit: false,
        version: '1.2'
    };
    Directives.defaultTags = {
        '!!': 'tag:yaml.org,2002:'
    };
    directives.Directives = Directives;
    return directives;
}

var Document = {};

var Alias = {};

var anchors = {};

function _type_of$D(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredAnchors;
function requireAnchors() {
    if (hasRequiredAnchors) return anchors;
    hasRequiredAnchors = 1;
    var identity = requireIdentity();
    var visit = requireVisit();
    /**
	 * Verify that the input string is a valid anchor.
	 *
	 * Will throw on errors.
	 */ function anchorIsValid(anchor) {
        if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
            var sa = JSON.stringify(anchor);
            var msg = "Anchor must not contain whitespace or control characters: ".concat(sa);
            throw new Error(msg);
        }
        return true;
    }
    function anchorNames(root) {
        var _$anchors = new Set();
        visit.visit(root, {
            Value: function Value(_key, node) {
                if (node.anchor) _$anchors.add(node.anchor);
            }
        });
        return _$anchors;
    }
    /** Find a new anchor name with the given `prefix` and a one-indexed suffix. */ function findNewAnchor(prefix, exclude) {
        for(var i = 1; true; ++i){
            var name = "".concat(prefix).concat(i);
            if (!exclude.has(name)) return name;
        }
    }
    function createNodeAnchors(doc, prefix) {
        var aliasObjects = [];
        var sourceObjects = new Map();
        var prevAnchors = null;
        return {
            onAnchor: function(source) {
                aliasObjects.push(source);
                if (!prevAnchors) prevAnchors = anchorNames(doc);
                var anchor = findNewAnchor(prefix, prevAnchors);
                prevAnchors.add(anchor);
                return anchor;
            },
            /**
	         * With circular references, the source node is only resolved after all
	         * of its child nodes are. This is why anchors are set only after all of
	         * the nodes have been created.
	         */ setAnchors: function() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = aliasObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var source = _step.value;
                        var ref = sourceObjects.get(source);
                        if ((typeof ref === "undefined" ? "undefined" : _type_of$D(ref)) === 'object' && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
                            ref.node.anchor = ref.anchor;
                        } else {
                            var error = new Error('Failed to resolve repeated object (this should not happen)');
                            error.source = source;
                            throw error;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            },
            sourceObjects: sourceObjects
        };
    }
    anchors.anchorIsValid = anchorIsValid;
    anchors.anchorNames = anchorNames;
    anchors.createNodeAnchors = createNodeAnchors;
    anchors.findNewAnchor = findNewAnchor;
    return anchors;
}

var Node = {};

var applyReviver = {};

function _array_like_to_array$i(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$c(arr) {
    if (Array.isArray(arr)) return arr;
}
function _instanceof$m(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array_limit$a(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$c() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$a(arr, i) {
    return _array_with_holes$c(arr) || _iterable_to_array_limit$a(arr, i) || _unsupported_iterable_to_array$i(arr, i) || _non_iterable_rest$c();
}
function _type_of$C(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$i(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$i(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$i(o, minLen);
}
var hasRequiredApplyReviver;
function requireApplyReviver() {
    if (hasRequiredApplyReviver) return applyReviver;
    hasRequiredApplyReviver = 1;
    /**
	 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
	 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
	 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
	 *
	 * Includes extensions for handling Map and Set objects.
	 */ function applyReviver$1(reviver, obj, key, val) {
        if (val && (typeof val === "undefined" ? "undefined" : _type_of$C(val)) === 'object') {
            if (Array.isArray(val)) {
                for(var i = 0, len = val.length; i < len; ++i){
                    var v0 = val[i];
                    var v1 = applyReviver$1(reviver, val, String(i), v0);
                    // eslint-disable-next-line @typescript-eslint/no-array-delete
                    if (v1 === undefined) delete val[i];
                    else if (v1 !== v0) val[i] = v1;
                }
            } else if (_instanceof$m(val, Map)) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Array.from(val.keys())[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var k = _step.value;
                        var v01 = val.get(k);
                        var v11 = applyReviver$1(reviver, val, k, v01);
                        if (v11 === undefined) val.delete(k);
                        else if (v11 !== v01) val.set(k, v11);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            } else if (_instanceof$m(val, Set)) {
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = Array.from(val)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var v02 = _step1.value;
                        var v12 = applyReviver$1(reviver, val, v02, v02);
                        if (v12 === undefined) val.delete(v02);
                        else if (v12 !== v02) {
                            val.delete(v02);
                            val.add(v12);
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            } else {
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                try {
                    for(var _iterator2 = Object.entries(val)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                        var _step_value = _sliced_to_array$a(_step2.value, 2), k1 = _step_value[0], v03 = _step_value[1];
                        var v13 = applyReviver$1(reviver, val, k1, v03);
                        if (v13 === undefined) delete val[k1];
                        else if (v13 !== v03) val[k1] = v13;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                            _iterator2.return();
                        }
                    } finally{
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        }
        return reviver.call(obj, key, val);
    }
    applyReviver.applyReviver = applyReviver$1;
    return applyReviver;
}

var toJS = {};

function _type_of$B(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredToJS;
function requireToJS() {
    if (hasRequiredToJS) return toJS;
    hasRequiredToJS = 1;
    var identity = requireIdentity();
    /**
	 * Recursively convert any node or its contents to native JavaScript
	 *
	 * @param value - The input value
	 * @param arg - If `value` defines a `toJSON()` method, use this
	 *   as its first argument
	 * @param ctx - Conversion context, originally set in Document#toJS(). If
	 *   `{ keep: true }` is not set, output should be suitable for JSON
	 *   stringification.
	 */ function toJS$1(value, arg, ctx) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        if (Array.isArray(value)) return value.map(function(v, i) {
            return toJS$1(v, String(i), ctx);
        });
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
            var data = {
                aliasCount: 0,
                count: 1,
                res: undefined
            };
            ctx.anchors.set(value, data);
            ctx.onCreate = function(res) {
                data.res = res;
                delete ctx.onCreate;
            };
            var res = value.toJSON(arg, ctx);
            if (ctx.onCreate) ctx.onCreate(res);
            return res;
        }
        if ((typeof value === "undefined" ? "undefined" : _type_of$B(value)) === 'bigint' && !(ctx === null || ctx === undefined ? undefined : ctx.keep)) return Number(value);
        return value;
    }
    toJS.toJS = toJS$1;
    return toJS;
}

function _class_call_check$x(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var hasRequiredNode;
function requireNode() {
    if (hasRequiredNode) return Node;
    hasRequiredNode = 1;
    var applyReviver = requireApplyReviver();
    var identity = requireIdentity();
    var toJS = requireToJS();
    var NodeBase = /*#__PURE__*/ function() {
        function NodeBase(type) {
            _class_call_check$x(this, NodeBase);
            Object.defineProperty(this, identity.NODE_TYPE, {
                value: type
            });
        }
        var _proto = NodeBase.prototype;
        /** Create a copy of this node.  */ _proto.clone = function clone() {
            var copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            if (this.range) copy.range = this.range.slice();
            return copy;
        };
        /** A plain JavaScript representation of this node. */ _proto.toJS = function toJS1(doc) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, mapAsMap = _ref.mapAsMap, maxAliasCount = _ref.maxAliasCount, onAnchor = _ref.onAnchor, reviver = _ref.reviver;
            if (!identity.isDocument(doc)) throw new TypeError('A document argument is required');
            var ctx = {
                anchors: new Map(),
                doc: doc,
                keep: true,
                mapAsMap: mapAsMap === true,
                mapKeyWarned: false,
                maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
            };
            var res = toJS.toJS(this, '', ctx);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            if (typeof onAnchor === 'function') try {
                for(var _iterator = ctx.anchors.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _step.value, count = _step_value.count, res1 = _step_value.res;
                    onAnchor(res1, count);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return typeof reviver === 'function' ? applyReviver.applyReviver(reviver, {
                '': res
            }, '', res) : res;
        };
        return NodeBase;
    }();
    Node.NodeBase = NodeBase;
    return Node;
}

function _assert_this_initialized$g(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$g(_this, derived, args) {
    derived = _get_prototype_of$g(derived);
    return _possible_constructor_return$g(_this, _is_native_reflect_construct$g() ? Reflect.construct(derived, args, _get_prototype_of$g(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$w(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$g(o) {
    _get_prototype_of$g = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$g(o);
}
function _inherits$g(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$g(subClass, superClass);
}
function _possible_constructor_return$g(self, call) {
    if (call && (_type_of$A(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$g(self);
}
function _set_prototype_of$g(o, p) {
    _set_prototype_of$g = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$g(o, p);
}
function _type_of$A(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$g() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$g = function() {
        return !!result;
    })();
}
var hasRequiredAlias;
function requireAlias() {
    if (hasRequiredAlias) return Alias;
    hasRequiredAlias = 1;
    var anchors = requireAnchors();
    var visit = requireVisit();
    var identity = requireIdentity();
    var Node = requireNode();
    var toJS = requireToJS();
    var Alias$1 = /*#__PURE__*/ function(_Node_NodeBase) {
        _inherits$g(Alias, _Node_NodeBase);
        function Alias(source) {
            _class_call_check$w(this, Alias);
            var _this;
            _this = _call_super$g(this, Alias, [
                identity.ALIAS
            ]);
            _this.source = source;
            Object.defineProperty(_this, 'tag', {
                set: function set() {
                    throw new Error('Alias nodes cannot have tags');
                }
            });
            return _this;
        }
        var _proto = Alias.prototype;
        /**
	     * Resolve the value of this alias within `doc`, finding the last
	     * instance of the `source` anchor before this node.
	     */ _proto.resolve = function resolve(doc) {
            var _this = this;
            var found = undefined;
            visit.visit(doc, {
                Node: function(_key, node) {
                    if (node === _this) return visit.visit.BREAK;
                    if (node.anchor === _this.source) found = node;
                }
            });
            return found;
        };
        _proto.toJSON = function toJSON(_arg, ctx) {
            if (!ctx) return {
                source: this.source
            };
            var anchors = ctx.anchors, doc = ctx.doc, maxAliasCount = ctx.maxAliasCount;
            var source = this.resolve(doc);
            if (!source) {
                var msg = "Unresolved alias (the anchor must be set before the alias): ".concat(this.source);
                throw new ReferenceError(msg);
            }
            var data = anchors.get(source);
            if (!data) {
                // Resolve anchors for Node.prototype.toJS()
                toJS.toJS(source, null, ctx);
                data = anchors.get(source);
            }
            /* istanbul ignore if */ if (!data || data.res === undefined) {
                var msg1 = 'This should not happen: Alias anchor was not resolved?';
                throw new ReferenceError(msg1);
            }
            if (maxAliasCount >= 0) {
                data.count += 1;
                if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);
                if (data.count * data.aliasCount > maxAliasCount) {
                    var msg2 = 'Excessive alias count indicates a resource exhaustion attack';
                    throw new ReferenceError(msg2);
                }
            }
            return data.res;
        };
        _proto.toString = function toString(ctx, _onComment, _onChompKeep) {
            var src = "*".concat(this.source);
            if (ctx) {
                anchors.anchorIsValid(this.source);
                if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                    var msg = "Unresolved alias (the anchor must be set before the alias): ".concat(this.source);
                    throw new Error(msg);
                }
                if (ctx.implicitKey) return "".concat(src, " ");
            }
            return src;
        };
        return Alias;
    }(Node.NodeBase);
    function getAliasCount(doc, node, anchors) {
        if (identity.isAlias(node)) {
            var source = node.resolve(doc);
            var anchor = anchors && source && anchors.get(source);
            return anchor ? anchor.count * anchor.aliasCount : 0;
        } else if (identity.isCollection(node)) {
            var count = 0;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = node.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var item = _step.value;
                    var c = getAliasCount(doc, item, anchors);
                    if (c > count) count = c;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return count;
        } else if (identity.isPair(node)) {
            var kc = getAliasCount(doc, node.key, anchors);
            var vc = getAliasCount(doc, node.value, anchors);
            return Math.max(kc, vc);
        }
        return 1;
    }
    Alias.Alias = Alias$1;
    return Alias;
}

var Collection = {};

var createNode = {};

var Scalar = {};

function _assert_this_initialized$f(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$f(_this, derived, args) {
    derived = _get_prototype_of$f(derived);
    return _possible_constructor_return$f(_this, _is_native_reflect_construct$f() ? Reflect.construct(derived, args, _get_prototype_of$f(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$v(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$f(o) {
    _get_prototype_of$f = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$f(o);
}
function _inherits$f(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$f(subClass, superClass);
}
function _possible_constructor_return$f(self, call) {
    if (call && (_type_of$z(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$f(self);
}
function _set_prototype_of$f(o, p) {
    _set_prototype_of$f = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$f(o, p);
}
function _type_of$z(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$f() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$f = function() {
        return !!result;
    })();
}
var hasRequiredScalar;
function requireScalar() {
    if (hasRequiredScalar) return Scalar;
    hasRequiredScalar = 1;
    var identity = requireIdentity();
    var Node = requireNode();
    var toJS = requireToJS();
    var isScalarValue = function(value) {
        return !value || typeof value !== 'function' && (typeof value === "undefined" ? "undefined" : _type_of$z(value)) !== 'object';
    };
    var Scalar$1 = /*#__PURE__*/ function(_Node_NodeBase) {
        _inherits$f(Scalar, _Node_NodeBase);
        function Scalar(value) {
            _class_call_check$v(this, Scalar);
            var _this;
            _this = _call_super$f(this, Scalar, [
                identity.SCALAR
            ]);
            _this.value = value;
            return _this;
        }
        var _proto = Scalar.prototype;
        _proto.toJSON = function toJSON(arg, ctx) {
            return (ctx === null || ctx === undefined ? undefined : ctx.keep) ? this.value : toJS.toJS(this.value, arg, ctx);
        };
        _proto.toString = function toString() {
            return String(this.value);
        };
        return Scalar;
    }(Node.NodeBase);
    Scalar$1.BLOCK_FOLDED = 'BLOCK_FOLDED';
    Scalar$1.BLOCK_LITERAL = 'BLOCK_LITERAL';
    Scalar$1.PLAIN = 'PLAIN';
    Scalar$1.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
    Scalar$1.QUOTE_SINGLE = 'QUOTE_SINGLE';
    Scalar.Scalar = Scalar$1;
    Scalar.isScalarValue = isScalarValue;
    return Scalar;
}

function _instanceof$l(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _type_of$y(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredCreateNode;
function requireCreateNode() {
    if (hasRequiredCreateNode) return createNode;
    hasRequiredCreateNode = 1;
    var Alias = requireAlias();
    var identity = requireIdentity();
    var Scalar = requireScalar();
    var defaultTagPrefix = 'tag:yaml.org,2002:';
    function findTagObject(value, tagName, tags) {
        if (tagName) {
            var match = tags.filter(function(t) {
                return t.tag === tagName;
            });
            var _match_find;
            var tagObj = (_match_find = match.find(function(t) {
                return !t.format;
            })) !== null && _match_find !== undefined ? _match_find : match[0];
            if (!tagObj) throw new Error("Tag ".concat(tagName, " not found"));
            return tagObj;
        }
        return tags.find(function(t) {
            var _t_identify;
            return ((_t_identify = t.identify) === null || _t_identify === undefined ? undefined : _t_identify.call(t, value)) && !t.format;
        });
    }
    function createNode$1(value, tagName, ctx) {
        var _tagObj_nodeClass;
        if (identity.isDocument(value)) value = value.contents;
        if (identity.isNode(value)) return value;
        if (identity.isPair(value)) {
            var _ctx_schema_identity_MAP_createNode, _ctx_schema_identity_MAP;
            var map = (_ctx_schema_identity_MAP_createNode = (_ctx_schema_identity_MAP = ctx.schema[identity.MAP]).createNode) === null || _ctx_schema_identity_MAP_createNode === undefined ? undefined : _ctx_schema_identity_MAP_createNode.call(_ctx_schema_identity_MAP, ctx.schema, null, ctx);
            map.items.push(value);
            return map;
        }
        if (_instanceof$l(value, String) || _instanceof$l(value, Number) || _instanceof$l(value, Boolean) || typeof BigInt !== 'undefined' && _instanceof$l(value, BigInt // not supported everywhere
        )) {
            // https://tc39.es/ecma262/#sec-serializejsonproperty
            value = value.valueOf();
        }
        var aliasDuplicateObjects = ctx.aliasDuplicateObjects, onAnchor = ctx.onAnchor, onTagObj = ctx.onTagObj, schema = ctx.schema, sourceObjects = ctx.sourceObjects;
        // Detect duplicate references to the same object & use Alias nodes for all
        // after first. The `ref` wrapper allows for circular references to resolve.
        var ref = undefined;
        if (aliasDuplicateObjects && value && (typeof value === "undefined" ? "undefined" : _type_of$y(value)) === 'object') {
            ref = sourceObjects.get(value);
            if (ref) {
                if (!ref.anchor) ref.anchor = onAnchor(value);
                return new Alias.Alias(ref.anchor);
            } else {
                ref = {
                    anchor: null,
                    node: null
                };
                sourceObjects.set(value, ref);
            }
        }
        if (tagName === null || tagName === undefined ? undefined : tagName.startsWith('!!')) tagName = defaultTagPrefix + tagName.slice(2);
        var tagObj = findTagObject(value, tagName, schema.tags);
        if (!tagObj) {
            if (value && typeof value.toJSON === 'function') {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                value = value.toJSON();
            }
            if (!value || (typeof value === "undefined" ? "undefined" : _type_of$y(value)) !== 'object') {
                var node = new Scalar.Scalar(value);
                if (ref) ref.node = node;
                return node;
            }
            tagObj = _instanceof$l(value, Map) ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
        }
        if (onTagObj) {
            onTagObj(tagObj);
            delete ctx.onTagObj;
        }
        var node1 = (tagObj === null || tagObj === undefined ? undefined : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof (tagObj === null || tagObj === undefined ? undefined : (_tagObj_nodeClass = tagObj.nodeClass) === null || _tagObj_nodeClass === undefined ? undefined : _tagObj_nodeClass.from) === 'function' ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
        if (tagName) node1.tag = tagName;
        else if (!tagObj.default) node1.tag = tagObj.tag;
        if (ref) ref.node = node1;
        return node1;
    }
    createNode.createNode = createNode$1;
    return createNode;
}

function _array_like_to_array$h(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$b(arr) {
    if (Array.isArray(arr)) return arr;
}
function _assert_this_initialized$e(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$e(_this, derived, args) {
    derived = _get_prototype_of$e(derived);
    return _possible_constructor_return$e(_this, _is_native_reflect_construct$e() ? Reflect.construct(derived, args, _get_prototype_of$e(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$u(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$e(o) {
    _get_prototype_of$e = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$e(o);
}
function _inherits$e(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$e(subClass, superClass);
}
function _iterable_to_array$9(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_rest$b() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$e(self, call) {
    if (call && (_type_of$x(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$e(self);
}
function _set_prototype_of$e(o, p) {
    _set_prototype_of$e = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$e(o, p);
}
function _to_array$1(arr) {
    return _array_with_holes$b(arr) || _iterable_to_array$9(arr) || _unsupported_iterable_to_array$h(arr) || _non_iterable_rest$b();
}
function _type_of$x(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$h(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$h(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$h(o, minLen);
}
function _is_native_reflect_construct$e() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$e = function() {
        return !!result;
    })();
}
var hasRequiredCollection;
function requireCollection() {
    if (hasRequiredCollection) return Collection;
    hasRequiredCollection = 1;
    var createNode = requireCreateNode();
    var identity = requireIdentity();
    var Node = requireNode();
    function collectionFromPath(schema, path, value) {
        var v = value;
        for(var i = path.length - 1; i >= 0; --i){
            var k = path[i];
            if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
                var a = [];
                a[k] = v;
                v = a;
            } else {
                v = new Map([
                    [
                        k,
                        v
                    ]
                ]);
            }
        }
        return createNode.createNode(v, undefined, {
            aliasDuplicateObjects: false,
            keepUndefined: false,
            onAnchor: function() {
                throw new Error('This should not happen, please report a bug.');
            },
            schema: schema,
            sourceObjects: new Map()
        });
    }
    // Type guard is intentionally a little wrong so as to be more useful,
    // as it does not cover untypable empty non-string iterables (e.g. []).
    var isEmptyPath = function(path) {
        return path == null || (typeof path === "undefined" ? "undefined" : _type_of$x(path)) === 'object' && !!path[Symbol.iterator]().next().done;
    };
    var Collection$1 = /*#__PURE__*/ function(_Node_NodeBase) {
        _inherits$e(Collection, _Node_NodeBase);
        function Collection(type, schema) {
            _class_call_check$u(this, Collection);
            var _this;
            _this = _call_super$e(this, Collection, [
                type
            ]);
            Object.defineProperty(_this, 'schema', {
                value: schema,
                configurable: true,
                enumerable: false,
                writable: true
            });
            return _this;
        }
        var _proto = Collection.prototype;
        /**
	     * Create a copy of this collection.
	     *
	     * @param schema - If defined, overwrites the original's schema
	     */ _proto.clone = function clone(schema) {
            var copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            if (schema) copy.schema = schema;
            copy.items = copy.items.map(function(it) {
                return identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it;
            });
            if (this.range) copy.range = this.range.slice();
            return copy;
        };
        /**
	     * Adds a value to the collection. For `!!map` and `!!omap` the value must
	     * be a Pair instance or a `{ key, value }` object, which may not have a key
	     * that already exists in the map.
	     */ _proto.addIn = function addIn(path, value) {
            if (isEmptyPath(path)) this.add(value);
            else {
                var _path = _to_array$1(path), key = _path[0], rest = _path.slice(1);
                var node = this.get(key, true);
                if (identity.isCollection(node)) node.addIn(rest, value);
                else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
                else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
            }
        };
        /**
	     * Removes a value from the collection.
	     * @returns `true` if the item was found and removed.
	     */ _proto.deleteIn = function deleteIn(path) {
            var _path = _to_array$1(path), key = _path[0], rest = _path.slice(1);
            if (rest.length === 0) return this.delete(key);
            var node = this.get(key, true);
            if (identity.isCollection(node)) return node.deleteIn(rest);
            else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
        };
        /**
	     * Returns item at `key`, or `undefined` if not found. By default unwraps
	     * scalar values from their surrounding node; to disable set `keepScalar` to
	     * `true` (collections are always returned intact).
	     */ _proto.getIn = function getIn(path, keepScalar) {
            var _path = _to_array$1(path), key = _path[0], rest = _path.slice(1);
            var node = this.get(key, true);
            if (rest.length === 0) return !keepScalar && identity.isScalar(node) ? node.value : node;
            else return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
        };
        _proto.hasAllNullValues = function hasAllNullValues(allowScalar) {
            return this.items.every(function(node) {
                if (!identity.isPair(node)) return false;
                var n = node.value;
                return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
            });
        };
        /**
	     * Checks if the collection includes a value with the key `key`.
	     */ _proto.hasIn = function hasIn(path) {
            var _path = _to_array$1(path), key = _path[0], rest = _path.slice(1);
            if (rest.length === 0) return this.has(key);
            var node = this.get(key, true);
            return identity.isCollection(node) ? node.hasIn(rest) : false;
        };
        /**
	     * Sets a value in this collection. For `!!set`, `value` needs to be a
	     * boolean to add/remove the item from the set.
	     */ _proto.setIn = function setIn(path, value) {
            var _path = _to_array$1(path), key = _path[0], rest = _path.slice(1);
            if (rest.length === 0) {
                this.set(key, value);
            } else {
                var node = this.get(key, true);
                if (identity.isCollection(node)) node.setIn(rest, value);
                else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
                else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
            }
        };
        return Collection;
    }(Node.NodeBase);
    Collection.Collection = Collection$1;
    Collection.collectionFromPath = collectionFromPath;
    Collection.isEmptyPath = isEmptyPath;
    return Collection;
}

var Pair = {};

var stringifyPair = {};

var stringify = {};

var stringifyComment = {};

var hasRequiredStringifyComment;
function requireStringifyComment() {
    if (hasRequiredStringifyComment) return stringifyComment;
    hasRequiredStringifyComment = 1;
    /**
	 * Stringifies a comment.
	 *
	 * Empty comment lines are left empty,
	 * lines consisting of a single space are replaced by `#`,
	 * and all other lines are prefixed with a `#`.
	 */ var stringifyComment$1 = function(str) {
        return str.replace(/^(?!$)(?: $)?/gm, '#');
    };
    function indentComment(comment, indent) {
        if (/^\n+$/.test(comment)) return comment.substring(1);
        return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = function(str, indent, comment) {
        return str.endsWith('\n') ? indentComment(comment, indent) : comment.includes('\n') ? '\n' + indentComment(comment, indent) : (str.endsWith(' ') ? '' : ' ') + comment;
    };
    stringifyComment.indentComment = indentComment;
    stringifyComment.lineComment = lineComment;
    stringifyComment.stringifyComment = stringifyComment$1;
    return stringifyComment;
}

var stringifyString = {};

var foldFlowLines = {};

var hasRequiredFoldFlowLines;
function requireFoldFlowLines() {
    if (hasRequiredFoldFlowLines) return foldFlowLines;
    hasRequiredFoldFlowLines = 1;
    var FOLD_FLOW = 'flow';
    var FOLD_BLOCK = 'block';
    var FOLD_QUOTED = 'quoted';
    /**
	 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
	 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
	 * terminated with `\n` and started with `indent`.
	 */ function foldFlowLines$1(text, indent) {
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flow', _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, indentAtStart = _ref.indentAtStart, _ref_lineWidth = _ref.lineWidth, lineWidth = _ref_lineWidth === undefined ? 80 : _ref_lineWidth, _ref_minContentWidth = _ref.minContentWidth, minContentWidth = _ref_minContentWidth === undefined ? 20 : _ref_minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
        if (!lineWidth || lineWidth < 0) return text;
        if (lineWidth < minContentWidth) minContentWidth = 0;
        var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
        if (text.length <= endStep) return text;
        var folds = [];
        var escapedFolds = {};
        var end = lineWidth - indent.length;
        if (typeof indentAtStart === 'number') {
            if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
            else end = lineWidth - indentAtStart;
        }
        var split = undefined;
        var prev = undefined;
        var overflow = false;
        var i = -1;
        var escStart = -1;
        var escEnd = -1;
        if (mode === FOLD_BLOCK) {
            i = consumeMoreIndentedLines(text, i, indent.length);
            if (i !== -1) end = i + endStep;
        }
        for(var ch; ch = text[i += 1];){
            if (mode === FOLD_QUOTED && ch === '\\') {
                escStart = i;
                switch(text[i + 1]){
                    case 'x':
                        i += 3;
                        break;
                    case 'u':
                        i += 5;
                        break;
                    case 'U':
                        i += 9;
                        break;
                    default:
                        i += 1;
                }
                escEnd = i;
            }
            if (ch === '\n') {
                if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i, indent.length);
                end = i + indent.length + endStep;
                split = undefined;
            } else {
                if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
                    // space surrounded by non-space can be replaced with newline + indent
                    var next = text[i + 1];
                    if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
                }
                if (i >= end) {
                    if (split) {
                        folds.push(split);
                        end = split + endStep;
                        split = undefined;
                    } else if (mode === FOLD_QUOTED) {
                        // white-space collected at end may stretch past lineWidth
                        while(prev === ' ' || prev === '\t'){
                            prev = ch;
                            ch = text[i += 1];
                            overflow = true;
                        }
                        // Account for newline escape, but don't break preceding escape
                        var j = i > escEnd + 1 ? i - 2 : escStart - 1;
                        // Bail out if lineWidth & minContentWidth are shorter than an escape string
                        if (escapedFolds[j]) return text;
                        folds.push(j);
                        escapedFolds[j] = true;
                        end = j + endStep;
                        split = undefined;
                    } else {
                        overflow = true;
                    }
                }
            }
            prev = ch;
        }
        if (overflow && onOverflow) onOverflow();
        if (folds.length === 0) return text;
        if (onFold) onFold();
        var res = text.slice(0, folds[0]);
        for(var i1 = 0; i1 < folds.length; ++i1){
            var fold = folds[i1];
            var end1 = folds[i1 + 1] || text.length;
            if (fold === 0) res = "\n".concat(indent).concat(text.slice(0, end1));
            else {
                if (mode === FOLD_QUOTED && escapedFolds[fold]) res += "".concat(text[fold], "\\");
                res += "\n".concat(indent).concat(text.slice(fold + 1, end1));
            }
        }
        return res;
    }
    /**
	 * Presumes `i + 1` is at the start of a line
	 * @returns index of last newline in more-indented block
	 */ function consumeMoreIndentedLines(text, i, indent) {
        var end = i;
        var start = i + 1;
        var ch = text[start];
        while(ch === ' ' || ch === '\t'){
            if (i < start + indent) {
                ch = text[++i];
            } else {
                do {
                    ch = text[++i];
                }while (ch && ch !== '\n');
                end = i;
                start = i + 1;
                ch = text[start];
            }
        }
        return end;
    }
    foldFlowLines.FOLD_BLOCK = FOLD_BLOCK;
    foldFlowLines.FOLD_FLOW = FOLD_FLOW;
    foldFlowLines.FOLD_QUOTED = FOLD_QUOTED;
    foldFlowLines.foldFlowLines = foldFlowLines$1;
    return foldFlowLines;
}

var hasRequiredStringifyString;
function requireStringifyString() {
    if (hasRequiredStringifyString) return stringifyString;
    hasRequiredStringifyString = 1;
    var Scalar = requireScalar();
    var foldFlowLines = requireFoldFlowLines();
    var getFoldOptions = function(ctx, isBlock) {
        return {
            indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
            lineWidth: ctx.options.lineWidth,
            minContentWidth: ctx.options.minContentWidth
        };
    };
    // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
    // presume that's starting a new document.
    var containsDocumentMarker = function(str) {
        return /^(%|---|\.\.\.)/m.test(str);
    };
    function lineLengthOverLimit(str, lineWidth, indentLength) {
        if (!lineWidth || lineWidth < 0) return false;
        var limit = lineWidth - indentLength;
        var strLen = str.length;
        if (strLen <= limit) return false;
        for(var i = 0, start = 0; i < strLen; ++i){
            if (str[i] === '\n') {
                if (i - start > limit) return true;
                start = i + 1;
                if (strLen - start <= limit) return false;
            }
        }
        return true;
    }
    function doubleQuotedString(value, ctx) {
        var json = JSON.stringify(value);
        if (ctx.options.doubleQuotedAsJSON) return json;
        var implicitKey = ctx.implicitKey;
        var minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
        var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
        var str = '';
        var start = 0;
        for(var i = 0, ch = json[i]; ch; ch = json[++i]){
            if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
                // space before newline needs to be escaped to not be folded
                str += json.slice(start, i) + '\\ ';
                i += 1;
                start = i;
                ch = '\\';
            }
            if (ch === '\\') switch(json[i + 1]){
                case 'u':
                    {
                        str += json.slice(start, i);
                        var code = json.substr(i + 2, 4);
                        switch(code){
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);
                                else str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                        i += 1;
                    } else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while(json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"'){
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ') str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
        }
        str = start ? str + json.slice(start) : json;
        return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
        if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes('\n') || /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
        ) return doubleQuotedString(value, ctx);
        var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
        var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
        return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
        var singleQuote = ctx.options.singleQuote;
        var qs;
        if (singleQuote === false) qs = doubleQuotedString;
        else {
            var hasDouble = value.includes('"');
            var hasSingle = value.includes("'");
            if (hasDouble && !hasSingle) qs = singleQuotedString;
            else if (hasSingle && !hasDouble) qs = doubleQuotedString;
            else qs = singleQuote ? singleQuotedString : doubleQuotedString;
        }
        return qs(value, ctx);
    }
    // The negative lookbehind avoids a polynomial search,
    // but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
    var blockEndNewlines;
    try {
        blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
    } catch (e) {
        blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString(param, ctx, onComment, onChompKeep) {
        var comment = param.comment, type = param.type, value = param.value;
        var _ctx_options = ctx.options, blockQuote = _ctx_options.blockQuote, commentString = _ctx_options.commentString, lineWidth = _ctx_options.lineWidth;
        // 1. Block can't end in whitespace unless the last line is non-empty.
        // 2. Strings consisting of only whitespace are best rendered explicitly.
        if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
            return quotedString(value, ctx);
        }
        var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
        var literal = blockQuote === 'literal' ? true : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
        if (!value) return literal ? '|\n' : '>\n';
        // determine chomping from whitespace at value end
        var chomp;
        var endStart;
        for(endStart = value.length; endStart > 0; --endStart){
            var ch = value[endStart - 1];
            if (ch !== '\n' && ch !== '\t' && ch !== ' ') break;
        }
        var end = value.substring(endStart);
        var endNlPos = end.indexOf('\n');
        if (endNlPos === -1) {
            chomp = '-'; // strip
        } else if (value === end || endNlPos !== end.length - 1) {
            chomp = '+'; // keep
            if (onChompKeep) onChompKeep();
        } else {
            chomp = ''; // clip
        }
        if (end) {
            value = value.slice(0, -end.length);
            if (end[end.length - 1] === '\n') end = end.slice(0, -1);
            end = end.replace(blockEndNewlines, "$&".concat(indent));
        }
        // determine indent indicator from whitespace at value start
        var startWithSpace = false;
        var startEnd;
        var startNlPos = -1;
        for(startEnd = 0; startEnd < value.length; ++startEnd){
            var ch1 = value[startEnd];
            if (ch1 === ' ') startWithSpace = true;
            else if (ch1 === '\n') startNlPos = startEnd;
            else break;
        }
        var start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
        if (start) {
            value = value.substring(start.length);
            start = start.replace(/\n+/g, "$&".concat(indent));
        }
        var indentSize = indent ? '2' : '1'; // root is at -1
        // Leading | or > is added later
        var header = (startWithSpace ? indentSize : '') + chomp;
        if (comment) {
            header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
            if (onComment) onComment();
        }
        if (!literal) {
            var foldedValue = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
            .replace(/\n+/g, "$&".concat(indent));
            var literalFallback = false;
            var foldOptions = getFoldOptions(ctx, true);
            if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {
                foldOptions.onOverflow = function() {
                    literalFallback = true;
                };
            }
            var body = foldFlowLines.foldFlowLines("".concat(start).concat(foldedValue).concat(end), indent, foldFlowLines.FOLD_BLOCK, foldOptions);
            if (!literalFallback) return ">".concat(header, "\n").concat(indent).concat(body);
        }
        value = value.replace(/\n+/g, "$&".concat(indent));
        return "|".concat(header, "\n").concat(indent).concat(start).concat(value).concat(end);
    }
    function plainString(item, ctx, onComment, onChompKeep) {
        var type = item.type, value = item.value;
        var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, indentStep = ctx.indentStep, inFlow = ctx.inFlow;
        if (implicitKey && value.includes('\n') || inFlow && /[[\]{},]/.test(value)) {
            return quotedString(value, ctx);
        }
        if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
            // not allowed:
            // - empty string, '-' or '?'
            // - start with an indicator character (except [?:-]) or /[?-] /
            // - '\n ', ': ' or ' \n' anywhere
            // - '#' not preceded by a non-space char
            // - end with ' ' or ':'
            return implicitKey || inFlow || !value.includes('\n') ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
        }
        if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes('\n')) {
            // Where allowed & type not set explicitly, prefer block style for multiline strings
            return blockString(item, ctx, onComment, onChompKeep);
        }
        if (containsDocumentMarker(value)) {
            if (indent === '') {
                ctx.forceBlockIndent = true;
                return blockString(item, ctx, onComment, onChompKeep);
            } else if (implicitKey && indent === indentStep) {
                return quotedString(value, ctx);
            }
        }
        var str = value.replace(/\n+/g, "$&\n".concat(indent));
        // Verify that output will be parsed as a string, as e.g. plain numbers and
        // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
        // and others in v1.1.
        if (actualString) {
            var test = function(tag) {
                var _tag_test;
                return tag.default && tag.tag !== 'tag:yaml.org,2002:str' && ((_tag_test = tag.test) === null || _tag_test === undefined ? undefined : _tag_test.test(str));
            };
            var _ctx_doc_schema = ctx.doc.schema, compat = _ctx_doc_schema.compat, tags = _ctx_doc_schema.tags;
            if (tags.some(test) || (compat === null || compat === undefined ? undefined : compat.some(test))) return quotedString(value, ctx);
        }
        return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString$1(item, ctx, onComment, onChompKeep) {
        var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
        var ss = typeof item.value === 'string' ? item : Object.assign({}, item, {
            value: String(item.value)
        });
        var type = item.type;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            // force double quotes on control characters & unpaired surrogates
            if (RegExp("[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\u{D800}-\u{DFFF}]", "u").test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
        }
        var _stringify = function(_type) {
            switch(_type){
                case Scalar.Scalar.BLOCK_FOLDED:
                case Scalar.Scalar.BLOCK_LITERAL:
                    return implicitKey || inFlow ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                     : blockString(ss, ctx, onComment, onChompKeep);
                case Scalar.Scalar.QUOTE_DOUBLE:
                    return doubleQuotedString(ss.value, ctx);
                case Scalar.Scalar.QUOTE_SINGLE:
                    return singleQuotedString(ss.value, ctx);
                case Scalar.Scalar.PLAIN:
                    return plainString(ss, ctx, onComment, onChompKeep);
                default:
                    return null;
            }
        };
        var res = _stringify(type);
        if (res === null) {
            var _ctx_options = ctx.options, defaultKeyType = _ctx_options.defaultKeyType, defaultStringType = _ctx_options.defaultStringType;
            var t = implicitKey && defaultKeyType || defaultStringType;
            res = _stringify(t);
            if (res === null) throw new Error("Unsupported default string type ".concat(t));
        }
        return res;
    }
    stringifyString.stringifyString = stringifyString$1;
    return stringifyString;
}

function _instanceof$k(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _type_of$w(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredStringify;
function requireStringify() {
    if (hasRequiredStringify) return stringify;
    hasRequiredStringify = 1;
    var anchors = requireAnchors();
    var identity = requireIdentity();
    var stringifyComment = requireStringifyComment();
    var stringifyString = requireStringifyString();
    function createStringifyContext(doc, options) {
        var opt = Object.assign({
            blockQuote: true,
            commentString: stringifyComment.stringifyComment,
            defaultKeyType: null,
            defaultStringType: 'PLAIN',
            directives: null,
            doubleQuotedAsJSON: false,
            doubleQuotedMinMultiLineLength: 40,
            falseStr: 'false',
            flowCollectionPadding: true,
            indentSeq: true,
            lineWidth: 80,
            minContentWidth: 20,
            nullStr: 'null',
            simpleKeys: false,
            singleQuote: null,
            trueStr: 'true',
            verifyAliasOrder: true
        }, doc.schema.toStringOptions, options);
        var inFlow;
        switch(opt.collectionStyle){
            case 'block':
                inFlow = false;
                break;
            case 'flow':
                inFlow = true;
                break;
            default:
                inFlow = null;
        }
        return {
            anchors: new Set(),
            doc: doc,
            flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
            indent: '',
            indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
            inFlow: inFlow,
            options: opt
        };
    }
    function getTagObject(tags, item) {
        if (item.tag) {
            var match = tags.filter(function(t) {
                return t.tag === item.tag;
            });
            var _match_find;
            if (match.length > 0) return (_match_find = match.find(function(t) {
                return t.format === item.format;
            })) !== null && _match_find !== undefined ? _match_find : match[0];
        }
        var tagObj = undefined;
        var obj;
        if (identity.isScalar(item)) {
            obj = item.value;
            var match1 = tags.filter(function(t) {
                var _t_identify;
                return (_t_identify = t.identify) === null || _t_identify === undefined ? undefined : _t_identify.call(t, obj);
            });
            if (match1.length > 1) {
                var testMatch = match1.filter(function(t) {
                    return t.test;
                });
                if (testMatch.length > 0) match1 = testMatch;
            }
            var _match_find1;
            tagObj = (_match_find1 = match1.find(function(t) {
                return t.format === item.format;
            })) !== null && _match_find1 !== undefined ? _match_find1 : match1.find(function(t) {
                return !t.format;
            });
        } else {
            obj = item;
            tagObj = tags.find(function(t) {
                return t.nodeClass && _instanceof$k(obj, t.nodeClass);
            });
        }
        if (!tagObj) {
            var _obj_constructor;
            var _obj_constructor_name;
            var name = (_obj_constructor_name = obj === null || obj === undefined ? undefined : (_obj_constructor = obj.constructor) === null || _obj_constructor === undefined ? undefined : _obj_constructor.name) !== null && _obj_constructor_name !== undefined ? _obj_constructor_name : typeof obj === "undefined" ? "undefined" : _type_of$w(obj);
            throw new Error("Tag not resolved for ".concat(name, " value"));
        }
        return tagObj;
    }
    // needs to be called before value stringifier to allow for circular anchor refs
    function stringifyProps(node, tagObj, param) {
        var anchors$1 = param.anchors, doc = param.doc;
        if (!doc.directives) return '';
        var props = [];
        var anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
        if (anchor && anchors.anchorIsValid(anchor)) {
            anchors$1.add(anchor);
            props.push("&".concat(anchor));
        }
        var tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
        if (tag) props.push(doc.directives.tagString(tag));
        return props.join(' ');
    }
    function stringify$1(item, ctx, onComment, onChompKeep) {
        if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
        if (identity.isAlias(item)) {
            var _ctx_resolvedAliases;
            if (ctx.doc.directives) return item.toString(ctx);
            if ((_ctx_resolvedAliases = ctx.resolvedAliases) === null || _ctx_resolvedAliases === undefined ? undefined : _ctx_resolvedAliases.has(item)) {
                throw new TypeError("Cannot stringify circular structure without alias nodes");
            } else {
                if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
                else ctx.resolvedAliases = new Set([
                    item
                ]);
                item = item.resolve(ctx.doc);
            }
        }
        var tagObj = undefined;
        var node = identity.isNode(item) ? item : ctx.doc.createNode(item, {
            onTagObj: function(o) {
                return tagObj = o;
            }
        });
        if (!tagObj) tagObj = getTagObject(ctx.doc.schema.tags, node);
        var props = stringifyProps(node, tagObj, ctx);
        var _ctx_indentAtStart;
        if (props.length > 0) ctx.indentAtStart = ((_ctx_indentAtStart = ctx.indentAtStart) !== null && _ctx_indentAtStart !== undefined ? _ctx_indentAtStart : 0) + props.length + 1;
        var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
        if (!props) return str;
        return identity.isScalar(node) || str[0] === '{' || str[0] === '[' ? "".concat(props, " ").concat(str) : "".concat(props, "\n").concat(ctx.indent).concat(str);
    }
    stringify.createStringifyContext = createStringifyContext;
    stringify.stringify = stringify$1;
    return stringify;
}

function _type_of$v(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredStringifyPair;
function requireStringifyPair() {
    if (hasRequiredStringifyPair) return stringifyPair;
    hasRequiredStringifyPair = 1;
    var identity = requireIdentity();
    var Scalar = requireScalar();
    var stringify = requireStringify();
    var stringifyComment = requireStringifyComment();
    function stringifyPair$1(param, ctx, onComment, onChompKeep) {
        var key = param.key, value = param.value;
        var allNullValues = ctx.allNullValues, doc = ctx.doc, indent = ctx.indent, indentStep = ctx.indentStep, _ctx_options = ctx.options, commentString = _ctx_options.commentString, indentSeq = _ctx_options.indentSeq, simpleKeys = _ctx_options.simpleKeys;
        var keyComment = identity.isNode(key) && key.comment || null;
        if (simpleKeys) {
            if (keyComment) {
                throw new Error('With simple keys, key nodes cannot have comments');
            }
            if (identity.isCollection(key) || !identity.isNode(key) && (typeof key === "undefined" ? "undefined" : _type_of$v(key)) === 'object') {
                var msg = 'With simple keys, collection cannot be used as a key value';
                throw new Error(msg);
            }
        }
        var explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : (typeof key === "undefined" ? "undefined" : _type_of$v(key)) === 'object'));
        ctx = Object.assign({}, ctx, {
            allNullValues: false,
            implicitKey: !explicitKey && (simpleKeys || !allNullValues),
            indent: indent + indentStep
        });
        var keyCommentDone = false;
        var chompKeep = false;
        var str = stringify.stringify(key, ctx, function() {
            return keyCommentDone = true;
        }, function() {
            return chompKeep = true;
        });
        if (!explicitKey && !ctx.inFlow && str.length > 1024) {
            if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
            explicitKey = true;
        }
        if (ctx.inFlow) {
            if (allNullValues || value == null) {
                if (keyCommentDone && onComment) onComment();
                return str === '' ? '?' : explicitKey ? "? ".concat(str) : str;
            }
        } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
            str = "? ".concat(str);
            if (keyComment && !keyCommentDone) {
                str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
            } else if (chompKeep && onChompKeep) onChompKeep();
            return str;
        }
        if (keyCommentDone) keyComment = null;
        if (explicitKey) {
            if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
            str = "? ".concat(str, "\n").concat(indent, ":");
        } else {
            str = "".concat(str, ":");
            if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        var vsb, vcb, valueComment;
        if (identity.isNode(value)) {
            vsb = !!value.spaceBefore;
            vcb = value.commentBefore;
            valueComment = value.comment;
        } else {
            vsb = false;
            vcb = null;
            valueComment = null;
            if (value && (typeof value === "undefined" ? "undefined" : _type_of$v(value)) === 'object') value = doc.createNode(value);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !keyComment && identity.isScalar(value)) ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
            // If indentSeq === false, consider '- ' as part of indentation where possible
            ctx.indent = ctx.indent.substring(2);
        }
        var valueCommentDone = false;
        var valueStr = stringify.stringify(value, ctx, function() {
            return valueCommentDone = true;
        }, function() {
            return chompKeep = true;
        });
        var ws = ' ';
        if (keyComment || vsb || vcb) {
            ws = vsb ? '\n' : '';
            if (vcb) {
                var cs = commentString(vcb);
                ws += "\n".concat(stringifyComment.indentComment(cs, ctx.indent));
            }
            if (valueStr === '' && !ctx.inFlow) {
                if (ws === '\n') ws = '\n\n';
            } else {
                ws += "\n".concat(ctx.indent);
            }
        } else if (!explicitKey && identity.isCollection(value)) {
            var vs0 = valueStr[0];
            var nl0 = valueStr.indexOf('\n');
            var hasNewline = nl0 !== -1;
            var _ctx_inFlow, _ref;
            var flow = (_ref = (_ctx_inFlow = ctx.inFlow) !== null && _ctx_inFlow !== undefined ? _ctx_inFlow : value.flow) !== null && _ref !== undefined ? _ref : value.items.length === 0;
            if (hasNewline || !flow) {
                var hasPropsLine = false;
                if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                    var sp0 = valueStr.indexOf(' ');
                    if (vs0 === '&' && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === '!') {
                        sp0 = valueStr.indexOf(' ', sp0 + 1);
                    }
                    if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
                }
                if (!hasPropsLine) ws = "\n".concat(ctx.indent);
            }
        } else if (valueStr === '' || valueStr[0] === '\n') {
            ws = '';
        }
        str += ws + valueStr;
        if (ctx.inFlow) {
            if (valueCommentDone && onComment) onComment();
        } else if (valueComment && !valueCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
        } else if (chompKeep && onChompKeep) {
            onChompKeep();
        }
        return str;
    }
    stringifyPair.stringifyPair = stringifyPair$1;
    return stringifyPair;
}

var addPairToJSMap = {};

var log$1 = {};

function _array_like_to_array$g(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$7(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$g(arr);
}
function _iterable_to_array$8(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$7() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array$7(arr) {
    return _array_without_holes$7(arr) || _iterable_to_array$8(arr) || _unsupported_iterable_to_array$g(arr) || _non_iterable_spread$7();
}
function _unsupported_iterable_to_array$g(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$g(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$g(o, minLen);
}
var hasRequiredLog;
function requireLog() {
    if (hasRequiredLog) return log$1;
    hasRequiredLog = 1;
    var node_process = require$$0$4;
    function debug(logLevel) {
        for(var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            messages[_key - 1] = arguments[_key];
        }
        var _console;
        if (logLevel === 'debug') (_console = console).log.apply(_console, _to_consumable_array$7(messages));
    }
    function warn(logLevel, warning) {
        if (logLevel === 'debug' || logLevel === 'warn') {
            if (typeof node_process.emitWarning === 'function') node_process.emitWarning(warning);
            else console.warn(warning);
        }
    }
    log$1.debug = debug;
    log$1.warn = warn;
    return log$1;
}

var merge = {};

function _array_like_to_array$f(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$a(arr) {
    if (Array.isArray(arr)) return arr;
}
function _instanceof$j(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array_limit$9(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$a() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$9(arr, i) {
    return _array_with_holes$a(arr) || _iterable_to_array_limit$9(arr, i) || _unsupported_iterable_to_array$f(arr, i) || _non_iterable_rest$a();
}
function _type_of$u(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$f(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$f(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$f(o, minLen);
}
var hasRequiredMerge;
function requireMerge() {
    if (hasRequiredMerge) return merge;
    hasRequiredMerge = 1;
    var identity = requireIdentity();
    var Scalar = requireScalar();
    // If the value associated with a merge key is a single mapping node, each of
    // its key/value pairs is inserted into the current mapping, unless the key
    // already exists in it. If the value associated with the merge key is a
    // sequence, then this sequence is expected to contain mapping nodes and each
    // of these nodes is merged in turn according to its order in the sequence.
    // Keys in mapping nodes earlier in the sequence override keys specified in
    // later mapping nodes. -- http://yaml.org/type/merge.html
    var MERGE_KEY = '<<';
    var merge$1 = {
        identify: function(value) {
            return value === MERGE_KEY || (typeof value === "undefined" ? "undefined" : _type_of$u(value)) === 'symbol' && value.description === MERGE_KEY;
        },
        default: 'key',
        tag: 'tag:yaml.org,2002:merge',
        test: /^<<$/,
        resolve: function() {
            return Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
                addToJSMap: addMergeToJSMap
            });
        },
        stringify: function() {
            return MERGE_KEY;
        }
    };
    var isMergeKey = function(ctx, key) {
        return (merge$1.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge$1.identify(key.value)) && (ctx === null || ctx === undefined ? undefined : ctx.doc.schema.tags.some(function(tag) {
            return tag.tag === merge$1.tag && tag.default;
        }));
    };
    function addMergeToJSMap(ctx, map, value) {
        value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined, _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        if (identity.isSeq(value)) try {
            for(var _iterator = value.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var it = _step.value;
                mergeValue(ctx, map, it);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        else if (Array.isArray(value)) try {
            for(var _iterator1 = value[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var it1 = _step1.value;
                mergeValue(ctx, map, it1);
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        else mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
        var source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (!identity.isMap(source)) throw new Error('Merge sources must be maps or map aliases');
        var srcMap = source.toJSON(null, ctx, Map);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = srcMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array$9(_step.value, 2), key = _step_value[0], _$value = _step_value[1];
                if (_instanceof$j(map, Map)) {
                    if (!map.has(key)) map.set(key, _$value);
                } else if (_instanceof$j(map, Set)) {
                    map.add(key);
                } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
                    Object.defineProperty(map, key, {
                        value: _$value,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return map;
    }
    merge.addMergeToJSMap = addMergeToJSMap;
    merge.isMergeKey = isMergeKey;
    merge.merge = merge$1;
    return merge;
}

function _instanceof$i(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _type_of$t(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredAddPairToJSMap;
function requireAddPairToJSMap() {
    if (hasRequiredAddPairToJSMap) return addPairToJSMap;
    hasRequiredAddPairToJSMap = 1;
    var log = requireLog();
    var merge = requireMerge();
    var stringify = requireStringify();
    var identity = requireIdentity();
    var toJS = requireToJS();
    function addPairToJSMap$1(ctx, map, param) {
        var key = param.key, value = param.value;
        if (identity.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map, value);
        else if (merge.isMergeKey(ctx, key)) merge.addMergeToJSMap(ctx, map, value);
        else {
            var jsKey = toJS.toJS(key, '', ctx);
            if (_instanceof$i(map, Map)) {
                map.set(jsKey, toJS.toJS(value, jsKey, ctx));
            } else if (_instanceof$i(map, Set)) {
                map.add(jsKey);
            } else {
                var stringKey = stringifyKey(key, jsKey, ctx);
                var jsValue = toJS.toJS(value, stringKey, ctx);
                if (stringKey in map) Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
                else map[stringKey] = jsValue;
            }
        }
        return map;
    }
    function stringifyKey(key, jsKey, ctx) {
        if (jsKey === null) return '';
        if ((typeof jsKey === "undefined" ? "undefined" : _type_of$t(jsKey)) !== 'object') return String(jsKey);
        if (identity.isNode(key) && (ctx === null || ctx === undefined ? undefined : ctx.doc)) {
            var strCtx = stringify.createStringifyContext(ctx.doc, {});
            strCtx.anchors = new Set();
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = ctx.anchors.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var node = _step.value;
                    strCtx.anchors.add(node.anchor);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            strCtx.inFlow = true;
            strCtx.inStringifyKey = true;
            var strKey = key.toString(strCtx);
            if (!ctx.mapKeyWarned) {
                var jsonStr = JSON.stringify(strKey);
                if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
                log.warn(ctx.doc.options.logLevel, "Keys with collection values will be stringified due to JS Object restrictions: ".concat(jsonStr, ". Set mapAsMap: true to use object keys."));
                ctx.mapKeyWarned = true;
            }
            return strKey;
        }
        return JSON.stringify(jsKey);
    }
    addPairToJSMap.addPairToJSMap = addPairToJSMap$1;
    return addPairToJSMap;
}

function _class_call_check$t(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var hasRequiredPair;
function requirePair() {
    if (hasRequiredPair) return Pair;
    hasRequiredPair = 1;
    var createNode = requireCreateNode();
    var stringifyPair = requireStringifyPair();
    var addPairToJSMap = requireAddPairToJSMap();
    var identity = requireIdentity();
    function createPair(key, value, ctx) {
        var k = createNode.createNode(key, undefined, ctx);
        var v = createNode.createNode(value, undefined, ctx);
        return new Pair$1(k, v);
    }
    var Pair$1 = /*#__PURE__*/ function() {
        function Pair(key) {
            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _class_call_check$t(this, Pair);
            Object.defineProperty(this, identity.NODE_TYPE, {
                value: identity.PAIR
            });
            this.key = key;
            this.value = value;
        }
        var _proto = Pair.prototype;
        _proto.clone = function clone(schema) {
            var _this = this, key = _this.key, value = _this.value;
            if (identity.isNode(key)) key = key.clone(schema);
            if (identity.isNode(value)) value = value.clone(schema);
            return new Pair(key, value);
        };
        _proto.toJSON = function toJSON(_, ctx) {
            var pair = (ctx === null || ctx === undefined ? undefined : ctx.mapAsMap) ? new Map() : {};
            return addPairToJSMap.addPairToJSMap(ctx, pair, this);
        };
        _proto.toString = function toString(ctx, onComment, onChompKeep) {
            return (ctx === null || ctx === undefined ? undefined : ctx.doc) ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
        };
        return Pair;
    }();
    Pair.Pair = Pair$1;
    Pair.createPair = createPair;
    return Pair;
}

var Schema = {};

var map = {};

var YAMLMap = {};

var stringifyCollection = {};

var hasRequiredStringifyCollection;
function requireStringifyCollection() {
    if (hasRequiredStringifyCollection) return stringifyCollection;
    hasRequiredStringifyCollection = 1;
    var identity = requireIdentity();
    var stringify = requireStringify();
    var stringifyComment = requireStringifyComment();
    function stringifyCollection$1(collection, ctx, options) {
        var _ctx_inFlow;
        var flow = (_ctx_inFlow = ctx.inFlow) !== null && _ctx_inFlow !== undefined ? _ctx_inFlow : collection.flow;
        var stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
        return stringify(collection, ctx, options);
    }
    function stringifyBlockCollection(param, ctx, param1) {
        var _loop = function(i) {
            var item = items[i];
            var comment = null;
            if (identity.isNode(item)) {
                if (!chompKeep && item.spaceBefore) lines.push('');
                addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
                if (item.comment) comment = item.comment;
            } else if (identity.isPair(item)) {
                var ik = identity.isNode(item.key) ? item.key : null;
                if (ik) {
                    if (!chompKeep && ik.spaceBefore) lines.push('');
                    addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
                }
            }
            chompKeep = false;
            var str = stringify.stringify(item, itemCtx, function() {
                return comment = null;
            }, function() {
                return chompKeep = true;
            });
            if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
            if (chompKeep && comment) chompKeep = false;
            lines.push(blockItemPrefix + str);
        };
        var comment = param.comment, items = param.items, blockItemPrefix = param1.blockItemPrefix, flowChars = param1.flowChars, itemIndent = param1.itemIndent, onChompKeep = param1.onChompKeep, onComment = param1.onComment;
        var indent = ctx.indent, commentString = ctx.options.commentString;
        var itemCtx = Object.assign({}, ctx, {
            indent: itemIndent,
            type: null
        });
        var chompKeep = false; // flag for the preceding node's status
        var lines = [];
        for(var i = 0; i < items.length; ++i)_loop(i);
        var str;
        if (lines.length === 0) {
            str = flowChars.start + flowChars.end;
        } else {
            str = lines[0];
            for(var i1 = 1; i1 < lines.length; ++i1){
                var line = lines[i1];
                str += line ? "\n".concat(indent).concat(line) : '\n';
            }
        }
        if (comment) {
            str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
            if (onComment) onComment();
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str;
    }
    function stringifyFlowCollection(param, ctx, param1) {
        var _loop = function(i) {
            var item = items[i];
            var comment = null;
            if (identity.isNode(item)) {
                if (item.spaceBefore) lines.push('');
                addCommentBefore(ctx, lines, item.commentBefore, false);
                if (item.comment) comment = item.comment;
            } else if (identity.isPair(item)) {
                var ik = identity.isNode(item.key) ? item.key : null;
                if (ik) {
                    if (ik.spaceBefore) lines.push('');
                    addCommentBefore(ctx, lines, ik.commentBefore, false);
                    if (ik.comment) reqNewline = true;
                }
                var iv = identity.isNode(item.value) ? item.value : null;
                if (iv) {
                    if (iv.comment) comment = iv.comment;
                    if (iv.commentBefore) reqNewline = true;
                } else if (item.value == null && (ik === null || ik === undefined ? undefined : ik.comment)) {
                    comment = ik.comment;
                }
            }
            if (comment) reqNewline = true;
            var str = stringify.stringify(item, itemCtx, function() {
                return comment = null;
            });
            if (i < items.length - 1) str += ',';
            if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
            if (!reqNewline && (lines.length > linesAtValue || str.includes('\n'))) reqNewline = true;
            lines.push(str);
            linesAtValue = lines.length;
        };
        var items = param.items, flowChars = param1.flowChars, itemIndent = param1.itemIndent;
        var indent = ctx.indent, indentStep = ctx.indentStep, fcPadding = ctx.flowCollectionPadding, commentString = ctx.options.commentString;
        itemIndent += indentStep;
        var itemCtx = Object.assign({}, ctx, {
            indent: itemIndent,
            inFlow: true,
            type: null
        });
        var reqNewline = false;
        var linesAtValue = 0;
        var lines = [];
        for(var i = 0; i < items.length; ++i)_loop(i);
        var start = flowChars.start, end = flowChars.end;
        if (lines.length === 0) {
            return start + end;
        } else {
            if (!reqNewline) {
                var len = lines.reduce(function(sum, line) {
                    return sum + line.length + 2;
                }, 2);
                reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
            }
            if (reqNewline) {
                var str = start;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var line = _step.value;
                        str += line ? "\n".concat(indentStep).concat(indent).concat(line) : '\n';
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return "".concat(str, "\n").concat(indent).concat(end);
            } else {
                return "".concat(start).concat(fcPadding).concat(lines.join(' ')).concat(fcPadding).concat(end);
            }
        }
    }
    function addCommentBefore(param, lines, comment, chompKeep) {
        var indent = param.indent, commentString = param.options.commentString;
        if (comment && chompKeep) comment = comment.replace(/^\n+/, '');
        if (comment) {
            var ic = stringifyComment.indentComment(commentString(comment), indent);
            lines.push(ic.trimStart()); // Avoid double indent on first line
        }
    }
    stringifyCollection.stringifyCollection = stringifyCollection$1;
    return stringifyCollection;
}

function _array_like_to_array$e(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$9(arr) {
    if (Array.isArray(arr)) return arr;
}
function _assert_this_initialized$d(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$d(_this, derived, args) {
    derived = _get_prototype_of$d(derived);
    return _possible_constructor_return$d(_this, _is_native_reflect_construct$d() ? Reflect.construct(derived, args, _get_prototype_of$d(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$s(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$8(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$8(Constructor, protoProps, staticProps) {
    _defineProperties$8(Constructor, staticProps);
    return Constructor;
}
function _get_prototype_of$d(o) {
    _get_prototype_of$d = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$d(o);
}
function _inherits$d(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$d(subClass, superClass);
}
function _instanceof$h(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array_limit$8(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$9() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$d(self, call) {
    if (call && (_type_of$s(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$d(self);
}
function _set_prototype_of$d(o, p) {
    _set_prototype_of$d = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$d(o, p);
}
function _sliced_to_array$8(arr, i) {
    return _array_with_holes$9(arr) || _iterable_to_array_limit$8(arr, i) || _unsupported_iterable_to_array$e(arr, i) || _non_iterable_rest$9();
}
function _type_of$s(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$e(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$e(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$e(o, minLen);
}
function _is_native_reflect_construct$d() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$d = function() {
        return !!result;
    })();
}
var hasRequiredYAMLMap;
function requireYAMLMap() {
    if (hasRequiredYAMLMap) return YAMLMap;
    hasRequiredYAMLMap = 1;
    var stringifyCollection = requireStringifyCollection();
    var addPairToJSMap = requireAddPairToJSMap();
    var Collection = requireCollection();
    var identity = requireIdentity();
    var Pair = requirePair();
    var Scalar = requireScalar();
    function findPair(items, key) {
        var k = identity.isScalar(key) ? key.value : key;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var it = _step.value;
                if (identity.isPair(it)) {
                    if (it.key === key || it.key === k) return it;
                    if (identity.isScalar(it.key) && it.key.value === k) return it;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return undefined;
    }
    var YAMLMap$1 = /*#__PURE__*/ function(_Collection_Collection) {
        _inherits$d(YAMLMap, _Collection_Collection);
        function YAMLMap(schema) {
            _class_call_check$s(this, YAMLMap);
            var _this;
            _this = _call_super$d(this, YAMLMap, [
                identity.MAP,
                schema
            ]);
            _this.items = [];
            return _this;
        }
        var _proto = YAMLMap.prototype;
        /**
	     * Adds a value to the collection.
	     *
	     * @param overwrite - If not set `true`, using a key that is already in the
	     *   collection will throw. Otherwise, overwrites the previous value.
	     */ _proto.add = function add(pair, overwrite) {
            var _this_schema;
            var _pair;
            if (identity.isPair(pair)) _pair = pair;
            else if (!pair || (typeof pair === "undefined" ? "undefined" : _type_of$s(pair)) !== 'object' || !('key' in pair)) {
                // In TypeScript, this never happens.
                _pair = new Pair.Pair(pair, pair === null || pair === undefined ? undefined : pair.value);
            } else _pair = new Pair.Pair(pair.key, pair.value);
            var prev = findPair(this.items, _pair.key);
            var sortEntries = (_this_schema = this.schema) === null || _this_schema === undefined ? undefined : _this_schema.sortMapEntries;
            if (prev) {
                if (!overwrite) throw new Error("Key ".concat(_pair.key, " already set"));
                // For scalars, keep the old node & its comments and anchors
                if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value)) prev.value.value = _pair.value;
                else prev.value = _pair.value;
            } else if (sortEntries) {
                var i = this.items.findIndex(function(item) {
                    return sortEntries(_pair, item) < 0;
                });
                if (i === -1) this.items.push(_pair);
                else this.items.splice(i, 0, _pair);
            } else {
                this.items.push(_pair);
            }
        };
        _proto.delete = function _delete(key) {
            var it = findPair(this.items, key);
            if (!it) return false;
            var del = this.items.splice(this.items.indexOf(it), 1);
            return del.length > 0;
        };
        _proto.get = function get(key, keepScalar) {
            var it = findPair(this.items, key);
            var node = it === null || it === undefined ? undefined : it.value;
            var _ref;
            return (_ref = !keepScalar && identity.isScalar(node) ? node.value : node) !== null && _ref !== undefined ? _ref : undefined;
        };
        _proto.has = function has(key) {
            return !!findPair(this.items, key);
        };
        _proto.set = function set(key, value) {
            this.add(new Pair.Pair(key, value), true);
        };
        /**
	     * @param ctx - Conversion context, originally set in Document#toJS()
	     * @param {Class} Type - If set, forces the returned collection type
	     * @returns Instance of Type, Map, or Object
	     */ _proto.toJSON = function toJSON(_, ctx, Type) {
            var map = Type ? new Type() : (ctx === null || ctx === undefined ? undefined : ctx.mapAsMap) ? new Map() : {};
            if (ctx === null || ctx === undefined ? undefined : ctx.onCreate) ctx.onCreate(map);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var item = _step.value;
                    addPairToJSMap.addPairToJSMap(ctx, map, item);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return map;
        };
        _proto.toString = function toString(ctx, onComment, onChompKeep) {
            if (!ctx) return JSON.stringify(this);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var item = _step.value;
                    if (!identity.isPair(item)) throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {
                allNullValues: true
            });
            return stringifyCollection.stringifyCollection(this, ctx, {
                blockItemPrefix: '',
                flowChars: {
                    start: '{',
                    end: '}'
                },
                itemIndent: ctx.indent || '',
                onChompKeep: onChompKeep,
                onComment: onComment
            });
        };
        /**
	     * A generic collection parsing method that can be extended
	     * to other node classes that inherit from YAMLMap
	     */ YAMLMap.from = function from(schema, obj, ctx) {
            var keepUndefined = ctx.keepUndefined, replacer = ctx.replacer;
            var map = new this(schema);
            var add = function(key, value) {
                if (typeof replacer === 'function') value = replacer.call(obj, key, value);
                else if (Array.isArray(replacer) && !replacer.includes(key)) return;
                if (value !== undefined || keepUndefined) map.items.push(Pair.createPair(key, value, ctx));
            };
            if (_instanceof$h(obj, Map)) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _step_value = _sliced_to_array$8(_step.value, 2), key = _step_value[0], value = _step_value[1];
                        add(key, value);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            } else if (obj && (typeof obj === "undefined" ? "undefined" : _type_of$s(obj)) === 'object') {
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = Object.keys(obj)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var key1 = _step1.value;
                        add(key1, obj[key1]);
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            }
            if (typeof schema.sortMapEntries === 'function') {
                map.items.sort(schema.sortMapEntries);
            }
            return map;
        };
        _create_class$8(YAMLMap, null, [
            {
                key: "tagName",
                get: function get() {
                    return 'tag:yaml.org,2002:map';
                }
            }
        ]);
        return YAMLMap;
    }(Collection.Collection);
    YAMLMap.YAMLMap = YAMLMap$1;
    YAMLMap.findPair = findPair;
    return YAMLMap;
}

var hasRequiredMap;
function requireMap() {
    if (hasRequiredMap) return map;
    hasRequiredMap = 1;
    var identity = requireIdentity();
    var YAMLMap = requireYAMLMap();
    var map$1 = {
        collection: 'map',
        default: true,
        nodeClass: YAMLMap.YAMLMap,
        tag: 'tag:yaml.org,2002:map',
        resolve: function resolve(map, onError) {
            if (!identity.isMap(map)) onError('Expected a mapping for this tag');
            return map;
        },
        createNode: function(schema, obj, ctx) {
            return YAMLMap.YAMLMap.from(schema, obj, ctx);
        }
    };
    map.map = map$1;
    return map;
}

var seq = {};

var YAMLSeq = {};

function _assert_this_initialized$c(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$c(_this, derived, args) {
    derived = _get_prototype_of$c(derived);
    return _possible_constructor_return$c(_this, _is_native_reflect_construct$c() ? Reflect.construct(derived, args, _get_prototype_of$c(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$r(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$7(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$7(Constructor, protoProps, staticProps) {
    _defineProperties$7(Constructor, staticProps);
    return Constructor;
}
function _get_prototype_of$c(o) {
    _get_prototype_of$c = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$c(o);
}
function _inherits$c(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$c(subClass, superClass);
}
function _instanceof$g(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _possible_constructor_return$c(self, call) {
    if (call && (_type_of$r(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$c(self);
}
function _set_prototype_of$c(o, p) {
    _set_prototype_of$c = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$c(o, p);
}
function _type_of$r(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$c() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$c = function() {
        return !!result;
    })();
}
var hasRequiredYAMLSeq;
function requireYAMLSeq() {
    if (hasRequiredYAMLSeq) return YAMLSeq;
    hasRequiredYAMLSeq = 1;
    var createNode = requireCreateNode();
    var stringifyCollection = requireStringifyCollection();
    var Collection = requireCollection();
    var identity = requireIdentity();
    var Scalar = requireScalar();
    var toJS = requireToJS();
    var YAMLSeq$1 = /*#__PURE__*/ function(_Collection_Collection) {
        _inherits$c(YAMLSeq, _Collection_Collection);
        function YAMLSeq(schema) {
            _class_call_check$r(this, YAMLSeq);
            var _this;
            _this = _call_super$c(this, YAMLSeq, [
                identity.SEQ,
                schema
            ]);
            _this.items = [];
            return _this;
        }
        var _proto = YAMLSeq.prototype;
        _proto.add = function add(value) {
            this.items.push(value);
        };
        /**
	     * Removes a value from the collection.
	     *
	     * `key` must contain a representation of an integer for this to succeed.
	     * It may be wrapped in a `Scalar`.
	     *
	     * @returns `true` if the item was found and removed.
	     */ _proto.delete = function _delete(key) {
            var idx = asItemIndex(key);
            if (typeof idx !== 'number') return false;
            var del = this.items.splice(idx, 1);
            return del.length > 0;
        };
        _proto.get = function get(key, keepScalar) {
            var idx = asItemIndex(key);
            if (typeof idx !== 'number') return undefined;
            var it = this.items[idx];
            return !keepScalar && identity.isScalar(it) ? it.value : it;
        };
        /**
	     * Checks if the collection includes a value with the key `key`.
	     *
	     * `key` must contain a representation of an integer for this to succeed.
	     * It may be wrapped in a `Scalar`.
	     */ _proto.has = function has(key) {
            var idx = asItemIndex(key);
            return typeof idx === 'number' && idx < this.items.length;
        };
        /**
	     * Sets a value in this collection. For `!!set`, `value` needs to be a
	     * boolean to add/remove the item from the set.
	     *
	     * If `key` does not contain a representation of an integer, this will throw.
	     * It may be wrapped in a `Scalar`.
	     */ _proto.set = function set(key, value) {
            var idx = asItemIndex(key);
            if (typeof idx !== 'number') throw new Error("Expected a valid index, not ".concat(key, "."));
            var prev = this.items[idx];
            if (identity.isScalar(prev) && Scalar.isScalarValue(value)) prev.value = value;
            else this.items[idx] = value;
        };
        _proto.toJSON = function toJSON(_, ctx) {
            var seq = [];
            if (ctx === null || ctx === undefined ? undefined : ctx.onCreate) ctx.onCreate(seq);
            var i = 0;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var item = _step.value;
                    seq.push(toJS.toJS(item, String(i++), ctx));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return seq;
        };
        _proto.toString = function toString(ctx, onComment, onChompKeep) {
            if (!ctx) return JSON.stringify(this);
            return stringifyCollection.stringifyCollection(this, ctx, {
                blockItemPrefix: '- ',
                flowChars: {
                    start: '[',
                    end: ']'
                },
                itemIndent: (ctx.indent || '') + '  ',
                onChompKeep: onChompKeep,
                onComment: onComment
            });
        };
        YAMLSeq.from = function from(schema, obj, ctx) {
            var replacer = ctx.replacer;
            var seq = new this(schema);
            if (obj && Symbol.iterator in Object(obj)) {
                var i = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var it = _step.value;
                        if (typeof replacer === 'function') {
                            var key = _instanceof$g(obj, Set) ? it : String(i++);
                            it = replacer.call(obj, key, it);
                        }
                        seq.items.push(createNode.createNode(it, undefined, ctx));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return seq;
        };
        _create_class$7(YAMLSeq, null, [
            {
                key: "tagName",
                get: function get() {
                    return 'tag:yaml.org,2002:seq';
                }
            }
        ]);
        return YAMLSeq;
    }(Collection.Collection);
    function asItemIndex(key) {
        var idx = identity.isScalar(key) ? key.value : key;
        if (idx && typeof idx === 'string') idx = Number(idx);
        return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    YAMLSeq.YAMLSeq = YAMLSeq$1;
    return YAMLSeq;
}

var hasRequiredSeq;
function requireSeq() {
    if (hasRequiredSeq) return seq;
    hasRequiredSeq = 1;
    var identity = requireIdentity();
    var YAMLSeq = requireYAMLSeq();
    var seq$1 = {
        collection: 'seq',
        default: true,
        nodeClass: YAMLSeq.YAMLSeq,
        tag: 'tag:yaml.org,2002:seq',
        resolve: function resolve(seq, onError) {
            if (!identity.isSeq(seq)) onError('Expected a sequence for this tag');
            return seq;
        },
        createNode: function(schema, obj, ctx) {
            return YAMLSeq.YAMLSeq.from(schema, obj, ctx);
        }
    };
    seq.seq = seq$1;
    return seq;
}

var string = {};

var hasRequiredString;
function requireString() {
    if (hasRequiredString) return string;
    hasRequiredString = 1;
    var stringifyString = requireStringifyString();
    var string$1 = {
        identify: function(value) {
            return typeof value === 'string';
        },
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: function(str) {
            return str;
        },
        stringify: function stringify(item, ctx, onComment, onChompKeep) {
            ctx = Object.assign({
                actualString: true
            }, ctx);
            return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
        }
    };
    string.string = string$1;
    return string;
}

var tags = {};

var _null = {};

var hasRequired_null;
function require_null() {
    if (hasRequired_null) return _null;
    hasRequired_null = 1;
    var Scalar = requireScalar();
    var nullTag = {
        identify: function(value) {
            return value == null;
        },
        createNode: function() {
            return new Scalar.Scalar(null);
        },
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: function() {
            return new Scalar.Scalar(null);
        },
        stringify: function(param, ctx) {
            var source = param.source;
            return typeof source === 'string' && nullTag.test.test(source) ? source : ctx.options.nullStr;
        }
    };
    _null.nullTag = nullTag;
    return _null;
}

var bool$1 = {};

var hasRequiredBool$1;
function requireBool$1() {
    if (hasRequiredBool$1) return bool$1;
    hasRequiredBool$1 = 1;
    var Scalar = requireScalar();
    var boolTag = {
        identify: function(value) {
            return typeof value === 'boolean';
        },
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: function(str) {
            return new Scalar.Scalar(str[0] === 't' || str[0] === 'T');
        },
        stringify: function stringify(param, ctx) {
            var source = param.source, value = param.value;
            if (source && boolTag.test.test(source)) {
                var sv = source[0] === 't' || source[0] === 'T';
                if (value === sv) return source;
            }
            return value ? ctx.options.trueStr : ctx.options.falseStr;
        }
    };
    bool$1.boolTag = boolTag;
    return bool$1;
}

var float$1 = {};

var stringifyNumber = {};

function _type_of$q(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredStringifyNumber;
function requireStringifyNumber() {
    if (hasRequiredStringifyNumber) return stringifyNumber;
    hasRequiredStringifyNumber = 1;
    function stringifyNumber$1(param) {
        var format = param.format, minFractionDigits = param.minFractionDigits, tag = param.tag, value = param.value;
        if ((typeof value === "undefined" ? "undefined" : _type_of$q(value)) === 'bigint') return String(value);
        var num = typeof value === 'number' ? value : Number(value);
        if (!isFinite(num)) return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
        var n = JSON.stringify(value);
        if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
            var i = n.indexOf('.');
            if (i < 0) {
                i = n.length;
                n += '.';
            }
            var d = minFractionDigits - (n.length - i - 1);
            while(d-- > 0)n += '0';
        }
        return n;
    }
    stringifyNumber.stringifyNumber = stringifyNumber$1;
    return stringifyNumber;
}

var hasRequiredFloat$1;
function requireFloat$1() {
    if (hasRequiredFloat$1) return float$1;
    hasRequiredFloat$1 = 1;
    var Scalar = requireScalar();
    var stringifyNumber = requireStringifyNumber();
    var floatNaN = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: function(str) {
            return str.slice(-3).toLowerCase() === 'nan' ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        },
        stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'EXP',
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: function(str) {
            return parseFloat(str);
        },
        stringify: function stringify(node) {
            var num = Number(node.value);
            return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
        }
    };
    var float = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
        resolve: function resolve(str) {
            var node = new Scalar.Scalar(parseFloat(str));
            var dot = str.indexOf('.');
            if (dot !== -1 && str[str.length - 1] === '0') node.minFractionDigits = str.length - dot - 1;
            return node;
        },
        stringify: stringifyNumber.stringifyNumber
    };
    float$1.float = float;
    float$1.floatExp = floatExp;
    float$1.floatNaN = floatNaN;
    return float$1;
}

var int$1 = {};

function _type_of$p(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredInt$1;
function requireInt$1() {
    if (hasRequiredInt$1) return int$1;
    hasRequiredInt$1 = 1;
    var stringifyNumber = requireStringifyNumber();
    var intIdentify = function(value) {
        return (typeof value === "undefined" ? "undefined" : _type_of$p(value)) === 'bigint' || Number.isInteger(value);
    };
    var intResolve = function(str, offset, radix, param) {
        var intAsBigInt = param.intAsBigInt;
        return intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    };
    function intStringify(node, radix, prefix) {
        var value = node.value;
        if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
        return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
        identify: function(value) {
            return intIdentify(value) && value >= 0;
        },
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'OCT',
        test: /^0o[0-7]+$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 2, 8, opt);
        },
        stringify: function(node) {
            return intStringify(node, 8, '0o');
        }
    };
    var int = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^[-+]?[0-9]+$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 0, 10, opt);
        },
        stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
        identify: function(value) {
            return intIdentify(value) && value >= 0;
        },
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'HEX',
        test: /^0x[0-9a-fA-F]+$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 2, 16, opt);
        },
        stringify: function(node) {
            return intStringify(node, 16, '0x');
        }
    };
    int$1.int = int;
    int$1.intHex = intHex;
    int$1.intOct = intOct;
    return int$1;
}

var schema$2 = {};

var hasRequiredSchema$3;
function requireSchema$3() {
    if (hasRequiredSchema$3) return schema$2;
    hasRequiredSchema$3 = 1;
    var map = requireMap();
    var _null = require_null();
    var seq = requireSeq();
    var string = requireString();
    var bool = requireBool$1();
    var float = requireFloat$1();
    var int = requireInt$1();
    var schema = [
        map.map,
        seq.seq,
        string.string,
        _null.nullTag,
        bool.boolTag,
        int.intOct,
        int.int,
        int.intHex,
        float.floatNaN,
        float.floatExp,
        float.float
    ];
    schema$2.schema = schema;
    return schema$2;
}

var schema$1 = {};

function _type_of$o(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredSchema$2;
function requireSchema$2() {
    if (hasRequiredSchema$2) return schema$1;
    hasRequiredSchema$2 = 1;
    var Scalar = requireScalar();
    var map = requireMap();
    var seq = requireSeq();
    function intIdentify(value) {
        return (typeof value === "undefined" ? "undefined" : _type_of$o(value)) === 'bigint' || Number.isInteger(value);
    }
    var stringifyJSON = function(param) {
        var value = param.value;
        return JSON.stringify(value);
    };
    var jsonScalars = [
        {
            identify: function(value) {
                return typeof value === 'string';
            },
            default: true,
            tag: 'tag:yaml.org,2002:str',
            resolve: function(str) {
                return str;
            },
            stringify: stringifyJSON
        },
        {
            identify: function(value) {
                return value == null;
            },
            createNode: function() {
                return new Scalar.Scalar(null);
            },
            default: true,
            tag: 'tag:yaml.org,2002:null',
            test: /^null$/,
            resolve: function() {
                return null;
            },
            stringify: stringifyJSON
        },
        {
            identify: function(value) {
                return typeof value === 'boolean';
            },
            default: true,
            tag: 'tag:yaml.org,2002:bool',
            test: /^true$|^false$/,
            resolve: function(str) {
                return str === 'true';
            },
            stringify: stringifyJSON
        },
        {
            identify: intIdentify,
            default: true,
            tag: 'tag:yaml.org,2002:int',
            test: /^-?(?:0|[1-9][0-9]*)$/,
            resolve: function(str, _onError, param) {
                var intAsBigInt = param.intAsBigInt;
                return intAsBigInt ? BigInt(str) : parseInt(str, 10);
            },
            stringify: function(param) {
                var value = param.value;
                return intIdentify(value) ? value.toString() : JSON.stringify(value);
            }
        },
        {
            identify: function(value) {
                return typeof value === 'number';
            },
            default: true,
            tag: 'tag:yaml.org,2002:float',
            test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
            resolve: function(str) {
                return parseFloat(str);
            },
            stringify: stringifyJSON
        }
    ];
    var jsonError = {
        default: true,
        tag: '',
        test: /^/,
        resolve: function resolve(str, onError) {
            onError("Unresolved plain scalar ".concat(JSON.stringify(str)));
            return str;
        }
    };
    var schema = [
        map.map,
        seq.seq
    ].concat(jsonScalars, jsonError);
    schema$1.schema = schema;
    return schema$1;
}

var binary = {};

function _instanceof$f(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var hasRequiredBinary;
function requireBinary() {
    if (hasRequiredBinary) return binary;
    hasRequiredBinary = 1;
    var node_buffer = require$$0$5;
    var Scalar = requireScalar();
    var stringifyString = requireStringifyString();
    var binary$1 = {
        identify: function(value) {
            return _instanceof$f(value, Uint8Array);
        },
        default: false,
        tag: 'tag:yaml.org,2002:binary',
        /**
	     * Returns a Buffer in node and an Uint8Array in browsers
	     *
	     * To use the resulting buffer as an image, you'll want to do something like:
	     *
	     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
	     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
	     */ resolve: function resolve(src, onError) {
            if (typeof node_buffer.Buffer === 'function') {
                return node_buffer.Buffer.from(src, 'base64');
            } else if (typeof atob === 'function') {
                // On IE 11, atob() can't handle newlines
                var str = atob(src.replace(/[\n\r]/g, ''));
                var buffer = new Uint8Array(str.length);
                for(var i = 0; i < str.length; ++i)buffer[i] = str.charCodeAt(i);
                return buffer;
            } else {
                onError('This environment does not support reading binary tags; either Buffer or atob is required');
                return src;
            }
        },
        stringify: function stringify(param, ctx, onComment, onChompKeep) {
            var comment = param.comment, type = param.type, value = param.value;
            var buf = value; // checked earlier by binary.identify()
            var str;
            if (typeof node_buffer.Buffer === 'function') {
                str = _instanceof$f(buf, node_buffer.Buffer) ? buf.toString('base64') : node_buffer.Buffer.from(buf.buffer).toString('base64');
            } else if (typeof btoa === 'function') {
                var s = '';
                for(var i = 0; i < buf.length; ++i)s += String.fromCharCode(buf[i]);
                str = btoa(s);
            } else {
                throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
            }
            if (!type) type = Scalar.Scalar.BLOCK_LITERAL;
            if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
                var lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
                var n = Math.ceil(str.length / lineWidth);
                var lines = new Array(n);
                for(var i1 = 0, o = 0; i1 < n; ++i1, o += lineWidth){
                    lines[i1] = str.substr(o, lineWidth);
                }
                str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
            }
            return stringifyString.stringifyString({
                comment: comment,
                type: type,
                value: str
            }, ctx, onComment, onChompKeep);
        }
    };
    binary.binary = binary$1;
    return binary;
}

var omap = {};

var pairs = {};

function _instanceof$e(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var hasRequiredPairs;
function requirePairs() {
    if (hasRequiredPairs) return pairs;
    hasRequiredPairs = 1;
    var identity = requireIdentity();
    var Pair = requirePair();
    var Scalar = requireScalar();
    var YAMLSeq = requireYAMLSeq();
    function resolvePairs(seq, onError) {
        if (identity.isSeq(seq)) {
            for(var i = 0; i < seq.items.length; ++i){
                var item = seq.items[i];
                if (identity.isPair(item)) continue;
                else if (identity.isMap(item)) {
                    if (item.items.length > 1) onError('Each pair must have its own sequence indicator');
                    var pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                    if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.key.commentBefore) : item.commentBefore;
                    if (item.comment) {
                        var _pair_value;
                        var cn = (_pair_value = pair.value) !== null && _pair_value !== undefined ? _pair_value : pair.key;
                        cn.comment = cn.comment ? "".concat(item.comment, "\n").concat(cn.comment) : item.comment;
                    }
                    item = pair;
                }
                seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
            }
        } else onError('Expected a sequence for this tag');
        return seq;
    }
    function createPairs(schema, iterable, ctx) {
        var replacer = ctx.replacer;
        var pairs = new YAMLSeq.YAMLSeq(schema);
        pairs.tag = 'tag:yaml.org,2002:pairs';
        var i = 0;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        if (iterable && Symbol.iterator in Object(iterable)) try {
            for(var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var it = _step.value;
                if (typeof replacer === 'function') it = replacer.call(iterable, String(i++), it);
                var key = void 0, value = void 0;
                if (Array.isArray(it)) {
                    if (it.length === 2) {
                        key = it[0];
                        value = it[1];
                    } else throw new TypeError("Expected [key, value] tuple: ".concat(it));
                } else if (it && _instanceof$e(it, Object)) {
                    var keys = Object.keys(it);
                    if (keys.length === 1) {
                        key = keys[0];
                        value = it[key];
                    } else {
                        throw new TypeError("Expected tuple with one key, not ".concat(keys.length, " keys"));
                    }
                } else {
                    key = it;
                }
                pairs.items.push(Pair.createPair(key, value, ctx));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return pairs;
    }
    var pairs$1 = {
        collection: 'seq',
        default: false,
        tag: 'tag:yaml.org,2002:pairs',
        resolve: resolvePairs,
        createNode: createPairs
    };
    pairs.createPairs = createPairs;
    pairs.pairs = pairs$1;
    pairs.resolvePairs = resolvePairs;
    return pairs;
}

function _assert_this_initialized$b(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$b(_this, derived, args) {
    derived = _get_prototype_of$b(derived);
    return _possible_constructor_return$b(_this, _is_native_reflect_construct$b() ? Reflect.construct(derived, [], _get_prototype_of$b(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$q(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get$1(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$1 = Reflect.get;
    } else {
        _get$1 = function get(target, property, receiver) {
            var base = _super_prop_base$1(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get$1(target, property, receiver || target);
}
function _get_prototype_of$b(o) {
    _get_prototype_of$b = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$b(o);
}
function _inherits$b(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$b(subClass, superClass);
}
function _instanceof$d(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _possible_constructor_return$b(self, call) {
    if (call && (_type_of$n(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$b(self);
}
function _set_prototype_of$b(o, p) {
    _set_prototype_of$b = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$b(o, p);
}
function _super_prop_base$1(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of$b(object);
        if (object === null) break;
    }
    return object;
}
function _type_of$n(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$b() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$b = function() {
        return !!result;
    })();
}
var hasRequiredOmap;
function requireOmap() {
    if (hasRequiredOmap) return omap;
    hasRequiredOmap = 1;
    var identity = requireIdentity();
    var toJS = requireToJS();
    var YAMLMap = requireYAMLMap();
    var YAMLSeq = requireYAMLSeq();
    var pairs = requirePairs();
    var YAMLOMap = /*#__PURE__*/ function(_YAMLSeq_YAMLSeq) {
        _inherits$b(YAMLOMap, _YAMLSeq_YAMLSeq);
        function YAMLOMap() {
            _class_call_check$q(this, YAMLOMap);
            var _this;
            _this = _call_super$b(this, YAMLOMap);
            _this.add = YAMLMap.YAMLMap.prototype.add.bind(_this);
            _this.delete = YAMLMap.YAMLMap.prototype.delete.bind(_this);
            _this.get = YAMLMap.YAMLMap.prototype.get.bind(_this);
            _this.has = YAMLMap.YAMLMap.prototype.has.bind(_this);
            _this.set = YAMLMap.YAMLMap.prototype.set.bind(_this);
            _this.tag = YAMLOMap.tag;
            return _this;
        }
        var _proto = YAMLOMap.prototype;
        /**
	     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
	     * but TypeScript won't allow widening the signature of a child method.
	     */ _proto.toJSON = function toJSON(_, ctx) {
            if (!ctx) return _get$1(_get_prototype_of$b(YAMLOMap.prototype), "toJSON", this).call(this, _);
            var map = new Map();
            if (ctx === null || ctx === undefined ? undefined : ctx.onCreate) ctx.onCreate(map);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var pair = _step.value;
                    var key = void 0, value = void 0;
                    if (identity.isPair(pair)) {
                        key = toJS.toJS(pair.key, '', ctx);
                        value = toJS.toJS(pair.value, key, ctx);
                    } else {
                        key = toJS.toJS(pair, '', ctx);
                    }
                    if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
                    map.set(key, value);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return map;
        };
        YAMLOMap.from = function from(schema, iterable, ctx) {
            var pairs$1 = pairs.createPairs(schema, iterable, ctx);
            var omap = new this();
            omap.items = pairs$1.items;
            return omap;
        };
        return YAMLOMap;
    }(YAMLSeq.YAMLSeq);
    YAMLOMap.tag = 'tag:yaml.org,2002:omap';
    var omap$1 = {
        collection: 'seq',
        identify: function(value) {
            return _instanceof$d(value, Map);
        },
        nodeClass: YAMLOMap,
        default: false,
        tag: 'tag:yaml.org,2002:omap',
        resolve: function resolve(seq, onError) {
            var pairs$1 = pairs.resolvePairs(seq, onError);
            var seenKeys = [];
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = pairs$1.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key = _step.value.key;
                    if (identity.isScalar(key)) {
                        if (seenKeys.includes(key.value)) {
                            onError("Ordered maps must not include duplicate keys: ".concat(key.value));
                        } else {
                            seenKeys.push(key.value);
                        }
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return Object.assign(new YAMLOMap(), pairs$1);
        },
        createNode: function(schema, iterable, ctx) {
            return YAMLOMap.from(schema, iterable, ctx);
        }
    };
    omap.YAMLOMap = YAMLOMap;
    omap.omap = omap$1;
    return omap;
}

var schema = {};

var bool = {};

var hasRequiredBool;
function requireBool() {
    if (hasRequiredBool) return bool;
    hasRequiredBool = 1;
    var Scalar = requireScalar();
    function boolStringify(param, ctx) {
        var value = param.value, source = param.source;
        var boolObj = value ? trueTag : falseTag;
        if (source && boolObj.test.test(source)) return source;
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
        identify: function(value) {
            return value === true;
        },
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: function() {
            return new Scalar.Scalar(true);
        },
        stringify: boolStringify
    };
    var falseTag = {
        identify: function(value) {
            return value === false;
        },
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
        resolve: function() {
            return new Scalar.Scalar(false);
        },
        stringify: boolStringify
    };
    bool.falseTag = falseTag;
    bool.trueTag = trueTag;
    return bool;
}

var float = {};

var hasRequiredFloat;
function requireFloat() {
    if (hasRequiredFloat) return float;
    hasRequiredFloat = 1;
    var Scalar = requireScalar();
    var stringifyNumber = requireStringifyNumber();
    var floatNaN = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: function(str) {
            return str.slice(-3).toLowerCase() === 'nan' ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        },
        stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'EXP',
        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: function(str) {
            return parseFloat(str.replace(/_/g, ''));
        },
        stringify: function stringify(node) {
            var num = Number(node.value);
            return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
        }
    };
    var float$1 = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
        resolve: function resolve(str) {
            var node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
            var dot = str.indexOf('.');
            if (dot !== -1) {
                var f = str.substring(dot + 1).replace(/_/g, '');
                if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
            }
            return node;
        },
        stringify: stringifyNumber.stringifyNumber
    };
    float.float = float$1;
    float.floatExp = floatExp;
    float.floatNaN = floatNaN;
    return float;
}

var int = {};

function _type_of$m(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredInt;
function requireInt() {
    if (hasRequiredInt) return int;
    hasRequiredInt = 1;
    var stringifyNumber = requireStringifyNumber();
    var intIdentify = function(value) {
        return (typeof value === "undefined" ? "undefined" : _type_of$m(value)) === 'bigint' || Number.isInteger(value);
    };
    function intResolve(str, offset, radix, param) {
        var intAsBigInt = param.intAsBigInt;
        var sign = str[0];
        if (sign === '-' || sign === '+') offset += 1;
        str = str.substring(offset).replace(/_/g, '');
        if (intAsBigInt) {
            switch(radix){
                case 2:
                    str = "0b".concat(str);
                    break;
                case 8:
                    str = "0o".concat(str);
                    break;
                case 16:
                    str = "0x".concat(str);
                    break;
            }
            var n = BigInt(str);
            return sign === '-' ? BigInt(-1) * n : n;
        }
        var n1 = parseInt(str, radix);
        return sign === '-' ? -1 * n1 : n1;
    }
    function intStringify(node, radix, prefix) {
        var value = node.value;
        if (intIdentify(value)) {
            var str = value.toString(radix);
            return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
        }
        return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'BIN',
        test: /^[-+]?0b[0-1_]+$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 2, 2, opt);
        },
        stringify: function(node) {
            return intStringify(node, 2, '0b');
        }
    };
    var intOct = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'OCT',
        test: /^[-+]?0[0-7_]+$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 1, 8, opt);
        },
        stringify: function(node) {
            return intStringify(node, 8, '0');
        }
    };
    var int$1 = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^[-+]?[0-9][0-9_]*$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 0, 10, opt);
        },
        stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'HEX',
        test: /^[-+]?0x[0-9a-fA-F_]+$/,
        resolve: function(str, _onError, opt) {
            return intResolve(str, 2, 16, opt);
        },
        stringify: function(node) {
            return intStringify(node, 16, '0x');
        }
    };
    int.int = int$1;
    int.intBin = intBin;
    int.intHex = intHex;
    int.intOct = intOct;
    return int;
}

var set = {};

function _assert_this_initialized$a(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$a(_this, derived, args) {
    derived = _get_prototype_of$a(derived);
    return _possible_constructor_return$a(_this, _is_native_reflect_construct$a() ? Reflect.construct(derived, args, _get_prototype_of$a(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$p(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of$a(o) {
    _get_prototype_of$a = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$a(o);
}
function _inherits$a(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$a(subClass, superClass);
}
function _instanceof$c(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _possible_constructor_return$a(self, call) {
    if (call && (_type_of$l(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$a(self);
}
function _set_prototype_of$a(o, p) {
    _set_prototype_of$a = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$a(o, p);
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of$a(object);
        if (object === null) break;
    }
    return object;
}
function _type_of$l(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$a() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$a = function() {
        return !!result;
    })();
}
var hasRequiredSet;
function requireSet() {
    if (hasRequiredSet) return set;
    hasRequiredSet = 1;
    var identity = requireIdentity();
    var Pair = requirePair();
    var YAMLMap = requireYAMLMap();
    var YAMLSet = /*#__PURE__*/ function(_YAMLMap_YAMLMap) {
        _inherits$a(YAMLSet, _YAMLMap_YAMLMap);
        function YAMLSet(schema) {
            _class_call_check$p(this, YAMLSet);
            var _this;
            _this = _call_super$a(this, YAMLSet, [
                schema
            ]);
            _this.tag = YAMLSet.tag;
            return _this;
        }
        var _proto = YAMLSet.prototype;
        _proto.add = function add(key) {
            var pair;
            if (identity.isPair(key)) pair = key;
            else if (key && (typeof key === "undefined" ? "undefined" : _type_of$l(key)) === 'object' && 'key' in key && 'value' in key && key.value === null) pair = new Pair.Pair(key.key, null);
            else pair = new Pair.Pair(key, null);
            var prev = YAMLMap.findPair(this.items, pair.key);
            if (!prev) this.items.push(pair);
        };
        /**
	     * If `keepPair` is `true`, returns the Pair matching `key`.
	     * Otherwise, returns the value of that Pair's key.
	     */ _proto.get = function get(key, keepPair) {
            var pair = YAMLMap.findPair(this.items, key);
            return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
        };
        _proto.set = function set(key, value) {
            if (typeof value !== 'boolean') throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(typeof value === "undefined" ? "undefined" : _type_of$l(value)));
            var prev = YAMLMap.findPair(this.items, key);
            if (prev && !value) {
                this.items.splice(this.items.indexOf(prev), 1);
            } else if (!prev && value) {
                this.items.push(new Pair.Pair(key));
            }
        };
        _proto.toJSON = function toJSON(_, ctx) {
            return _get(_get_prototype_of$a(YAMLSet.prototype), "toJSON", this).call(this, _, ctx, Set);
        };
        _proto.toString = function toString(ctx, onComment, onChompKeep) {
            if (!ctx) return JSON.stringify(this);
            if (this.hasAllNullValues(true)) return _get(_get_prototype_of$a(YAMLSet.prototype), "toString", this).call(this, Object.assign({}, ctx, {
                allNullValues: true
            }), onComment, onChompKeep);
            else throw new Error('Set items must all have null values');
        };
        YAMLSet.from = function from(schema, iterable, ctx) {
            var replacer = ctx.replacer;
            var set = new this(schema);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            if (iterable && Symbol.iterator in Object(iterable)) try {
                for(var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var value = _step.value;
                    if (typeof replacer === 'function') value = replacer.call(iterable, value, value);
                    set.items.push(Pair.createPair(value, null, ctx));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return set;
        };
        return YAMLSet;
    }(YAMLMap.YAMLMap);
    YAMLSet.tag = 'tag:yaml.org,2002:set';
    var set$1 = {
        collection: 'map',
        identify: function(value) {
            return _instanceof$c(value, Set);
        },
        nodeClass: YAMLSet,
        default: false,
        tag: 'tag:yaml.org,2002:set',
        createNode: function(schema, iterable, ctx) {
            return YAMLSet.from(schema, iterable, ctx);
        },
        resolve: function resolve(map, onError) {
            if (identity.isMap(map)) {
                if (map.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map);
                else onError('Set items must all have null values');
            } else onError('Expected a mapping for this tag');
            return map;
        }
    };
    set.YAMLSet = YAMLSet;
    set.set = set$1;
    return set;
}

var timestamp = {};

function _array_like_to_array$d(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$8(arr) {
    if (Array.isArray(arr)) return arr;
}
function _instanceof$b(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array_limit$7(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$8() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$7(arr, i) {
    return _array_with_holes$8(arr) || _iterable_to_array_limit$7(arr, i) || _unsupported_iterable_to_array$d(arr, i) || _non_iterable_rest$8();
}
function _type_of$k(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$d(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$d(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$d(o, minLen);
}
var hasRequiredTimestamp;
function requireTimestamp() {
    if (hasRequiredTimestamp) return timestamp;
    hasRequiredTimestamp = 1;
    var stringifyNumber = requireStringifyNumber();
    /** Internal types handle bigint as number, because TS can't figure it out. */ function parseSexagesimal(str, asBigInt) {
        var sign = str[0];
        var parts = sign === '-' || sign === '+' ? str.substring(1) : str;
        var num = function(n) {
            return asBigInt ? BigInt(n) : Number(n);
        };
        var res = parts.replace(/_/g, '').split(':').reduce(function(res, p) {
            return res * num(60) + num(p);
        }, num(0));
        return sign === '-' ? num(-1) * res : res;
    }
    /**
	 * hhhh:mm:ss.sss
	 *
	 * Internal types handle bigint as number, because TS can't figure it out.
	 */ function stringifySexagesimal(node) {
        var value = node.value;
        var num = function(n) {
            return n;
        };
        if ((typeof value === "undefined" ? "undefined" : _type_of$k(value)) === 'bigint') num = function(n) {
            return BigInt(n);
        };
        else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
        var sign = '';
        if (value < 0) {
            sign = '-';
            value *= num(-1);
        }
        var _60 = num(60);
        var parts = [
            value % _60
        ]; // seconds, including ms
        if (value < 60) {
            parts.unshift(0); // at least one : is required
        } else {
            value = (value - parts[0]) / _60;
            parts.unshift(value % _60); // minutes
            if (value >= 60) {
                value = (value - parts[0]) / _60;
                parts.unshift(value); // hours
            }
        }
        return sign + parts.map(function(n) {
            return String(n).padStart(2, '0');
        }).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
        ;
    }
    var intTime = {
        identify: function(value) {
            return (typeof value === "undefined" ? "undefined" : _type_of$k(value)) === 'bigint' || Number.isInteger(value);
        },
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'TIME',
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
        resolve: function(str, _onError, param) {
            var intAsBigInt = param.intAsBigInt;
            return parseSexagesimal(str, intAsBigInt);
        },
        stringify: stringifySexagesimal
    };
    var floatTime = {
        identify: function(value) {
            return typeof value === 'number';
        },
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'TIME',
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
        resolve: function(str) {
            return parseSexagesimal(str, false);
        },
        stringify: stringifySexagesimal
    };
    var timestamp$1 = {
        identify: function(value) {
            return _instanceof$b(value, Date);
        },
        default: true,
        tag: 'tag:yaml.org,2002:timestamp',
        // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
        // may be omitted altogether, resulting in a date format. In such a case, the time part is
        // assumed to be 00:00:00Z (start of day, UTC).
        test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
        resolve: function resolve(str) {
            var match = str.match(timestamp$1.test);
            if (!match) throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
            var _match_map = _sliced_to_array$7(match.map(Number), 7), year = _match_map[1], month = _match_map[2], day = _match_map[3], hour = _match_map[4], minute = _match_map[5], second = _match_map[6];
            var millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
            var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
            var tz = match[8];
            if (tz && tz !== 'Z') {
                var d = parseSexagesimal(tz, false);
                if (Math.abs(d) < 30) d *= 60;
                date -= 60000 * d;
            }
            return new Date(date);
        },
        stringify: function(param) {
            var value = param.value;
            return value.toISOString().replace(/(T00:00:00)?\.000Z$/, '');
        }
    };
    timestamp.floatTime = floatTime;
    timestamp.intTime = intTime;
    timestamp.timestamp = timestamp$1;
    return timestamp;
}

var hasRequiredSchema$1;
function requireSchema$1() {
    if (hasRequiredSchema$1) return schema;
    hasRequiredSchema$1 = 1;
    var map = requireMap();
    var _null = require_null();
    var seq = requireSeq();
    var string = requireString();
    var binary = requireBinary();
    var bool = requireBool();
    var float = requireFloat();
    var int = requireInt();
    var merge = requireMerge();
    var omap = requireOmap();
    var pairs = requirePairs();
    var set = requireSet();
    var timestamp = requireTimestamp();
    var schema$1 = [
        map.map,
        seq.seq,
        string.string,
        _null.nullTag,
        bool.trueTag,
        bool.falseTag,
        int.intBin,
        int.intOct,
        int.int,
        int.intHex,
        float.floatNaN,
        float.floatExp,
        float.float,
        binary.binary,
        merge.merge,
        omap.omap,
        pairs.pairs,
        set.set,
        timestamp.intTime,
        timestamp.floatTime,
        timestamp.timestamp
    ];
    schema.schema = schema$1;
    return schema;
}

var hasRequiredTags;
function requireTags() {
    if (hasRequiredTags) return tags;
    hasRequiredTags = 1;
    var map = requireMap();
    var _null = require_null();
    var seq = requireSeq();
    var string = requireString();
    var bool = requireBool$1();
    var float = requireFloat$1();
    var int = requireInt$1();
    var schema = requireSchema$3();
    var schema$1 = requireSchema$2();
    var binary = requireBinary();
    var merge = requireMerge();
    var omap = requireOmap();
    var pairs = requirePairs();
    var schema$2 = requireSchema$1();
    var set = requireSet();
    var timestamp = requireTimestamp();
    var schemas = new Map([
        [
            'core',
            schema.schema
        ],
        [
            'failsafe',
            [
                map.map,
                seq.seq,
                string.string
            ]
        ],
        [
            'json',
            schema$1.schema
        ],
        [
            'yaml11',
            schema$2.schema
        ],
        [
            'yaml-1.1',
            schema$2.schema
        ]
    ]);
    var tagsByName = {
        binary: binary.binary,
        bool: bool.boolTag,
        float: float.float,
        floatExp: float.floatExp,
        floatNaN: float.floatNaN,
        floatTime: timestamp.floatTime,
        int: int.int,
        intHex: int.intHex,
        intOct: int.intOct,
        intTime: timestamp.intTime,
        map: map.map,
        merge: merge.merge,
        null: _null.nullTag,
        omap: omap.omap,
        pairs: pairs.pairs,
        seq: seq.seq,
        set: set.set,
        timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
        'tag:yaml.org,2002:binary': binary.binary,
        'tag:yaml.org,2002:merge': merge.merge,
        'tag:yaml.org,2002:omap': omap.omap,
        'tag:yaml.org,2002:pairs': pairs.pairs,
        'tag:yaml.org,2002:set': set.set,
        'tag:yaml.org,2002:timestamp': timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
        var schemaTags = schemas.get(schemaName);
        if (schemaTags && !customTags) {
            return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
        }
        var _$tags = schemaTags;
        if (!_$tags) {
            if (Array.isArray(customTags)) _$tags = [];
            else {
                var keys = Array.from(schemas.keys()).filter(function(key) {
                    return key !== 'yaml11';
                }).map(function(key) {
                    return JSON.stringify(key);
                }).join(', ');
                throw new Error('Unknown schema "'.concat(schemaName, '"; use one of ').concat(keys, " or define customTags array"));
            }
        }
        if (Array.isArray(customTags)) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = customTags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var tag = _step.value;
                    _$tags = _$tags.concat(tag);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        } else if (typeof customTags === 'function') {
            _$tags = customTags(_$tags.slice());
        }
        if (addMergeTag) _$tags = _$tags.concat(merge.merge);
        return _$tags.reduce(function(tags, tag) {
            var tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;
            if (!tagObj) {
                var tagName = JSON.stringify(tag);
                var keys = Object.keys(tagsByName).map(function(key) {
                    return JSON.stringify(key);
                }).join(', ');
                throw new Error("Unknown custom tag ".concat(tagName, "; use one of ").concat(keys));
            }
            if (!tags.includes(tagObj)) tags.push(tagObj);
            return tags;
        }, []);
    }
    tags.coreKnownTags = coreKnownTags;
    tags.getTags = getTags;
    return tags;
}

function _class_call_check$o(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var hasRequiredSchema;
function requireSchema() {
    if (hasRequiredSchema) return Schema;
    hasRequiredSchema = 1;
    var identity = requireIdentity();
    var map = requireMap();
    var seq = requireSeq();
    var string = requireString();
    var tags = requireTags();
    var sortMapEntriesByKey = function(a, b) {
        return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    };
    var Schema$1 = /*#__PURE__*/ function() {
        function Schema(param) {
            var compat = param.compat, customTags = param.customTags, merge = param.merge, resolveKnownTags = param.resolveKnownTags, schema = param.schema, sortMapEntries = param.sortMapEntries, toStringDefaults = param.toStringDefaults;
            _class_call_check$o(this, Schema);
            this.compat = Array.isArray(compat) ? tags.getTags(compat, 'compat') : compat ? tags.getTags(null, compat) : null;
            this.name = typeof schema === 'string' && schema || 'core';
            this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
            this.tags = tags.getTags(customTags, this.name, merge);
            this.toStringOptions = toStringDefaults !== null && toStringDefaults !== undefined ? toStringDefaults : null;
            Object.defineProperty(this, identity.MAP, {
                value: map.map
            });
            Object.defineProperty(this, identity.SCALAR, {
                value: string.string
            });
            Object.defineProperty(this, identity.SEQ, {
                value: seq.seq
            });
            // Used by createMap()
            this.sortMapEntries = typeof sortMapEntries === 'function' ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
        }
        var _proto = Schema.prototype;
        _proto.clone = function clone() {
            var copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
            copy.tags = this.tags.slice();
            return copy;
        };
        return Schema;
    }();
    Schema.Schema = Schema$1;
    return Schema;
}

var stringifyDocument = {};

var hasRequiredStringifyDocument;
function requireStringifyDocument() {
    if (hasRequiredStringifyDocument) return stringifyDocument;
    hasRequiredStringifyDocument = 1;
    var identity = requireIdentity();
    var stringify = requireStringify();
    var stringifyComment = requireStringifyComment();
    function stringifyDocument$1(doc, options) {
        var _doc_directives;
        var lines = [];
        var hasDirectives = options.directives === true;
        if (options.directives !== false && doc.directives) {
            var dir = doc.directives.toString(doc);
            if (dir) {
                lines.push(dir);
                hasDirectives = true;
            } else if (doc.directives.docStart) hasDirectives = true;
        }
        if (hasDirectives) lines.push('---');
        var ctx = stringify.createStringifyContext(doc, options);
        var commentString = ctx.options.commentString;
        if (doc.commentBefore) {
            if (lines.length !== 1) lines.unshift('');
            var cs = commentString(doc.commentBefore);
            lines.unshift(stringifyComment.indentComment(cs, ''));
        }
        var chompKeep = false;
        var contentComment = null;
        if (doc.contents) {
            if (identity.isNode(doc.contents)) {
                if (doc.contents.spaceBefore && hasDirectives) lines.push('');
                if (doc.contents.commentBefore) {
                    var cs1 = commentString(doc.contents.commentBefore);
                    lines.push(stringifyComment.indentComment(cs1, ''));
                }
                // top-level block scalars need to be indented if followed by a comment
                ctx.forceBlockIndent = !!doc.comment;
                contentComment = doc.contents.comment;
            }
            var onChompKeep = contentComment ? undefined : function() {
                return chompKeep = true;
            };
            var body = stringify.stringify(doc.contents, ctx, function() {
                return contentComment = null;
            }, onChompKeep);
            if (contentComment) body += stringifyComment.lineComment(body, '', commentString(contentComment));
            if ((body[0] === '|' || body[0] === '>') && lines[lines.length - 1] === '---') {
                // Top-level block scalars with a preceding doc marker ought to use the
                // same line for their header.
                lines[lines.length - 1] = "--- ".concat(body);
            } else lines.push(body);
        } else {
            lines.push(stringify.stringify(doc.contents, ctx));
        }
        if ((_doc_directives = doc.directives) === null || _doc_directives === undefined ? undefined : _doc_directives.docEnd) {
            if (doc.comment) {
                var cs2 = commentString(doc.comment);
                if (cs2.includes('\n')) {
                    lines.push('...');
                    lines.push(stringifyComment.indentComment(cs2, ''));
                } else {
                    lines.push("... ".concat(cs2));
                }
            } else {
                lines.push('...');
            }
        } else {
            var dc = doc.comment;
            if (dc && chompKeep) dc = dc.replace(/^\n+/, '');
            if (dc) {
                if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
                lines.push(stringifyComment.indentComment(commentString(dc), ''));
            }
        }
        return lines.join('\n') + '\n';
    }
    stringifyDocument.stringifyDocument = stringifyDocument$1;
    return stringifyDocument;
}

function _class_call_check$n(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _instanceof$a(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var hasRequiredDocument;
function requireDocument() {
    if (hasRequiredDocument) return Document;
    hasRequiredDocument = 1;
    var Alias = requireAlias();
    var Collection = requireCollection();
    var identity = requireIdentity();
    var Pair = requirePair();
    var toJS = requireToJS();
    var Schema = requireSchema();
    var stringifyDocument = requireStringifyDocument();
    var anchors = requireAnchors();
    var applyReviver = requireApplyReviver();
    var createNode = requireCreateNode();
    var directives = requireDirectives();
    var Document$1 = /*#__PURE__*/ function() {
        function Document(value, replacer, options) {
            _class_call_check$n(this, Document);
            /** A comment before this Document */ this.commentBefore = null;
            /** A comment immediately after this Document */ this.comment = null;
            /** Errors encountered during parsing. */ this.errors = [];
            /** Warnings encountered during parsing. */ this.warnings = [];
            Object.defineProperty(this, identity.NODE_TYPE, {
                value: identity.DOC
            });
            var _replacer = null;
            if (typeof replacer === 'function' || Array.isArray(replacer)) {
                _replacer = replacer;
            } else if (options === undefined && replacer) {
                options = replacer;
                replacer = undefined;
            }
            var opt = Object.assign({
                intAsBigInt: false,
                keepSourceTokens: false,
                logLevel: 'warn',
                prettyErrors: true,
                strict: true,
                stringKeys: false,
                uniqueKeys: true,
                version: '1.2'
            }, options);
            this.options = opt;
            var version = opt.version;
            if (options === null || options === undefined ? undefined : options._directives) {
                this.directives = options._directives.atDocument();
                if (this.directives.yaml.explicit) version = this.directives.yaml.version;
            } else this.directives = new directives.Directives({
                version: version
            });
            this.setSchema(version, options);
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
        }
        var _proto = Document.prototype;
        /**
	     * Create a deep copy of this Document and its contents.
	     *
	     * Custom Node values that inherit from `Object` still refer to their original instances.
	     */ _proto.clone = function clone() {
            var copy = Object.create(Document.prototype, _define_property({}, identity.NODE_TYPE, {
                value: identity.DOC
            }));
            copy.commentBefore = this.commentBefore;
            copy.comment = this.comment;
            copy.errors = this.errors.slice();
            copy.warnings = this.warnings.slice();
            copy.options = Object.assign({}, this.options);
            if (this.directives) copy.directives = this.directives.clone();
            copy.schema = this.schema.clone();
            // @ts-expect-error We can't really know that this matches Contents.
            copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
            if (this.range) copy.range = this.range.slice();
            return copy;
        };
        /** Adds a value to the document. */ _proto.add = function add(value) {
            if (assertCollection(this.contents)) this.contents.add(value);
        };
        /** Adds a value to the document. */ _proto.addIn = function addIn(path, value) {
            if (assertCollection(this.contents)) this.contents.addIn(path, value);
        };
        /**
	     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
	     *
	     * If `node` already has an anchor, `name` is ignored.
	     * Otherwise, the `node.anchor` value will be set to `name`,
	     * or if an anchor with that name is already present in the document,
	     * `name` will be used as a prefix for a new unique anchor.
	     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
	     */ _proto.createAlias = function createAlias(node, name) {
            if (!node.anchor) {
                var prev = anchors.anchorNames(this);
                node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
            }
            return new Alias.Alias(node.anchor);
        };
        _proto.createNode = function createNode1(value, replacer, options) {
            var _replacer = undefined;
            if (typeof replacer === 'function') {
                value = replacer.call({
                    '': value
                }, '', value);
                _replacer = replacer;
            } else if (Array.isArray(replacer)) {
                var keyToStr = function(v) {
                    return typeof v === 'number' || _instanceof$a(v, String) || _instanceof$a(v, Number);
                };
                var asStr = replacer.filter(keyToStr).map(String);
                if (asStr.length > 0) replacer = replacer.concat(asStr);
                _replacer = replacer;
            } else if (options === undefined && replacer) {
                options = replacer;
                replacer = undefined;
            }
            var _ref = options !== null && options !== undefined ? options : {}, aliasDuplicateObjects = _ref.aliasDuplicateObjects, anchorPrefix = _ref.anchorPrefix, flow = _ref.flow, keepUndefined = _ref.keepUndefined, onTagObj = _ref.onTagObj, tag = _ref.tag;
            var _anchors_createNodeAnchors = anchors.createNodeAnchors(this, // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            anchorPrefix || 'a'), onAnchor = _anchors_createNodeAnchors.onAnchor, setAnchors = _anchors_createNodeAnchors.setAnchors, sourceObjects = _anchors_createNodeAnchors.sourceObjects;
            var ctx = {
                aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== undefined ? aliasDuplicateObjects : true,
                keepUndefined: keepUndefined !== null && keepUndefined !== undefined ? keepUndefined : false,
                onAnchor: onAnchor,
                onTagObj: onTagObj,
                replacer: _replacer,
                schema: this.schema,
                sourceObjects: sourceObjects
            };
            var node = createNode.createNode(value, tag, ctx);
            if (flow && identity.isCollection(node)) node.flow = true;
            setAnchors();
            return node;
        };
        /**
	     * Convert a key and a value into a `Pair` using the current schema,
	     * recursively wrapping all values as `Scalar` or `Collection` nodes.
	     */ _proto.createPair = function createPair(key, value) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var k = this.createNode(key, null, options);
            var v = this.createNode(value, null, options);
            return new Pair.Pair(k, v);
        };
        /**
	     * Removes a value from the document.
	     * @returns `true` if the item was found and removed.
	     */ _proto.delete = function _delete(key) {
            return assertCollection(this.contents) ? this.contents.delete(key) : false;
        };
        /**
	     * Removes a value from the document.
	     * @returns `true` if the item was found and removed.
	     */ _proto.deleteIn = function deleteIn(path) {
            if (Collection.isEmptyPath(path)) {
                if (this.contents == null) return false;
                // @ts-expect-error Presumed impossible if Strict extends false
                this.contents = null;
                return true;
            }
            return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
        };
        /**
	     * Returns item at `key`, or `undefined` if not found. By default unwraps
	     * scalar values from their surrounding node; to disable set `keepScalar` to
	     * `true` (collections are always returned intact).
	     */ _proto.get = function get(key, keepScalar) {
            return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
        };
        /**
	     * Returns item at `path`, or `undefined` if not found. By default unwraps
	     * scalar values from their surrounding node; to disable set `keepScalar` to
	     * `true` (collections are always returned intact).
	     */ _proto.getIn = function getIn(path, keepScalar) {
            if (Collection.isEmptyPath(path)) return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
            return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
        };
        /**
	     * Checks if the document includes a value with the key `key`.
	     */ _proto.has = function has(key) {
            return identity.isCollection(this.contents) ? this.contents.has(key) : false;
        };
        /**
	     * Checks if the document includes a value at `path`.
	     */ _proto.hasIn = function hasIn(path) {
            if (Collection.isEmptyPath(path)) return this.contents !== undefined;
            return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
        };
        /**
	     * Sets a value in this document. For `!!set`, `value` needs to be a
	     * boolean to add/remove the item from the set.
	     */ _proto.set = function set(key, value) {
            if (this.contents == null) {
                // @ts-expect-error We can't really know that this matches Contents.
                this.contents = Collection.collectionFromPath(this.schema, [
                    key
                ], value);
            } else if (assertCollection(this.contents)) {
                this.contents.set(key, value);
            }
        };
        /**
	     * Sets a value in this document. For `!!set`, `value` needs to be a
	     * boolean to add/remove the item from the set.
	     */ _proto.setIn = function setIn(path, value) {
            if (Collection.isEmptyPath(path)) {
                // @ts-expect-error We can't really know that this matches Contents.
                this.contents = value;
            } else if (this.contents == null) {
                // @ts-expect-error We can't really know that this matches Contents.
                this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
            } else if (assertCollection(this.contents)) {
                this.contents.setIn(path, value);
            }
        };
        /**
	     * Change the YAML version and schema used by the document.
	     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
	     * It also requires the `schema` option to be given as a `Schema` instance value.
	     *
	     * Overrides all previously set schema options.
	     */ _proto.setSchema = function setSchema(version) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (typeof version === 'number') version = String(version);
            var opt;
            switch(version){
                case '1.1':
                    if (this.directives) this.directives.yaml.version = '1.1';
                    else this.directives = new directives.Directives({
                        version: '1.1'
                    });
                    opt = {
                        resolveKnownTags: false,
                        schema: 'yaml-1.1'
                    };
                    break;
                case '1.2':
                case 'next':
                    if (this.directives) this.directives.yaml.version = version;
                    else this.directives = new directives.Directives({
                        version: version
                    });
                    opt = {
                        resolveKnownTags: true,
                        schema: 'core'
                    };
                    break;
                case null:
                    if (this.directives) delete this.directives;
                    opt = null;
                    break;
                default:
                    {
                        var sv = JSON.stringify(version);
                        throw new Error("Expected '1.1', '1.2' or null as first argument, but found: ".concat(sv));
                    }
            }
            // Not using `instanceof Schema` to allow for duck typing
            if (_instanceof$a(options.schema, Object)) this.schema = options.schema;
            else if (opt) this.schema = new Schema.Schema(Object.assign(opt, options));
            else throw new Error("With a null YAML version, the { schema: Schema } option is required");
        };
        // json & jsonArg are only used from toJSON()
        _proto.toJS = function toJS1() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, json = _ref.json, jsonArg = _ref.jsonArg, mapAsMap = _ref.mapAsMap, maxAliasCount = _ref.maxAliasCount, onAnchor = _ref.onAnchor, reviver = _ref.reviver;
            var ctx = {
                anchors: new Map(),
                doc: this,
                keep: !json,
                mapAsMap: mapAsMap === true,
                mapKeyWarned: false,
                maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
            };
            var res = toJS.toJS(this.contents, jsonArg !== null && jsonArg !== undefined ? jsonArg : '', ctx);
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            if (typeof onAnchor === 'function') try {
                for(var _iterator = ctx.anchors.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _step.value, count = _step_value.count, res1 = _step_value.res;
                    onAnchor(res1, count);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return typeof reviver === 'function' ? applyReviver.applyReviver(reviver, {
                '': res
            }, '', res) : res;
        };
        /**
	     * A JSON representation of the document `contents`.
	     *
	     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
	     *   property name.
	     */ _proto.toJSON = function toJSON(jsonArg, onAnchor) {
            return this.toJS({
                json: true,
                jsonArg: jsonArg,
                mapAsMap: false,
                onAnchor: onAnchor
            });
        };
        /** A YAML representation of the document. */ _proto.toString = function toString() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
            if ('indent' in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
                var s = JSON.stringify(options.indent);
                throw new Error('"indent" option must be a positive integer, not '.concat(s));
            }
            return stringifyDocument.stringifyDocument(this, options);
        };
        return Document;
    }();
    function assertCollection(contents) {
        if (identity.isCollection(contents)) return true;
        throw new Error('Expected a YAML collection as document contents');
    }
    Document.Document = Document$1;
    return Document;
}

var errors = {};

function _assert_this_initialized$9(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$9(_this, derived, args) {
    derived = _get_prototype_of$9(derived);
    return _possible_constructor_return$9(_this, _is_native_reflect_construct$9() ? Reflect.construct(derived, args || [], _get_prototype_of$9(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$m(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct$3(Parent, args, Class) {
    if (_is_native_reflect_construct$9()) {
        _construct$3 = Reflect.construct;
    } else {
        _construct$3 = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of$9(instance, Class.prototype);
            return instance;
        };
    }
    return _construct$3.apply(null, arguments);
}
function _get_prototype_of$9(o) {
    _get_prototype_of$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$9(o);
}
function _inherits$9(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$9(subClass, superClass);
}
function _is_native_function$3(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _possible_constructor_return$9(self, call) {
    if (call && (_type_of$j(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$9(self);
}
function _set_prototype_of$9(o, p) {
    _set_prototype_of$9 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$9(o, p);
}
function _type_of$j(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _wrap_native_super$3(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super$3 = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function$3(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct$3(Class, arguments, _get_prototype_of$9(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of$9(Wrapper, Class);
    };
    return _wrap_native_super$3(Class);
}
function _is_native_reflect_construct$9() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$9 = function() {
        return !!result;
    })();
}
var hasRequiredErrors;
function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    var YAMLError = /*#__PURE__*/ function(Error1) {
        _inherits$9(YAMLError, Error1);
        function YAMLError(name, pos, code, message) {
            _class_call_check$m(this, YAMLError);
            var _this;
            _this = _call_super$9(this, YAMLError);
            _this.name = name;
            _this.code = code;
            _this.message = message;
            _this.pos = pos;
            return _this;
        }
        return YAMLError;
    }(_wrap_native_super$3(Error));
    var YAMLParseError = /*#__PURE__*/ function(YAMLError) {
        _inherits$9(YAMLParseError, YAMLError);
        function YAMLParseError(pos, code, message) {
            _class_call_check$m(this, YAMLParseError);
            return _call_super$9(this, YAMLParseError, [
                'YAMLParseError',
                pos,
                code,
                message
            ]);
        }
        return YAMLParseError;
    }(YAMLError);
    var YAMLWarning = /*#__PURE__*/ function(YAMLError) {
        _inherits$9(YAMLWarning, YAMLError);
        function YAMLWarning(pos, code, message) {
            _class_call_check$m(this, YAMLWarning);
            return _call_super$9(this, YAMLWarning, [
                'YAMLWarning',
                pos,
                code,
                message
            ]);
        }
        return YAMLWarning;
    }(YAMLError);
    var prettifyError = function(src, lc) {
        return function(error) {
            if (error.pos[0] === -1) return;
            error.linePos = error.pos.map(function(pos) {
                return lc.linePos(pos);
            });
            var _error_linePos_ = error.linePos[0], line = _error_linePos_.line, col = _error_linePos_.col;
            error.message += " at line ".concat(line, ", column ").concat(col);
            var ci = col - 1;
            var lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, '');
            // Trim to max 80 chars, keeping col position near the middle
            if (ci >= 60 && lineStr.length > 80) {
                var trimStart = Math.min(ci - 39, lineStr.length - 79);
                lineStr = '…' + lineStr.substring(trimStart);
                ci -= trimStart - 1;
            }
            if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + '…';
            // Include previous line in context if pointing at line start
            if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
                // Regexp won't match if start is trimmed
                var prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
                if (prev.length > 80) prev = prev.substring(0, 79) + '…\n';
                lineStr = prev + lineStr;
            }
            if (/[^ ]/.test(lineStr)) {
                var count = 1;
                var end = error.linePos[1];
                if (end && end.line === line && end.col > col) {
                    count = Math.max(1, Math.min(end.col - col, 80 - ci));
                }
                var pointer = ' '.repeat(ci) + '^'.repeat(count);
                error.message += ":\n\n".concat(lineStr, "\n").concat(pointer, "\n");
            }
        };
    };
    errors.YAMLError = YAMLError;
    errors.YAMLParseError = YAMLParseError;
    errors.YAMLWarning = YAMLWarning;
    errors.prettifyError = prettifyError;
    return errors;
}

var composeDoc = {};

var composeNode = {};

var composeCollection = {};

var resolveBlockMap = {};

var resolveProps = {};

var hasRequiredResolveProps;
function requireResolveProps() {
    if (hasRequiredResolveProps) return resolveProps;
    hasRequiredResolveProps = 1;
    function resolveProps$1(tokens, param) {
        var flow = param.flow, indicator = param.indicator, next = param.next, offset = param.offset, onError = param.onError, parentIndent = param.parentIndent, startOnNewline = param.startOnNewline;
        var spaceBefore = false;
        var atNewline = startOnNewline;
        var hasSpace = startOnNewline;
        var comment = '';
        var commentSep = '';
        var hasNewline = false;
        var reqSpace = false;
        var tab = null;
        var anchor = null;
        var tag = null;
        var newlineAfterProp = null;
        var comma = null;
        var found = null;
        var start = null;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var token = _step.value;
                if (reqSpace) {
                    if (token.type !== 'space' && token.type !== 'newline' && token.type !== 'comma') onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
                    reqSpace = false;
                }
                if (tab) {
                    if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
                        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                    }
                    tab = null;
                }
                switch(token.type){
                    case 'space':
                        // At the doc level, tabs at line start may be parsed
                        // as leading white space rather than indentation.
                        // In a flow collection, only the parser handles indent.
                        if (!flow && (indicator !== 'doc-start' || (next === null || next === void 0 ? void 0 : next.type) !== 'flow-collection') && token.source.includes('\t')) {
                            tab = token;
                        }
                        hasSpace = true;
                        break;
                    case 'comment':
                        {
                            if (!hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                            var cb = token.source.substring(1) || ' ';
                            if (!comment) comment = cb;
                            else comment += commentSep + cb;
                            commentSep = '';
                            atNewline = false;
                            break;
                        }
                    case 'newline':
                        if (atNewline) {
                            if (comment) comment += token.source;
                            else if (!found || indicator !== 'seq-item-ind') spaceBefore = true;
                        } else commentSep += token.source;
                        atNewline = true;
                        hasNewline = true;
                        if (anchor || tag) newlineAfterProp = token;
                        hasSpace = true;
                        break;
                    case 'anchor':
                        if (anchor) onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                        if (token.source.endsWith(':')) onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                        anchor = token;
                        if (start === null) start = token.offset;
                        atNewline = false;
                        hasSpace = false;
                        reqSpace = true;
                        break;
                    case 'tag':
                        {
                            if (tag) onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                            tag = token;
                            if (start === null) start = token.offset;
                            atNewline = false;
                            hasSpace = false;
                            reqSpace = true;
                            break;
                        }
                    case indicator:
                        // Could here handle preceding comments differently
                        if (anchor || tag) onError(token, 'BAD_PROP_ORDER', "Anchors and tags must be after the ".concat(token.source, " indicator"));
                        if (found) onError(token, 'UNEXPECTED_TOKEN', "Unexpected ".concat(token.source, " in ").concat(flow !== null && flow !== void 0 ? flow : 'collection'));
                        found = token;
                        atNewline = indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
                        hasSpace = false;
                        break;
                    case 'comma':
                        if (flow) {
                            if (comma) onError(token, 'UNEXPECTED_TOKEN', "Unexpected , in ".concat(flow));
                            comma = token;
                            atNewline = false;
                            hasSpace = false;
                            break;
                        }
                    // else fallthrough
                    default:
                        onError(token, 'UNEXPECTED_TOKEN', "Unexpected ".concat(token.type, " token"));
                        atNewline = false;
                        hasSpace = false;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var last = tokens[tokens.length - 1];
        var end = last ? last.offset + last.source.length : offset;
        if (reqSpace && next && next.type !== 'space' && next.type !== 'newline' && next.type !== 'comma' && (next.type !== 'scalar' || next.source !== '')) {
            onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
        }
        if (tab && (atNewline && tab.indent <= parentIndent || (next === null || next === undefined ? undefined : next.type) === 'block-map' || (next === null || next === undefined ? undefined : next.type) === 'block-seq')) onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
        return {
            comma: comma,
            found: found,
            spaceBefore: spaceBefore,
            comment: comment,
            hasNewline: hasNewline,
            anchor: anchor,
            tag: tag,
            newlineAfterProp: newlineAfterProp,
            end: end,
            start: start !== null && start !== undefined ? start : end
        };
    }
    resolveProps.resolveProps = resolveProps$1;
    return resolveProps;
}

var utilContainsNewline = {};

var hasRequiredUtilContainsNewline;
function requireUtilContainsNewline() {
    if (hasRequiredUtilContainsNewline) return utilContainsNewline;
    hasRequiredUtilContainsNewline = 1;
    function containsNewline(key) {
        if (!key) return null;
        switch(key.type){
            case 'alias':
            case 'scalar':
            case 'double-quoted-scalar':
            case 'single-quoted-scalar':
                if (key.source.includes('\n')) return true;
                if (key.end) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = key.end[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var st = _step.value;
                            if (st.type === 'newline') return true;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                return false;
            case 'flow-collection':
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = key.items[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var it = _step1.value;
                        var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                        try {
                            for(var _iterator2 = it.start[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                var st1 = _step2.value;
                                if (st1.type === 'newline') return true;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                    _iterator2.return();
                                }
                            } finally{
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                        if (it.sep) {
                            var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                            try {
                                for(var _iterator3 = it.sep[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                                    var st2 = _step3.value;
                                    if (st2.type === 'newline') return true;
                                }
                            } catch (err) {
                                _didIteratorError3 = true;
                                _iteratorError3 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                        _iterator3.return();
                                    }
                                } finally{
                                    if (_didIteratorError3) {
                                        throw _iteratorError3;
                                    }
                                }
                            }
                        }
                        if (containsNewline(it.key) || containsNewline(it.value)) return true;
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                return false;
            default:
                return true;
        }
    }
    utilContainsNewline.containsNewline = containsNewline;
    return utilContainsNewline;
}

var utilFlowIndentCheck = {};

var hasRequiredUtilFlowIndentCheck;
function requireUtilFlowIndentCheck() {
    if (hasRequiredUtilFlowIndentCheck) return utilFlowIndentCheck;
    hasRequiredUtilFlowIndentCheck = 1;
    var utilContainsNewline = requireUtilContainsNewline();
    function flowIndentCheck(indent, fc, onError) {
        if ((fc === null || fc === undefined ? undefined : fc.type) === 'flow-collection') {
            var end = fc.end[0];
            if (end.indent === indent && (end.source === ']' || end.source === '}') && utilContainsNewline.containsNewline(fc)) {
                var msg = 'Flow end indicator should be more indented than parent';
                onError(end, 'BAD_INDENT', msg, true);
            }
        }
    }
    utilFlowIndentCheck.flowIndentCheck = flowIndentCheck;
    return utilFlowIndentCheck;
}

var utilMapIncludes = {};

var hasRequiredUtilMapIncludes;
function requireUtilMapIncludes() {
    if (hasRequiredUtilMapIncludes) return utilMapIncludes;
    hasRequiredUtilMapIncludes = 1;
    var identity = requireIdentity();
    function mapIncludes(ctx, items, search) {
        var uniqueKeys = ctx.options.uniqueKeys;
        if (uniqueKeys === false) return false;
        var isEqual = typeof uniqueKeys === 'function' ? uniqueKeys : function(a, b) {
            return a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
        };
        return items.some(function(pair) {
            return isEqual(pair.key, search);
        });
    }
    utilMapIncludes.mapIncludes = mapIncludes;
    return utilMapIncludes;
}

var hasRequiredResolveBlockMap;
function requireResolveBlockMap() {
    if (hasRequiredResolveBlockMap) return resolveBlockMap;
    hasRequiredResolveBlockMap = 1;
    var Pair = requirePair();
    var YAMLMap = requireYAMLMap();
    var resolveProps = requireResolveProps();
    var utilContainsNewline = requireUtilContainsNewline();
    var utilFlowIndentCheck = requireUtilFlowIndentCheck();
    var utilMapIncludes = requireUtilMapIncludes();
    var startColMsg = 'All mapping items must start at the same column';
    function resolveBlockMap$1(param, ctx, bm, onError, tag) {
        var composeNode = param.composeNode, composeEmptyNode = param.composeEmptyNode;
        var _tag_nodeClass;
        var NodeClass = (_tag_nodeClass = tag === null || tag === undefined ? undefined : tag.nodeClass) !== null && _tag_nodeClass !== undefined ? _tag_nodeClass : YAMLMap.YAMLMap;
        var map = new NodeClass(ctx.schema);
        if (ctx.atRoot) ctx.atRoot = false;
        var offset = bm.offset;
        var commentEnd = null;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = bm.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var collItem = _step.value;
                var _keyProps_found;
                var start = collItem.start, key = collItem.key, sep = collItem.sep, value = collItem.value;
                // key properties
                var keyProps = resolveProps.resolveProps(start, {
                    indicator: 'explicit-key-ind',
                    next: key !== null && key !== void 0 ? key : sep === null || sep === void 0 ? void 0 : sep[0],
                    offset: offset,
                    onError: onError,
                    parentIndent: bm.indent,
                    startOnNewline: true
                });
                var implicitKey = !keyProps.found;
                if (implicitKey) {
                    if (key) {
                        if (key.type === 'block-seq') onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                        else if ('indent' in key && key.indent !== bm.indent) onError(offset, 'BAD_INDENT', startColMsg);
                    }
                    if (!keyProps.anchor && !keyProps.tag && !sep) {
                        commentEnd = keyProps.end;
                        if (keyProps.comment) {
                            if (map.comment) map.comment += '\n' + keyProps.comment;
                            else map.comment = keyProps.comment;
                        }
                        continue;
                    }
                    if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
                        onError(key !== null && key !== void 0 ? key : start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
                    }
                } else if (((_keyProps_found = keyProps.found) === null || _keyProps_found === void 0 ? void 0 : _keyProps_found.indent) !== bm.indent) {
                    onError(offset, 'BAD_INDENT', startColMsg);
                }
                // key value
                ctx.atKey = true;
                var keyStart = keyProps.end;
                var keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
                if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
                ctx.atKey = false;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                // value properties
                var valueProps = resolveProps.resolveProps(sep !== null && sep !== void 0 ? sep : [], {
                    indicator: 'map-value-ind',
                    next: value,
                    offset: keyNode.range[2],
                    onError: onError,
                    parentIndent: bm.indent,
                    startOnNewline: !key || key.type === 'block-scalar'
                });
                offset = valueProps.end;
                if (valueProps.found) {
                    if (implicitKey) {
                        if ((value === null || value === void 0 ? void 0 : value.type) === 'block-map' && !valueProps.hasNewline) onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
                    }
                    // value value
                    var valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
                    if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
                    offset = valueNode.range[2];
                    var pair = new Pair.Pair(keyNode, valueNode);
                    if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
                    map.items.push(pair);
                } else {
                    // key with no value
                    if (implicitKey) onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
                    if (valueProps.comment) {
                        if (keyNode.comment) keyNode.comment += '\n' + valueProps.comment;
                        else keyNode.comment = valueProps.comment;
                    }
                    var pair1 = new Pair.Pair(keyNode);
                    if (ctx.options.keepSourceTokens) pair1.srcToken = collItem;
                    map.items.push(pair1);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (commentEnd && commentEnd < offset) onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
        map.range = [
            bm.offset,
            offset,
            commentEnd !== null && commentEnd !== undefined ? commentEnd : offset
        ];
        return map;
    }
    resolveBlockMap.resolveBlockMap = resolveBlockMap$1;
    return resolveBlockMap;
}

var resolveBlockSeq = {};

var hasRequiredResolveBlockSeq;
function requireResolveBlockSeq() {
    if (hasRequiredResolveBlockSeq) return resolveBlockSeq;
    hasRequiredResolveBlockSeq = 1;
    var YAMLSeq = requireYAMLSeq();
    var resolveProps = requireResolveProps();
    var utilFlowIndentCheck = requireUtilFlowIndentCheck();
    function resolveBlockSeq$1(param, ctx, bs, onError, tag) {
        var composeNode = param.composeNode, composeEmptyNode = param.composeEmptyNode;
        var _tag_nodeClass;
        var NodeClass = (_tag_nodeClass = tag === null || tag === undefined ? undefined : tag.nodeClass) !== null && _tag_nodeClass !== undefined ? _tag_nodeClass : YAMLSeq.YAMLSeq;
        var seq = new NodeClass(ctx.schema);
        if (ctx.atRoot) ctx.atRoot = false;
        if (ctx.atKey) ctx.atKey = false;
        var offset = bs.offset;
        var commentEnd = null;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = bs.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _step.value, start = _step_value.start, value = _step_value.value;
                var props = resolveProps.resolveProps(start, {
                    indicator: 'seq-item-ind',
                    next: value,
                    offset: offset,
                    onError: onError,
                    parentIndent: bs.indent,
                    startOnNewline: true
                });
                if (!props.found) {
                    if (props.anchor || props.tag || value) {
                        if (value && value.type === 'block-seq') onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                        else onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
                    } else {
                        commentEnd = props.end;
                        if (props.comment) seq.comment = props.comment;
                        continue;
                    }
                }
                var node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
                if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
                offset = node.range[2];
                seq.items.push(node);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        seq.range = [
            bs.offset,
            offset,
            commentEnd !== null && commentEnd !== undefined ? commentEnd : offset
        ];
        return seq;
    }
    resolveBlockSeq.resolveBlockSeq = resolveBlockSeq$1;
    return resolveBlockSeq;
}

var resolveFlowCollection = {};

var resolveEnd = {};

var hasRequiredResolveEnd;
function requireResolveEnd() {
    if (hasRequiredResolveEnd) return resolveEnd;
    hasRequiredResolveEnd = 1;
    function resolveEnd$1(end, offset, reqSpace, onError) {
        var comment = '';
        if (end) {
            var hasSpace = false;
            var sep = '';
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = end[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var token = _step.value;
                    var source = token.source, type = token.type;
                    switch(type){
                        case 'space':
                            hasSpace = true;
                            break;
                        case 'comment':
                            {
                                if (reqSpace && !hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                                var cb = source.substring(1) || ' ';
                                if (!comment) comment = cb;
                                else comment += sep + cb;
                                sep = '';
                                break;
                            }
                        case 'newline':
                            if (comment) sep += source;
                            hasSpace = true;
                            break;
                        default:
                            onError(token, 'UNEXPECTED_TOKEN', "Unexpected ".concat(type, " at node end"));
                    }
                    offset += source.length;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
        return {
            comment: comment,
            offset: offset
        };
    }
    resolveEnd.resolveEnd = resolveEnd$1;
    return resolveEnd;
}

function _array_like_to_array$c(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$7(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array$7(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_rest$7() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_array(arr) {
    return _array_with_holes$7(arr) || _iterable_to_array$7(arr) || _unsupported_iterable_to_array$c(arr) || _non_iterable_rest$7();
}
function _unsupported_iterable_to_array$c(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$c(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$c(o, minLen);
}
var hasRequiredResolveFlowCollection;
function requireResolveFlowCollection() {
    if (hasRequiredResolveFlowCollection) return resolveFlowCollection;
    hasRequiredResolveFlowCollection = 1;
    var identity = requireIdentity();
    var Pair = requirePair();
    var YAMLMap = requireYAMLMap();
    var YAMLSeq = requireYAMLSeq();
    var resolveEnd = requireResolveEnd();
    var resolveProps = requireResolveProps();
    var utilContainsNewline = requireUtilContainsNewline();
    var utilMapIncludes = requireUtilMapIncludes();
    var blockMsg = 'Block collections are not allowed within flow collections';
    var isBlock = function(token) {
        return token && (token.type === 'block-map' || token.type === 'block-seq');
    };
    function resolveFlowCollection$1(param, ctx, fc, onError, tag) {
        var composeNode = param.composeNode, composeEmptyNode = param.composeEmptyNode;
        var isMap = fc.start.source === '{';
        var fcName = isMap ? 'flow map' : 'flow sequence';
        var _tag_nodeClass;
        var NodeClass = (_tag_nodeClass = tag === null || tag === undefined ? undefined : tag.nodeClass) !== null && _tag_nodeClass !== undefined ? _tag_nodeClass : isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq;
        var coll = new NodeClass(ctx.schema);
        coll.flow = true;
        var atRoot = ctx.atRoot;
        if (atRoot) ctx.atRoot = false;
        if (ctx.atKey) ctx.atKey = false;
        var offset = fc.offset + fc.start.source.length;
        for(var i = 0; i < fc.items.length; ++i){
            var collItem = fc.items[i];
            var start = collItem.start, key = collItem.key, sep = collItem.sep, value = collItem.value;
            var props = resolveProps.resolveProps(start, {
                flow: fcName,
                indicator: 'explicit-key-ind',
                next: key !== null && key !== undefined ? key : sep === null || sep === undefined ? undefined : sep[0],
                offset: offset,
                onError: onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (!props.found) {
                if (!props.anchor && !props.tag && !sep && !value) {
                    if (i === 0 && props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', "Unexpected , in ".concat(fcName));
                    else if (i < fc.items.length - 1) onError(props.start, 'UNEXPECTED_TOKEN', "Unexpected empty item in ".concat(fcName));
                    if (props.comment) {
                        if (coll.comment) coll.comment += '\n' + props.comment;
                        else coll.comment = props.comment;
                    }
                    offset = props.end;
                    continue;
                }
                if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key)) onError(key, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
            }
            if (i === 0) {
                if (props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', "Unexpected , in ".concat(fcName));
            } else {
                if (!props.comma) onError(props.start, 'MISSING_CHAR', "Missing , between ".concat(fcName, " items"));
                if (props.comment) {
                    var prevItemComment = '';
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        loop: for(var _iterator = start[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var st = _step.value;
                            switch(st.type){
                                case 'comma':
                                case 'space':
                                    break;
                                case 'comment':
                                    prevItemComment = st.source.substring(1);
                                    break loop;
                                default:
                                    break loop;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    if (prevItemComment) {
                        var prev = coll.items[coll.items.length - 1];
                        var _prev_value;
                        if (identity.isPair(prev)) prev = (_prev_value = prev.value) !== null && _prev_value !== undefined ? _prev_value : prev.key;
                        if (prev.comment) prev.comment += '\n' + prevItemComment;
                        else prev.comment = prevItemComment;
                        props.comment = props.comment.substring(prevItemComment.length + 1);
                    }
                }
            }
            if (!isMap && !sep && !props.found) {
                // item is a value in a seq
                // → key & sep are empty, start does not include ? or :
                var valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
                coll.items.push(valueNode);
                offset = valueNode.range[2];
                if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            } else {
                // item is a key+value pair
                // key value
                ctx.atKey = true;
                var keyStart = props.end;
                var keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
                if (isBlock(key)) onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
                ctx.atKey = false;
                // value properties
                var valueProps = resolveProps.resolveProps(sep !== null && sep !== undefined ? sep : [], {
                    flow: fcName,
                    indicator: 'map-value-ind',
                    next: value,
                    offset: keyNode.range[2],
                    onError: onError,
                    parentIndent: fc.indent,
                    startOnNewline: false
                });
                if (valueProps.found) {
                    if (!isMap && !props.found && ctx.options.strict) {
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        if (sep) try {
                            for(var _iterator1 = sep[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var st1 = _step1.value;
                                if (st1 === valueProps.found) break;
                                if (st1.type === 'newline') {
                                    onError(st1, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                    break;
                                }
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                        if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                    }
                } else if (value) {
                    if ('source' in value && value.source && value.source[0] === ':') onError(value, 'MISSING_CHAR', "Missing space after : in ".concat(fcName));
                    else onError(valueProps.start, 'MISSING_CHAR', "Missing , or : between ".concat(fcName, " items"));
                }
                // value value
                var valueNode1 = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
                if (valueNode1) {
                    if (isBlock(value)) onError(valueNode1.range, 'BLOCK_IN_FLOW', blockMsg);
                } else if (valueProps.comment) {
                    if (keyNode.comment) keyNode.comment += '\n' + valueProps.comment;
                    else keyNode.comment = valueProps.comment;
                }
                var pair = new Pair.Pair(keyNode, valueNode1);
                if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
                if (isMap) {
                    var map = coll;
                    if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                    map.items.push(pair);
                } else {
                    var map1 = new YAMLMap.YAMLMap(ctx.schema);
                    map1.flow = true;
                    map1.items.push(pair);
                    var endRange = (valueNode1 !== null && valueNode1 !== undefined ? valueNode1 : keyNode).range;
                    map1.range = [
                        keyNode.range[0],
                        endRange[1],
                        endRange[2]
                    ];
                    coll.items.push(map1);
                }
                offset = valueNode1 ? valueNode1.range[2] : valueProps.end;
            }
        }
        var expectedEnd = isMap ? '}' : ']';
        var _fc_end = _to_array(fc.end), ce = _fc_end[0], ee = _fc_end.slice(1);
        var cePos = offset;
        if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;
        else {
            var name = fcName[0].toUpperCase() + fcName.substring(1);
            var msg = atRoot ? "".concat(name, " must end with a ").concat(expectedEnd) : "".concat(name, " in block collection must be sufficiently indented and end with a ").concat(expectedEnd);
            onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
            if (ce && ce.source.length !== 1) ee.unshift(ce);
        }
        if (ee.length > 0) {
            var end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
            if (end.comment) {
                if (coll.comment) coll.comment += '\n' + end.comment;
                else coll.comment = end.comment;
            }
            coll.range = [
                fc.offset,
                cePos,
                end.offset
            ];
        } else {
            coll.range = [
                fc.offset,
                cePos,
                cePos
            ];
        }
        return coll;
    }
    resolveFlowCollection.resolveFlowCollection = resolveFlowCollection$1;
    return resolveFlowCollection;
}

var hasRequiredComposeCollection;
function requireComposeCollection() {
    if (hasRequiredComposeCollection) return composeCollection;
    hasRequiredComposeCollection = 1;
    var identity = requireIdentity();
    var Scalar = requireScalar();
    var YAMLMap = requireYAMLMap();
    var YAMLSeq = requireYAMLSeq();
    var resolveBlockMap = requireResolveBlockMap();
    var resolveBlockSeq = requireResolveBlockSeq();
    var resolveFlowCollection = requireResolveFlowCollection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
        var coll = token.type === 'block-map' ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === 'block-seq' ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
        var Coll = coll.constructor;
        // If we got a tagName matching the class, or the tag name is '!',
        // then use the tagName from the node class used to create it.
        if (tagName === '!' || tagName === Coll.tagName) {
            coll.tag = Coll.tagName;
            return coll;
        }
        if (tagName) coll.tag = tagName;
        return coll;
    }
    function composeCollection$1(CN, ctx, token, props, onError) {
        var _tag_resolve;
        var tagToken = props.tag;
        var tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, function(msg) {
            return onError(tagToken, 'TAG_RESOLVE_FAILED', msg);
        });
        if (token.type === 'block-seq') {
            var anchor = props.anchor, nl = props.newlineAfterProp;
            var lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor !== null && anchor !== undefined ? anchor : tagToken;
            if (lastProp && (!nl || nl.offset < lastProp.offset)) {
                var message = 'Missing newline after block sequence props';
                onError(lastProp, 'MISSING_CHAR', message);
            }
        }
        var expType = token.type === 'block-map' ? 'map' : token.type === 'block-seq' ? 'seq' : token.start.source === '{' ? 'map' : 'seq';
        // shortcut: check if it's a generic YAMLMap or YAMLSeq
        // before jumping into the custom tag logic.
        if (!tagToken || !tagName || tagName === '!' || tagName === YAMLMap.YAMLMap.tagName && expType === 'map' || tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq') {
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
        var tag = ctx.schema.tags.find(function(t) {
            return t.tag === tagName && t.collection === expType;
        });
        if (!tag) {
            var kt = ctx.schema.knownTags[tagName];
            if (kt && kt.collection === expType) {
                ctx.schema.tags.push(Object.assign({}, kt, {
                    default: false
                }));
                tag = kt;
            } else {
                if (kt === null || kt === undefined ? undefined : kt.collection) {
                    onError(tagToken, 'BAD_COLLECTION_TYPE', "".concat(kt.tag, " used for ").concat(expType, " collection, but expects ").concat(kt.collection), true);
                } else {
                    onError(tagToken, 'TAG_RESOLVE_FAILED', "Unresolved tag: ".concat(tagName), true);
                }
                return resolveCollection(CN, ctx, token, onError, tagName);
            }
        }
        var coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
        var _tag_resolve1;
        var res = (_tag_resolve1 = (_tag_resolve = tag.resolve) === null || _tag_resolve === undefined ? undefined : _tag_resolve.call(tag, coll, function(msg) {
            return onError(tagToken, 'TAG_RESOLVE_FAILED', msg);
        }, ctx.options)) !== null && _tag_resolve1 !== undefined ? _tag_resolve1 : coll;
        var node = identity.isNode(res) ? res : new Scalar.Scalar(res);
        node.range = coll.range;
        node.tag = tagName;
        if (tag === null || tag === undefined ? undefined : tag.format) node.format = tag.format;
        return node;
    }
    composeCollection.composeCollection = composeCollection$1;
    return composeCollection;
}

var composeScalar = {};

var resolveBlockScalar = {};

function _array_like_to_array$b(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$6(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$6(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$6() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$6(arr, i) {
    return _array_with_holes$6(arr) || _iterable_to_array_limit$6(arr, i) || _unsupported_iterable_to_array$b(arr, i) || _non_iterable_rest$6();
}
function _unsupported_iterable_to_array$b(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$b(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$b(o, minLen);
}
var hasRequiredResolveBlockScalar;
function requireResolveBlockScalar() {
    if (hasRequiredResolveBlockScalar) return resolveBlockScalar;
    hasRequiredResolveBlockScalar = 1;
    var Scalar = requireScalar();
    function resolveBlockScalar$1(ctx, scalar, onError) {
        var start = scalar.offset;
        var header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
        if (!header) return {
            value: '',
            type: null,
            comment: '',
            range: [
                start,
                start,
                start
            ]
        };
        var type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
        var lines = scalar.source ? splitLines(scalar.source) : [];
        // determine the end of content & start of chomping
        var chompStart = lines.length;
        for(var i = lines.length - 1; i >= 0; --i){
            var content = lines[i][1];
            if (content === '' || content === '\r') chompStart = i;
            else break;
        }
        // shortcut for empty contents
        if (chompStart === 0) {
            var value = header.chomp === '+' && lines.length > 0 ? '\n'.repeat(Math.max(1, lines.length - 1)) : '';
            var end = start + header.length;
            if (scalar.source) end += scalar.source.length;
            return {
                value: value,
                type: type,
                comment: header.comment,
                range: [
                    start,
                    end,
                    end
                ]
            };
        }
        // find the indentation level to trim from start
        var trimIndent = scalar.indent + header.indent;
        var offset = scalar.offset + header.length;
        var contentStart = 0;
        for(var i1 = 0; i1 < chompStart; ++i1){
            var _lines_i = _sliced_to_array$6(lines[i1], 2), indent = _lines_i[0], content1 = _lines_i[1];
            if (content1 === '' || content1 === '\r') {
                if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
            } else {
                if (indent.length < trimIndent) {
                    var message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                    onError(offset + indent.length, 'MISSING_CHAR', message);
                }
                if (header.indent === 0) trimIndent = indent.length;
                contentStart = i1;
                if (trimIndent === 0 && !ctx.atRoot) {
                    var message1 = 'Block scalar values in collections must be indented';
                    onError(offset, 'BAD_INDENT', message1);
                }
                break;
            }
            offset += indent.length + content1.length + 1;
        }
        // include trailing more-indented empty lines in content
        for(var i2 = lines.length - 1; i2 >= chompStart; --i2){
            if (lines[i2][0].length > trimIndent) chompStart = i2 + 1;
        }
        var value1 = '';
        var sep = '';
        var prevMoreIndented = false;
        // leading whitespace is kept intact
        for(var i3 = 0; i3 < contentStart; ++i3)value1 += lines[i3][0].slice(trimIndent) + '\n';
        for(var i4 = contentStart; i4 < chompStart; ++i4){
            var _lines_i1 = _sliced_to_array$6(lines[i4], 2), indent1 = _lines_i1[0], content2 = _lines_i1[1];
            offset += indent1.length + content2.length + 1;
            var crlf = content2[content2.length - 1] === '\r';
            if (crlf) content2 = content2.slice(0, -1);
            /* istanbul ignore if already caught in lexer */ if (content2 && indent1.length < trimIndent) {
                var src = header.indent ? 'explicit indentation indicator' : 'first line';
                var message2 = "Block scalar lines must not be less indented than their ".concat(src);
                onError(offset - content2.length - (crlf ? 2 : 1), 'BAD_INDENT', message2);
                indent1 = '';
            }
            if (type === Scalar.Scalar.BLOCK_LITERAL) {
                value1 += sep + indent1.slice(trimIndent) + content2;
                sep = '\n';
            } else if (indent1.length > trimIndent || content2[0] === '\t') {
                // more-indented content within a folded block
                if (sep === ' ') sep = '\n';
                else if (!prevMoreIndented && sep === '\n') sep = '\n\n';
                value1 += sep + indent1.slice(trimIndent) + content2;
                sep = '\n';
                prevMoreIndented = true;
            } else if (content2 === '') {
                // empty line
                if (sep === '\n') value1 += '\n';
                else sep = '\n';
            } else {
                value1 += sep + content2;
                sep = ' ';
                prevMoreIndented = false;
            }
        }
        switch(header.chomp){
            case '-':
                break;
            case '+':
                for(var i5 = chompStart; i5 < lines.length; ++i5)value1 += '\n' + lines[i5][0].slice(trimIndent);
                if (value1[value1.length - 1] !== '\n') value1 += '\n';
                break;
            default:
                value1 += '\n';
        }
        var end1 = start + header.length + scalar.source.length;
        return {
            value: value1,
            type: type,
            comment: header.comment,
            range: [
                start,
                end1,
                end1
            ]
        };
    }
    function parseBlockScalarHeader(param, strict, onError) {
        var offset = param.offset, props = param.props;
        /* istanbul ignore if should not happen */ if (props[0].type !== 'block-scalar-header') {
            onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
            return null;
        }
        var source = props[0].source;
        var mode = source[0];
        var indent = 0;
        var chomp = '';
        var error = -1;
        for(var i = 1; i < source.length; ++i){
            var ch = source[i];
            if (!chomp && (ch === '-' || ch === '+')) chomp = ch;
            else {
                var n = Number(ch);
                if (!indent && n) indent = n;
                else if (error === -1) error = offset + i;
            }
        }
        if (error !== -1) onError(error, 'UNEXPECTED_TOKEN', "Block scalar header includes extra characters: ".concat(source));
        var hasSpace = false;
        var comment = '';
        var length = source.length;
        for(var i1 = 1; i1 < props.length; ++i1){
            var token = props[i1];
            switch(token.type){
                case 'space':
                    hasSpace = true;
                // fallthrough
                case 'newline':
                    length += token.source.length;
                    break;
                case 'comment':
                    if (strict && !hasSpace) {
                        var message = 'Comments must be separated from other tokens by white space characters';
                        onError(token, 'MISSING_CHAR', message);
                    }
                    length += token.source.length;
                    comment = token.source.substring(1);
                    break;
                case 'error':
                    onError(token, 'UNEXPECTED_TOKEN', token.message);
                    length += token.source.length;
                    break;
                /* istanbul ignore next should not happen */ default:
                    {
                        var message1 = "Unexpected token in block scalar header: ".concat(token.type);
                        onError(token, 'UNEXPECTED_TOKEN', message1);
                        var ts = token.source;
                        if (ts && typeof ts === 'string') length += ts.length;
                    }
            }
        }
        return {
            mode: mode,
            indent: indent,
            chomp: chomp,
            comment: comment,
            length: length
        };
    }
    /** @returns Array of lines split up as `[indent, content]` */ function splitLines(source) {
        var split = source.split(/\n( *)/);
        var first = split[0];
        var m = first.match(/^( *)/);
        var line0 = (m === null || m === undefined ? undefined : m[1]) ? [
            m[1],
            first.slice(m[1].length)
        ] : [
            '',
            first
        ];
        var lines = [
            line0
        ];
        for(var i = 1; i < split.length; i += 2)lines.push([
            split[i],
            split[i + 1]
        ]);
        return lines;
    }
    resolveBlockScalar.resolveBlockScalar = resolveBlockScalar$1;
    return resolveBlockScalar;
}

var resolveFlowScalar = {};

var hasRequiredResolveFlowScalar;
function requireResolveFlowScalar() {
    if (hasRequiredResolveFlowScalar) return resolveFlowScalar;
    hasRequiredResolveFlowScalar = 1;
    var Scalar = requireScalar();
    var resolveEnd = requireResolveEnd();
    function resolveFlowScalar$1(scalar, strict, onError) {
        var offset = scalar.offset, type = scalar.type, source = scalar.source, end = scalar.end;
        var _type;
        var value;
        var _onError = function(rel, code, msg) {
            return onError(offset + rel, code, msg);
        };
        switch(type){
            case 'scalar':
                _type = Scalar.Scalar.PLAIN;
                value = plainValue(source, _onError);
                break;
            case 'single-quoted-scalar':
                _type = Scalar.Scalar.QUOTE_SINGLE;
                value = singleQuotedValue(source, _onError);
                break;
            case 'double-quoted-scalar':
                _type = Scalar.Scalar.QUOTE_DOUBLE;
                value = doubleQuotedValue(source, _onError);
                break;
            /* istanbul ignore next should not happen */ default:
                onError(scalar, 'UNEXPECTED_TOKEN', "Expected a flow scalar value, but found: ".concat(type));
                return {
                    value: '',
                    type: null,
                    comment: '',
                    range: [
                        offset,
                        offset + source.length,
                        offset + source.length
                    ]
                };
        }
        var valueEnd = offset + source.length;
        var re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
        return {
            value: value,
            type: _type,
            comment: re.comment,
            range: [
                offset,
                valueEnd,
                re.offset
            ]
        };
    }
    function plainValue(source, onError) {
        var badChar = '';
        switch(source[0]){
            /* istanbul ignore next should not happen */ case '\t':
                badChar = 'a tab character';
                break;
            case ',':
                badChar = 'flow indicator character ,';
                break;
            case '%':
                badChar = 'directive indicator character %';
                break;
            case '|':
            case '>':
                {
                    badChar = "block scalar indicator ".concat(source[0]);
                    break;
                }
            case '@':
            case '`':
                {
                    badChar = "reserved character ".concat(source[0]);
                    break;
                }
        }
        if (badChar) onError(0, 'BAD_SCALAR_START', "Plain value cannot start with ".concat(badChar));
        return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
        if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
        return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
        /**
	     * The negative lookbehind here and in the `re` RegExp is to
	     * prevent causing a polynomial search time in certain cases.
	     *
	     * The try-catch is for Safari, which doesn't support this yet:
	     * https://caniuse.com/js-regexp-lookbehind
	     */ var first, line;
        try {
            first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
            line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
        } catch (e) {
            first = RegExp("(.*?)[ \\t]*\\r?\\n", "sy");
            line = RegExp("[ \\t]*(.*?)[ \\t]*\\r?\\n", "sy");
        }
        var match = first.exec(source);
        if (!match) return source;
        var res = match[1];
        var sep = ' ';
        var pos = first.lastIndex;
        line.lastIndex = pos;
        while(match = line.exec(source)){
            if (match[1] === '') {
                if (sep === '\n') res += sep;
                else sep = '\n';
            } else {
                res += sep + match[1];
                sep = ' ';
            }
            pos = line.lastIndex;
        }
        var last = RegExp("[ \\t]*(.*)", "sy");
        last.lastIndex = pos;
        match = last.exec(source);
        var _match_;
        return res + sep + ((_match_ = match === null || match === undefined ? undefined : match[1]) !== null && _match_ !== undefined ? _match_ : '');
    }
    function doubleQuotedValue(source, onError) {
        var res = '';
        for(var i = 1; i < source.length - 1; ++i){
            var ch = source[i];
            if (ch === '\r' && source[i + 1] === '\n') continue;
            if (ch === '\n') {
                var _foldNewline = foldNewline(source, i), fold = _foldNewline.fold, offset = _foldNewline.offset;
                res += fold;
                i = offset;
            } else if (ch === '\\') {
                var next = source[++i];
                var cc = escapeCodes[next];
                if (cc) res += cc;
                else if (next === '\n') {
                    // skip escaped newlines, but still trim the following line
                    next = source[i + 1];
                    while(next === ' ' || next === '\t')next = source[++i + 1];
                } else if (next === '\r' && source[i + 1] === '\n') {
                    // skip escaped CRLF newlines, but still trim the following line
                    next = source[++i + 1];
                    while(next === ' ' || next === '\t')next = source[++i + 1];
                } else if (next === 'x' || next === 'u' || next === 'U') {
                    var length = {
                        x: 2,
                        u: 4,
                        U: 8
                    }[next];
                    res += parseCharCode(source, i + 1, length, onError);
                    i += length;
                } else {
                    var raw = source.substr(i - 1, 2);
                    onError(i - 1, 'BAD_DQ_ESCAPE', "Invalid escape sequence ".concat(raw));
                    res += raw;
                }
            } else if (ch === ' ' || ch === '\t') {
                // trim trailing whitespace
                var wsStart = i;
                var next1 = source[i + 1];
                while(next1 === ' ' || next1 === '\t')next1 = source[++i + 1];
                if (next1 !== '\n' && !(next1 === '\r' && source[i + 2] === '\n')) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
            } else {
                res += ch;
            }
        }
        if (source[source.length - 1] !== '"' || source.length === 1) onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
        return res;
    }
    /**
	 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
	 * Presumes `source[offset] === '\n'`
	 */ function foldNewline(source, offset) {
        var fold = '';
        var ch = source[offset + 1];
        while(ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r'){
            if (ch === '\r' && source[offset + 2] !== '\n') break;
            if (ch === '\n') fold += '\n';
            offset += 1;
            ch = source[offset + 1];
        }
        if (!fold) fold = ' ';
        return {
            fold: fold,
            offset: offset
        };
    }
    var escapeCodes = {
        '0': '\0',
        a: '\x07',
        b: '\b',
        e: '\x1b',
        f: '\f',
        n: '\n',
        r: '\r',
        t: '\t',
        v: '\v',
        N: '\u0085',
        _: '\u00a0',
        L: '\u2028',
        P: '\u2029',
        ' ': ' ',
        '"': '"',
        '/': '/',
        '\\': '\\',
        '\t': '\t'
    };
    function parseCharCode(source, offset, length, onError) {
        var cc = source.substr(offset, length);
        var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        var code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
            var raw = source.substr(offset - 2, length + 2);
            onError(offset - 2, 'BAD_DQ_ESCAPE', "Invalid escape sequence ".concat(raw));
            return raw;
        }
        return String.fromCodePoint(code);
    }
    resolveFlowScalar.resolveFlowScalar = resolveFlowScalar$1;
    return resolveFlowScalar;
}

function _instanceof$9(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var hasRequiredComposeScalar;
function requireComposeScalar() {
    if (hasRequiredComposeScalar) return composeScalar;
    hasRequiredComposeScalar = 1;
    var identity = requireIdentity();
    var Scalar = requireScalar();
    var resolveBlockScalar = requireResolveBlockScalar();
    var resolveFlowScalar = requireResolveFlowScalar();
    function composeScalar$1(ctx, token, tagToken, onError) {
        var _ref = token.type === 'block-scalar' ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError), value = _ref.value, type = _ref.type, comment = _ref.comment, range = _ref.range;
        var tagName = tagToken ? ctx.directives.tagName(tagToken.source, function(msg) {
            return onError(tagToken, 'TAG_RESOLVE_FAILED', msg);
        }) : null;
        var tag;
        if (ctx.options.stringKeys && ctx.atKey) {
            tag = ctx.schema[identity.SCALAR];
        } else if (tagName) tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
        else if (token.type === 'scalar') tag = findScalarTagByTest(ctx, value, token, onError);
        else tag = ctx.schema[identity.SCALAR];
        var scalar;
        try {
            var res = tag.resolve(value, function(msg) {
                return onError(tagToken !== null && tagToken !== void 0 ? tagToken : token, 'TAG_RESOLVE_FAILED', msg);
            }, ctx.options);
            scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
        } catch (error) {
            var msg = _instanceof$9(error, Error) ? error.message : String(error);
            onError(tagToken !== null && tagToken !== undefined ? tagToken : token, 'TAG_RESOLVE_FAILED', msg);
            scalar = new Scalar.Scalar(value);
        }
        scalar.range = range;
        scalar.source = value;
        if (type) scalar.type = type;
        if (tagName) scalar.tag = tagName;
        if (tag.format) scalar.format = tag.format;
        if (comment) scalar.comment = comment;
        return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
        var _tag_test;
        if (tagName === '!') return schema[identity.SCALAR]; // non-specific tag
        var matchWithTest = [];
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = schema.tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var tag = _step.value;
                if (!tag.collection && tag.tag === tagName) {
                    if (tag.default && tag.test) matchWithTest.push(tag);
                    else return tag;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = matchWithTest[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var tag1 = _step1.value;
                if ((_tag_test = tag1.test) === null || _tag_test === void 0 ? void 0 : _tag_test.test(value)) return tag1;
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        var kt = schema.knownTags[tagName];
        if (kt && !kt.collection) {
            // Ensure that the known tag is available for stringifying,
            // but does not get used by default.
            schema.tags.push(Object.assign({}, kt, {
                default: false,
                test: undefined
            }));
            return kt;
        }
        onError(tagToken, 'TAG_RESOLVE_FAILED', "Unresolved tag: ".concat(tagName), tagName !== 'tag:yaml.org,2002:str');
        return schema[identity.SCALAR];
    }
    function findScalarTagByTest(param, value, token, onError) {
        var atKey = param.atKey, directives = param.directives, schema = param.schema;
        var tag = schema.tags.find(function(tag) {
            var _tag_test;
            return (tag.default === true || atKey && tag.default === 'key') && ((_tag_test = tag.test) === null || _tag_test === undefined ? undefined : _tag_test.test(value));
        }) || schema[identity.SCALAR];
        if (schema.compat) {
            var _schema_compat_find;
            var compat = (_schema_compat_find = schema.compat.find(function(tag) {
                var _tag_test;
                return tag.default && ((_tag_test = tag.test) === null || _tag_test === undefined ? undefined : _tag_test.test(value));
            })) !== null && _schema_compat_find !== undefined ? _schema_compat_find : schema[identity.SCALAR];
            if (tag.tag !== compat.tag) {
                var ts = directives.tagString(tag.tag);
                var cs = directives.tagString(compat.tag);
                var msg = "Value may be parsed as either ".concat(ts, " or ").concat(cs);
                onError(token, 'TAG_RESOLVE_FAILED', msg, true);
            }
        }
        return tag;
    }
    composeScalar.composeScalar = composeScalar$1;
    return composeScalar;
}

var utilEmptyScalarPosition = {};

var hasRequiredUtilEmptyScalarPosition;
function requireUtilEmptyScalarPosition() {
    if (hasRequiredUtilEmptyScalarPosition) return utilEmptyScalarPosition;
    hasRequiredUtilEmptyScalarPosition = 1;
    function emptyScalarPosition(offset, before, pos) {
        if (before) {
            if (pos === null) pos = before.length;
            for(var i = pos - 1; i >= 0; --i){
                var st = before[i];
                switch(st.type){
                    case 'space':
                    case 'comment':
                    case 'newline':
                        offset -= st.source.length;
                        continue;
                }
                // Technically, an empty scalar is immediately after the last non-empty
                // node, but it's more useful to place it after any whitespace.
                st = before[++i];
                while((st === null || st === undefined ? undefined : st.type) === 'space'){
                    offset += st.source.length;
                    st = before[++i];
                }
                break;
            }
        }
        return offset;
    }
    utilEmptyScalarPosition.emptyScalarPosition = emptyScalarPosition;
    return utilEmptyScalarPosition;
}

var hasRequiredComposeNode;
function requireComposeNode() {
    if (hasRequiredComposeNode) return composeNode;
    hasRequiredComposeNode = 1;
    var Alias = requireAlias();
    var identity = requireIdentity();
    var composeCollection = requireComposeCollection();
    var composeScalar = requireComposeScalar();
    var resolveEnd = requireResolveEnd();
    var utilEmptyScalarPosition = requireUtilEmptyScalarPosition();
    var CN = {
        composeNode: composeNode$1,
        composeEmptyNode: composeEmptyNode
    };
    function composeNode$1(ctx, token, props, onError) {
        var atKey = ctx.atKey;
        var spaceBefore = props.spaceBefore, comment = props.comment, anchor = props.anchor, tag = props.tag;
        var node;
        var isSrcToken = true;
        switch(token.type){
            case 'alias':
                node = composeAlias(ctx, token, onError);
                if (anchor || tag) onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
                break;
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
            case 'block-scalar':
                node = composeScalar.composeScalar(ctx, token, tag, onError);
                if (anchor) node.anchor = anchor.source.substring(1);
                break;
            case 'block-map':
            case 'block-seq':
            case 'flow-collection':
                node = composeCollection.composeCollection(CN, ctx, token, props, onError);
                if (anchor) node.anchor = anchor.source.substring(1);
                break;
            default:
                {
                    var message = token.type === 'error' ? token.message : "Unsupported token (type: ".concat(token.type, ")");
                    onError(token, 'UNEXPECTED_TOKEN', message);
                    node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
                    isSrcToken = false;
                }
        }
        if (anchor && node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
        if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== 'string' || node.tag && node.tag !== 'tag:yaml.org,2002:str')) {
            var msg = 'With stringKeys, all keys must be strings';
            onError(tag !== null && tag !== undefined ? tag : token, 'NON_STRING_KEY', msg);
        }
        if (spaceBefore) node.spaceBefore = true;
        if (comment) {
            if (token.type === 'scalar' && token.source === '') node.comment = comment;
            else node.commentBefore = comment;
        }
        // @ts-expect-error Type checking misses meaning of isSrcToken
        if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
        return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, param, onError) {
        var spaceBefore = param.spaceBefore, comment = param.comment, anchor = param.anchor, tag = param.tag, end = param.end;
        var token = {
            type: 'scalar',
            offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
            indent: -1,
            source: ''
        };
        var node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor) {
            node.anchor = anchor.source.substring(1);
            if (node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
        }
        if (spaceBefore) node.spaceBefore = true;
        if (comment) {
            node.comment = comment;
            node.range[2] = end;
        }
        return node;
    }
    function composeAlias(param, param1, onError) {
        var options = param.options, offset = param1.offset, source = param1.source, end = param1.end;
        var alias = new Alias.Alias(source.substring(1));
        if (alias.source === '') onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
        if (alias.source.endsWith(':')) onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
        var valueEnd = offset + source.length;
        var re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
        alias.range = [
            offset,
            valueEnd,
            re.offset
        ];
        if (re.comment) alias.comment = re.comment;
        return alias;
    }
    composeNode.composeEmptyNode = composeEmptyNode;
    composeNode.composeNode = composeNode$1;
    return composeNode;
}

var hasRequiredComposeDoc;
function requireComposeDoc() {
    if (hasRequiredComposeDoc) return composeDoc;
    hasRequiredComposeDoc = 1;
    var Document = requireDocument();
    var composeNode = requireComposeNode();
    var resolveEnd = requireResolveEnd();
    var resolveProps = requireResolveProps();
    function composeDoc$1(options, directives, param, onError) {
        var offset = param.offset, start = param.start, value = param.value, end = param.end;
        var opts = Object.assign({
            _directives: directives
        }, options);
        var doc = new Document.Document(undefined, opts);
        var ctx = {
            atKey: false,
            atRoot: true,
            directives: doc.directives,
            options: doc.options,
            schema: doc.schema
        };
        var props = resolveProps.resolveProps(start, {
            indicator: 'doc-start',
            next: value !== null && value !== undefined ? value : end === null || end === undefined ? undefined : end[0],
            offset: offset,
            onError: onError,
            parentIndent: 0,
            startOnNewline: true
        });
        if (props.found) {
            doc.directives.docStart = true;
            if (value && (value.type === 'block-map' || value.type === 'block-seq') && !props.hasNewline) onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
        }
        // @ts-expect-error If Contents is set, let's trust the user
        doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
        var contentEnd = doc.contents.range[2];
        var re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
        if (re.comment) doc.comment = re.comment;
        doc.range = [
            offset,
            contentEnd,
            re.offset
        ];
        return doc;
    }
    composeDoc.composeDoc = composeDoc$1;
    return composeDoc;
}

function _class_call_check$l(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _ts_generator$2(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
function _ts_values$2(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = undefined;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var hasRequiredComposer;
function requireComposer() {
    if (hasRequiredComposer) return composer;
    hasRequiredComposer = 1;
    var node_process = require$$0$4;
    var directives = requireDirectives();
    var Document = requireDocument();
    var errors = requireErrors();
    var identity = requireIdentity();
    var composeDoc = requireComposeDoc();
    var resolveEnd = requireResolveEnd();
    function getErrorPos(src) {
        if (typeof src === 'number') return [
            src,
            src + 1
        ];
        if (Array.isArray(src)) return src.length === 2 ? src : [
            src[0],
            src[1]
        ];
        var offset = src.offset, source = src.source;
        return [
            offset,
            offset + (typeof source === 'string' ? source.length : 1)
        ];
    }
    function parsePrelude(prelude) {
        var comment = '';
        var atComment = false;
        var afterEmptyLine = false;
        for(var i = 0; i < prelude.length; ++i){
            var source = prelude[i];
            switch(source[0]){
                case '#':
                    comment += (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') + (source.substring(1) || ' ');
                    atComment = true;
                    afterEmptyLine = false;
                    break;
                case '%':
                    var _prelude_;
                    if (((_prelude_ = prelude[i + 1]) === null || _prelude_ === undefined ? undefined : _prelude_[0]) !== '#') i += 1;
                    atComment = false;
                    break;
                default:
                    // This may be wrong after doc-end, but in that case it doesn't matter
                    if (!atComment) afterEmptyLine = true;
                    atComment = false;
            }
        }
        return {
            comment: comment,
            afterEmptyLine: afterEmptyLine
        };
    }
    /**
	 * Compose a stream of CST nodes into a stream of YAML Documents.
	 *
	 * ```ts
	 * import { Composer, Parser } from 'yaml'
	 *
	 * const src: string = ...
	 * const tokens = new Parser().parse(src)
	 * const docs = new Composer().compose(tokens)
	 * ```
	 */ var Composer = /*#__PURE__*/ function() {
        function Composer() {
            var _this = this;
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _class_call_check$l(this, Composer);
            this.doc = null;
            this.atDirectives = false;
            this.prelude = [];
            this.errors = [];
            this.warnings = [];
            this.onError = function(source, code, message, warning) {
                var pos = getErrorPos(source);
                if (warning) _this.warnings.push(new errors.YAMLWarning(pos, code, message));
                else _this.errors.push(new errors.YAMLParseError(pos, code, message));
            };
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            this.directives = new directives.Directives({
                version: options.version || '1.2'
            });
            this.options = options;
        }
        var _proto = Composer.prototype;
        _proto.decorate = function decorate(doc, afterDoc) {
            var _parsePrelude = parsePrelude(this.prelude), comment = _parsePrelude.comment, afterEmptyLine = _parsePrelude.afterEmptyLine;
            //console.log({ dc: doc.comment, prelude, comment })
            if (comment) {
                var dc = doc.contents;
                if (afterDoc) {
                    doc.comment = doc.comment ? "".concat(doc.comment, "\n").concat(comment) : comment;
                } else if (afterEmptyLine || doc.directives.docStart || !dc) {
                    doc.commentBefore = comment;
                } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                    var it = dc.items[0];
                    if (identity.isPair(it)) it = it.key;
                    var cb = it.commentBefore;
                    it.commentBefore = cb ? "".concat(comment, "\n").concat(cb) : comment;
                } else {
                    var cb1 = dc.commentBefore;
                    dc.commentBefore = cb1 ? "".concat(comment, "\n").concat(cb1) : comment;
                }
            }
            if (afterDoc) {
                Array.prototype.push.apply(doc.errors, this.errors);
                Array.prototype.push.apply(doc.warnings, this.warnings);
            } else {
                doc.errors = this.errors;
                doc.warnings = this.warnings;
            }
            this.prelude = [];
            this.errors = [];
            this.warnings = [];
        };
        /**
	     * Current stream status information.
	     *
	     * Mostly useful at the end of input for an empty stream.
	     */ _proto.streamInfo = function streamInfo() {
            return {
                comment: parsePrelude(this.prelude).comment,
                directives: this.directives,
                errors: this.errors,
                warnings: this.warnings
            };
        };
        /**
	     * Compose tokens into documents.
	     *
	     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
	     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
	     */ _proto.compose = function compose(tokens) {
            var forceDoc, endOffset, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, token, err;
            var _arguments = arguments;
            return _ts_generator$2(this, function(_state) {
                switch(_state.label){
                    case 0:
                        forceDoc = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false, endOffset = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : -1;
                        _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        _state.label = 1;
                    case 1:
                        _state.trys.push([
                            1,
                            6,
                            7,
                            8
                        ]);
                        _iterator = tokens[Symbol.iterator]();
                        _state.label = 2;
                    case 2:
                        if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                            3,
                            5
                        ];
                        token = _step.value;
                        return [
                            5,
                            _ts_values$2(this.next(token))
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        _iteratorNormalCompletion = true;
                        return [
                            3,
                            2
                        ];
                    case 5:
                        return [
                            3,
                            8
                        ];
                    case 6:
                        err = _state.sent();
                        _didIteratorError = true;
                        _iteratorError = err;
                        return [
                            3,
                            8
                        ];
                    case 7:
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                        return [
                            7
                        ];
                    case 8:
                        return [
                            5,
                            _ts_values$2(this.end(forceDoc, endOffset))
                        ];
                    case 9:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        };
        /** Advance the composer by one CST token. */ _proto.next = function next(token) {
            var _this, _, doc, msg, error, msg1, end, dc;
            return _ts_generator$2(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this = this;
                        if (node_process.env.LOG_STREAM) console.dir(token, {
                            depth: null
                        });
                        _ = token.type;
                        switch(_){
                            case 'directive':
                                return [
                                    3,
                                    1
                                ];
                            case 'document':
                                return [
                                    3,
                                    2
                                ];
                            case 'byte-order-mark':
                                return [
                                    3,
                                    5
                                ];
                            case 'space':
                                return [
                                    3,
                                    5
                                ];
                            case 'comment':
                                return [
                                    3,
                                    6
                                ];
                            case 'newline':
                                return [
                                    3,
                                    6
                                ];
                            case 'error':
                                return [
                                    3,
                                    7
                                ];
                            case 'doc-end':
                                return [
                                    3,
                                    8
                                ];
                        }
                        return [
                            3,
                            9
                        ];
                    case 1:
                        this.directives.add(token.source, function(offset, message, warning) {
                            var pos = getErrorPos(token);
                            pos[0] += offset;
                            _this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                        });
                        this.prelude.push(token.source);
                        this.atDirectives = true;
                        return [
                            3,
                            10
                        ];
                    case 2:
                        doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                        if (this.atDirectives && !doc.directives.docStart) this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                        this.decorate(doc, false);
                        if (!this.doc) return [
                            3,
                            4
                        ];
                        return [
                            4,
                            this.doc
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        this.doc = doc;
                        this.atDirectives = false;
                        return [
                            3,
                            10
                        ];
                    case 5:
                        return [
                            3,
                            10
                        ];
                    case 6:
                        this.prelude.push(token.source);
                        return [
                            3,
                            10
                        ];
                    case 7:
                        {
                            msg = token.source ? "".concat(token.message, ": ").concat(JSON.stringify(token.source)) : token.message;
                            error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                            if (this.atDirectives || !this.doc) this.errors.push(error);
                            else this.doc.errors.push(error);
                            return [
                                3,
                                10
                            ];
                        }
                    case 8:
                        {
                            if (!this.doc) {
                                msg1 = 'Unexpected doc-end without preceding document';
                                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg1));
                                return [
                                    3,
                                    10
                                ];
                            }
                            this.doc.directives.docEnd = true;
                            end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                            this.decorate(this.doc, true);
                            if (end.comment) {
                                dc = this.doc.comment;
                                this.doc.comment = dc ? "".concat(dc, "\n").concat(end.comment) : end.comment;
                            }
                            this.doc.range[2] = end.offset;
                            return [
                                3,
                                10
                            ];
                        }
                    case 9:
                        this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', "Unsupported token ".concat(token.type)));
                        _state.label = 10;
                    case 10:
                        return [
                            2
                        ];
                }
            });
        };
        /**
	     * Call at end of input to yield any remaining document.
	     *
	     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
	     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
	     */ _proto.end = function end() {
            var forceDoc, endOffset, opts, doc;
            var _arguments = arguments;
            return _ts_generator$2(this, function(_state) {
                switch(_state.label){
                    case 0:
                        forceDoc = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : false, endOffset = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : -1;
                        if (!this.doc) return [
                            3,
                            2
                        ];
                        this.decorate(this.doc, true);
                        return [
                            4,
                            this.doc
                        ];
                    case 1:
                        _state.sent();
                        this.doc = null;
                        return [
                            3,
                            4
                        ];
                    case 2:
                        if (!forceDoc) return [
                            3,
                            4
                        ];
                        opts = Object.assign({
                            _directives: this.directives
                        }, this.options);
                        doc = new Document.Document(undefined, opts);
                        if (this.atDirectives) this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
                        doc.range = [
                            0,
                            endOffset,
                            endOffset
                        ];
                        this.decorate(doc, false);
                        return [
                            4,
                            doc
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        return [
                            2
                        ];
                }
            });
        };
        return Composer;
    }();
    composer.Composer = Composer;
    return composer;
}

var cst = {};

var cstScalar = {};

var hasRequiredCstScalar;
function requireCstScalar() {
    if (hasRequiredCstScalar) return cstScalar;
    hasRequiredCstScalar = 1;
    var resolveBlockScalar = requireResolveBlockScalar();
    var resolveFlowScalar = requireResolveFlowScalar();
    var errors = requireErrors();
    var stringifyString = requireStringifyString();
    function resolveAsScalar(token) {
        var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true, onError = arguments.length > 2 ? arguments[2] : undefined;
        if (token) {
            var _onError = function(pos, code, message) {
                var offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
                if (onError) onError(offset, code, message);
                else throw new errors.YAMLParseError([
                    offset,
                    offset + 1
                ], code, message);
            };
            switch(token.type){
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar':
                    return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
                case 'block-scalar':
                    return resolveBlockScalar.resolveBlockScalar({
                        options: {
                            strict: strict
                        }
                    }, token, _onError);
            }
        }
        return null;
    }
    /**
	 * Create a new scalar token with `value`
	 *
	 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
	 * as this function does not support any schema operations and won't check for such conflicts.
	 *
	 * @param value The string representation of the value, which will have its content properly indented.
	 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
	 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
	 * @param context.indent The indent level of the token.
	 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
	 * @param context.offset The offset position of the token.
	 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
	 */ function createScalarToken(value, context) {
        var _context_implicitKey = context.implicitKey, implicitKey = _context_implicitKey === undefined ? false : _context_implicitKey, indent = context.indent, _context_inFlow = context.inFlow, inFlow = _context_inFlow === undefined ? false : _context_inFlow, _context_offset = context.offset, offset = _context_offset === undefined ? -1 : _context_offset, _context_type = context.type, type = _context_type === undefined ? 'PLAIN' : _context_type;
        var source = stringifyString.stringifyString({
            type: type,
            value: value
        }, {
            implicitKey: implicitKey,
            indent: indent > 0 ? ' '.repeat(indent) : '',
            inFlow: inFlow,
            options: {
                blockQuote: true,
                lineWidth: -1
            }
        });
        var _context_end;
        var end = (_context_end = context.end) !== null && _context_end !== undefined ? _context_end : [
            {
                type: 'newline',
                offset: -1,
                indent: indent,
                source: '\n'
            }
        ];
        switch(source[0]){
            case '|':
            case '>':
                {
                    var he = source.indexOf('\n');
                    var head = source.substring(0, he);
                    var body = source.substring(he + 1) + '\n';
                    var props = [
                        {
                            type: 'block-scalar-header',
                            offset: offset,
                            indent: indent,
                            source: head
                        }
                    ];
                    if (!addEndtoBlockProps(props, end)) props.push({
                        type: 'newline',
                        offset: -1,
                        indent: indent,
                        source: '\n'
                    });
                    return {
                        type: 'block-scalar',
                        offset: offset,
                        indent: indent,
                        props: props,
                        source: body
                    };
                }
            case '"':
                return {
                    type: 'double-quoted-scalar',
                    offset: offset,
                    indent: indent,
                    source: source,
                    end: end
                };
            case "'":
                return {
                    type: 'single-quoted-scalar',
                    offset: offset,
                    indent: indent,
                    source: source,
                    end: end
                };
            default:
                return {
                    type: 'scalar',
                    offset: offset,
                    indent: indent,
                    source: source,
                    end: end
                };
        }
    }
    /**
	 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
	 *
	 * Best efforts are made to retain any comments previously associated with the `token`,
	 * though all contents within a collection's `items` will be overwritten.
	 *
	 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
	 * as this function does not support any schema operations and won't check for such conflicts.
	 *
	 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
	 * @param value The string representation of the value, which will have its content properly indented.
	 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
	 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
	 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
	 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
	 */ function setScalarValue(token, value) {
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _context_afterKey = context.afterKey, afterKey = _context_afterKey === undefined ? false : _context_afterKey, _context_implicitKey = context.implicitKey, implicitKey = _context_implicitKey === undefined ? false : _context_implicitKey, _context_inFlow = context.inFlow, inFlow = _context_inFlow === undefined ? false : _context_inFlow, type = context.type;
        var indent = 'indent' in token ? token.indent : null;
        if (afterKey && typeof indent === 'number') indent += 2;
        if (!type) switch(token.type){
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar':
                {
                    var header = token.props[0];
                    if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');
                    type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                    break;
                }
            default:
                type = 'PLAIN';
        }
        var source = stringifyString.stringifyString({
            type: type,
            value: value
        }, {
            implicitKey: implicitKey || indent === null,
            indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
            inFlow: inFlow,
            options: {
                blockQuote: true,
                lineWidth: -1
            }
        });
        switch(source[0]){
            case '|':
            case '>':
                setBlockScalarValue(token, source);
                break;
            case '"':
                setFlowScalarValue(token, source, 'double-quoted-scalar');
                break;
            case "'":
                setFlowScalarValue(token, source, 'single-quoted-scalar');
                break;
            default:
                setFlowScalarValue(token, source, 'scalar');
        }
    }
    function setBlockScalarValue(token, source) {
        var he = source.indexOf('\n');
        var head = source.substring(0, he);
        var body = source.substring(he + 1) + '\n';
        if (token.type === 'block-scalar') {
            var header = token.props[0];
            if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');
            header.source = head;
            token.source = body;
        } else {
            var offset = token.offset;
            var indent = 'indent' in token ? token.indent : -1;
            var props = [
                {
                    type: 'block-scalar-header',
                    offset: offset,
                    indent: indent,
                    source: head
                }
            ];
            if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined)) props.push({
                type: 'newline',
                offset: -1,
                indent: indent,
                source: '\n'
            });
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.keys(token)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var key = _step.value;
                    if (key !== 'type' && key !== 'offset') delete token[key];
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            Object.assign(token, {
                type: 'block-scalar',
                indent: indent,
                props: props,
                source: body
            });
        }
    }
    /** @returns `true` if last token is a newline */ function addEndtoBlockProps(props, end) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        if (end) try {
            for(var _iterator = end[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var st = _step.value;
                switch(st.type){
                    case 'space':
                    case 'comment':
                        props.push(st);
                        break;
                    case 'newline':
                        props.push(st);
                        return true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return false;
    }
    function setFlowScalarValue(token, source, type) {
        switch(token.type){
            case 'scalar':
            case 'double-quoted-scalar':
            case 'single-quoted-scalar':
                token.type = type;
                token.source = source;
                break;
            case 'block-scalar':
                {
                    var end = token.props.slice(1);
                    var oa = source.length;
                    if (token.props[0].type === 'block-scalar-header') oa -= token.props[0].source.length;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = end[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var tok = _step.value;
                            tok.offset += oa;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    delete token.props;
                    Object.assign(token, {
                        type: type,
                        source: source,
                        end: end
                    });
                    break;
                }
            case 'block-map':
            case 'block-seq':
                {
                    var offset = token.offset + source.length;
                    var nl = {
                        type: 'newline',
                        offset: offset,
                        indent: token.indent,
                        source: '\n'
                    };
                    delete token.items;
                    Object.assign(token, {
                        type: type,
                        source: source,
                        end: [
                            nl
                        ]
                    });
                    break;
                }
            default:
                {
                    var indent = 'indent' in token ? token.indent : -1;
                    var end1 = 'end' in token && Array.isArray(token.end) ? token.end.filter(function(st) {
                        return st.type === 'space' || st.type === 'comment' || st.type === 'newline';
                    }) : [];
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = Object.keys(token)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var key = _step1.value;
                            if (key !== 'type' && key !== 'offset') delete token[key];
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                    Object.assign(token, {
                        type: type,
                        indent: indent,
                        source: source,
                        end: end1
                    });
                }
        }
    }
    cstScalar.createScalarToken = createScalarToken;
    cstScalar.resolveAsScalar = resolveAsScalar;
    cstScalar.setScalarValue = setScalarValue;
    return cstScalar;
}

var cstStringify = {};

var hasRequiredCstStringify;
function requireCstStringify() {
    if (hasRequiredCstStringify) return cstStringify;
    hasRequiredCstStringify = 1;
    /**
	 * Stringify a CST document, token, or collection item
	 *
	 * Fair warning: This applies no validation whatsoever, and
	 * simply concatenates the sources in their logical order.
	 */ var stringify = function(cst) {
        return 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
    };
    function stringifyToken(token) {
        switch(token.type){
            case 'block-scalar':
                {
                    var res = '';
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = token.props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var tok = _step.value;
                            res += stringifyToken(tok);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    return res + token.source;
                }
            case 'block-map':
            case 'block-seq':
                {
                    var res1 = '';
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = token.items[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var item = _step1.value;
                            res1 += stringifyItem(item);
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                    return res1;
                }
            case 'flow-collection':
                {
                    var res2 = token.start.source;
                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                    try {
                        for(var _iterator2 = token.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                            var item1 = _step2.value;
                            res2 += stringifyItem(item1);
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                _iterator2.return();
                            }
                        } finally{
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                    var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                    try {
                        for(var _iterator3 = token.end[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                            var st = _step3.value;
                            res2 += st.source;
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                _iterator3.return();
                            }
                        } finally{
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                    return res2;
                }
            case 'document':
                {
                    var res3 = stringifyItem(token);
                    var _iteratorNormalCompletion4 = true, _didIteratorError4 = false, _iteratorError4 = undefined;
                    if (token.end) try {
                        for(var _iterator4 = token.end[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){
                            var st1 = _step4.value;
                            res3 += st1.source;
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                                _iterator4.return();
                            }
                        } finally{
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                    return res3;
                }
            default:
                {
                    var res4 = token.source;
                    var _iteratorNormalCompletion5 = true, _didIteratorError5 = false, _iteratorError5 = undefined;
                    if ('end' in token && token.end) try {
                        for(var _iterator5 = token.end[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true){
                            var st2 = _step5.value;
                            res4 += st2.source;
                        }
                    } catch (err) {
                        _didIteratorError5 = true;
                        _iteratorError5 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                                _iterator5.return();
                            }
                        } finally{
                            if (_didIteratorError5) {
                                throw _iteratorError5;
                            }
                        }
                    }
                    return res4;
                }
        }
    }
    function stringifyItem(param) {
        var start = param.start, key = param.key, sep = param.sep, value = param.value;
        var res = '';
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = start[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var st = _step.value;
                res += st.source;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (key) res += stringifyToken(key);
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        if (sep) try {
            for(var _iterator1 = sep[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var st1 = _step1.value;
                res += st1.source;
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        if (value) res += stringifyToken(value);
        return res;
    }
    cstStringify.stringify = stringify;
    return cstStringify;
}

var cstVisit = {};

function _array_like_to_array$a(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$5(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$5(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$5() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$5(arr, i) {
    return _array_with_holes$5(arr) || _iterable_to_array_limit$5(arr, i) || _unsupported_iterable_to_array$a(arr, i) || _non_iterable_rest$5();
}
function _type_of$i(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$a(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$a(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$a(o, minLen);
}
var hasRequiredCstVisit;
function requireCstVisit() {
    if (hasRequiredCstVisit) return cstVisit;
    hasRequiredCstVisit = 1;
    var BREAK = Symbol('break visit');
    var SKIP = Symbol('skip children');
    var REMOVE = Symbol('remove item');
    /**
	 * Apply a visitor to a CST document or item.
	 *
	 * Walks through the tree (depth-first) starting from the root, calling a
	 * `visitor` function with two arguments when entering each item:
	 *   - `item`: The current item, which included the following members:
	 *     - `start: SourceToken[]` – Source tokens before the key or value,
	 *       possibly including its anchor or tag.
	 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
	 *       the key before the `:` separator is empty.
	 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
	 *       which should include the `:` map value indicator if `value` is set.
	 *     - `value?: Token` – The value of a sequence item, or of a map pair.
	 *   - `path`: The steps from the root to the current node, as an array of
	 *     `['key' | 'value', number]` tuples.
	 *
	 * The return value of the visitor may be used to control the traversal:
	 *   - `undefined` (default): Do nothing and continue
	 *   - `visit.SKIP`: Do not visit the children of this token, continue with
	 *      next sibling
	 *   - `visit.BREAK`: Terminate traversal completely
	 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
	 *   - `number`: Set the index of the next step. This is useful especially if
	 *     the index of the current token has changed.
	 *   - `function`: Define the next visitor for this item. After the original
	 *     visitor is called on item entry, next visitors are called after handling
	 *     a non-empty `key` and when exiting the item.
	 */ function visit(cst, visitor) {
        if ('type' in cst && cst.type === 'document') cst = {
            start: cst.start,
            value: cst.value
        };
        _visit(Object.freeze([]), cst, visitor);
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */ visit.BREAK = BREAK;
    /** Do not visit the children of the current item */ visit.SKIP = SKIP;
    /** Remove the current item */ visit.REMOVE = REMOVE;
    /** Find the item at `path` from `cst` as the root */ visit.itemAtPath = function(cst, path) {
        var item = cst;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array$5(_step.value, 2), field = _step_value[0], index = _step_value[1];
                var tok = item === null || item === void 0 ? void 0 : item[field];
                if (tok && 'items' in tok) {
                    item = tok.items[index];
                } else return undefined;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return item;
    };
    /**
	 * Get the immediate parent collection of the item at `path` from `cst` as the root.
	 *
	 * Throws an error if the collection is not found, which should never happen if the item itself exists.
	 */ visit.parentCollection = function(cst, path) {
        var parent = visit.itemAtPath(cst, path.slice(0, -1));
        var field = path[path.length - 1][0];
        var coll = parent === null || parent === undefined ? undefined : parent[field];
        if (coll && 'items' in coll) return coll;
        throw new Error('Parent collection not found');
    };
    function _visit(path, item, visitor) {
        var ctrl = visitor(item, path);
        if ((typeof ctrl === "undefined" ? "undefined" : _type_of$i(ctrl)) === 'symbol') return ctrl;
        for(var _i = 0, _iter = [
            'key',
            'value'
        ]; _i < _iter.length; _i++){
            var field = _iter[_i];
            var token = item[field];
            if (token && 'items' in token) {
                for(var i = 0; i < token.items.length; ++i){
                    var ci = _visit(Object.freeze(path.concat([
                        [
                            field,
                            i
                        ]
                    ])), token.items[i], visitor);
                    if (typeof ci === 'number') i = ci - 1;
                    else if (ci === BREAK) return BREAK;
                    else if (ci === REMOVE) {
                        token.items.splice(i, 1);
                        i -= 1;
                    }
                }
                if (typeof ctrl === 'function' && field === 'key') ctrl = ctrl(item, path);
            }
        }
        return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
    }
    cstVisit.visit = visit;
    return cstVisit;
}

var hasRequiredCst;
function requireCst() {
    if (hasRequiredCst) return cst;
    hasRequiredCst = 1;
    var cstScalar = requireCstScalar();
    var cstStringify = requireCstStringify();
    var cstVisit = requireCstVisit();
    /** The byte order mark */ var BOM = '\u{FEFF}';
    /** Start of doc-mode */ var DOCUMENT = '\x02'; // C0: Start of Text
    /** Unexpected end of flow-mode */ var FLOW_END = '\x18'; // C0: Cancel
    /** Next token is a scalar value */ var SCALAR = '\x1f'; // C0: Unit Separator
    /** @returns `true` if `token` is a flow or block collection */ var isCollection = function(token) {
        return !!token && 'items' in token;
    };
    /** @returns `true` if `token` is a flow or block scalar; not an alias */ var isScalar = function(token) {
        return !!token && (token.type === 'scalar' || token.type === 'single-quoted-scalar' || token.type === 'double-quoted-scalar' || token.type === 'block-scalar');
    };
    /* istanbul ignore next */ /** Get a printable representation of a lexer token */ function prettyToken(token) {
        switch(token){
            case BOM:
                return '<BOM>';
            case DOCUMENT:
                return '<DOC>';
            case FLOW_END:
                return '<FLOW_END>';
            case SCALAR:
                return '<SCALAR>';
            default:
                return JSON.stringify(token);
        }
    }
    /** Identify the type of a lexer token. May return `null` for unknown tokens. */ function tokenType(source) {
        switch(source){
            case BOM:
                return 'byte-order-mark';
            case DOCUMENT:
                return 'doc-mode';
            case FLOW_END:
                return 'flow-error-end';
            case SCALAR:
                return 'scalar';
            case '---':
                return 'doc-start';
            case '...':
                return 'doc-end';
            case '':
            case '\n':
            case '\r\n':
                return 'newline';
            case '-':
                return 'seq-item-ind';
            case '?':
                return 'explicit-key-ind';
            case ':':
                return 'map-value-ind';
            case '{':
                return 'flow-map-start';
            case '}':
                return 'flow-map-end';
            case '[':
                return 'flow-seq-start';
            case ']':
                return 'flow-seq-end';
            case ',':
                return 'comma';
        }
        switch(source[0]){
            case ' ':
            case '\t':
                return 'space';
            case '#':
                return 'comment';
            case '%':
                return 'directive-line';
            case '*':
                return 'alias';
            case '&':
                return 'anchor';
            case '!':
                return 'tag';
            case "'":
                return 'single-quoted-scalar';
            case '"':
                return 'double-quoted-scalar';
            case '|':
            case '>':
                return 'block-scalar-header';
        }
        return null;
    }
    cst.createScalarToken = cstScalar.createScalarToken;
    cst.resolveAsScalar = cstScalar.resolveAsScalar;
    cst.setScalarValue = cstScalar.setScalarValue;
    cst.stringify = cstStringify.stringify;
    cst.visit = cstVisit.visit;
    cst.BOM = BOM;
    cst.DOCUMENT = DOCUMENT;
    cst.FLOW_END = FLOW_END;
    cst.SCALAR = SCALAR;
    cst.isCollection = isCollection;
    cst.isScalar = isScalar;
    cst.prettyToken = prettyToken;
    cst.tokenType = tokenType;
    return cst;
}

var lexer = {};

function _array_like_to_array$9(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$4(arr) {
    if (Array.isArray(arr)) return arr;
}
function _class_call_check$k(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _iterable_to_array_limit$4(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$4() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$4(arr, i) {
    return _array_with_holes$4(arr) || _iterable_to_array_limit$4(arr, i) || _unsupported_iterable_to_array$9(arr, i) || _non_iterable_rest$4();
}
function _unsupported_iterable_to_array$9(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$9(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$9(o, minLen);
}
function _ts_generator$1(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
function _ts_values$1(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = undefined;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var hasRequiredLexer;
function requireLexer() {
    if (hasRequiredLexer) return lexer;
    hasRequiredLexer = 1;
    var cst = requireCst();
    /*
	START -> stream

	stream
	  directive -> line-end -> stream
	  indent + line-end -> stream
	  [else] -> line-start

	line-end
	  comment -> line-end
	  newline -> .
	  input-end -> END

	line-start
	  doc-start -> doc
	  doc-end -> stream
	  [else] -> indent -> block-start

	block-start
	  seq-item-start -> block-start
	  explicit-key-start -> block-start
	  map-value-start -> block-start
	  [else] -> doc

	doc
	  line-end -> line-start
	  spaces -> doc
	  anchor -> doc
	  tag -> doc
	  flow-start -> flow -> doc
	  flow-end -> error -> doc
	  seq-item-start -> error -> doc
	  explicit-key-start -> error -> doc
	  map-value-start -> doc
	  alias -> doc
	  quote-start -> quoted-scalar -> doc
	  block-scalar-header -> line-end -> block-scalar(min) -> line-start
	  [else] -> plain-scalar(false, min) -> doc

	flow
	  line-end -> flow
	  spaces -> flow
	  anchor -> flow
	  tag -> flow
	  flow-start -> flow -> flow
	  flow-end -> .
	  seq-item-start -> error -> flow
	  explicit-key-start -> flow
	  map-value-start -> flow
	  alias -> flow
	  quote-start -> quoted-scalar -> flow
	  comma -> flow
	  [else] -> plain-scalar(true, 0) -> flow

	quoted-scalar
	  quote-end -> .
	  [else] -> quoted-scalar

	block-scalar(min)
	  newline + peek(indent < min) -> .
	  [else] -> block-scalar(min)

	plain-scalar(is-flow, min)
	  scalar-end(is-flow) -> .
	  peek(newline + (indent < min)) -> .
	  [else] -> plain-scalar(min)
	*/ function isEmpty(ch) {
        switch(ch){
            case undefined:
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                return true;
            default:
                return false;
        }
    }
    var hexDigits = new Set('0123456789ABCDEFabcdef');
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(',[]{}');
    var invalidAnchorChars = new Set(' ,[]{}\n\r\t');
    var isNotAnchorChar = function(ch) {
        return !ch || invalidAnchorChars.has(ch);
    };
    /**
	 * Splits an input string into lexical tokens, i.e. smaller strings that are
	 * easily identifiable by `tokens.tokenType()`.
	 *
	 * Lexing starts always in a "stream" context. Incomplete input may be buffered
	 * until a complete token can be emitted.
	 *
	 * In addition to slices of the original input, the following control characters
	 * may also be emitted:
	 *
	 * - `\x02` (Start of Text): A document starts with the next token
	 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
	 * - `\x1f` (Unit Separator): Next token is a scalar value
	 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
	 */ var Lexer = /*#__PURE__*/ function() {
        function Lexer() {
            _class_call_check$k(this, Lexer);
            /**
	         * Flag indicating whether the end of the current buffer marks the end of
	         * all input
	         */ this.atEnd = false;
            /**
	         * Explicit indent set in block scalar header, as an offset from the current
	         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
	         * explicitly set.
	         */ this.blockScalarIndent = -1;
            /**
	         * Block scalars that include a + (keep) chomping indicator in their header
	         * include trailing empty lines, which are otherwise excluded from the
	         * scalar's contents.
	         */ this.blockScalarKeep = false;
            /** Current input */ this.buffer = '';
            /**
	         * Flag noting whether the map value indicator : can immediately follow this
	         * node within a flow context.
	         */ this.flowKey = false;
            /** Count of surrounding flow collection levels. */ this.flowLevel = 0;
            /**
	         * Minimum level of indentation required for next lines to be parsed as a
	         * part of the current scalar value.
	         */ this.indentNext = 0;
            /** Indentation level of the current line. */ this.indentValue = 0;
            /** Position of the next \n character. */ this.lineEndPos = null;
            /** Stores the state of the lexer if reaching the end of incpomplete input */ this.next = null;
            /** A pointer to `buffer`; the current position of the lexer. */ this.pos = 0;
        }
        var _proto = Lexer.prototype;
        /**
	     * Generate YAML tokens from the `source` string. If `incomplete`,
	     * a part of the last line may be left as a buffer for the next call.
	     *
	     * @returns A generator of lexical tokens
	     */ _proto.lex = function lex(source) {
            var incomplete, _this_next, next;
            var _arguments = arguments;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        incomplete = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                        if (source) {
                            if (typeof source !== 'string') throw TypeError('source is not a string');
                            this.buffer = this.buffer ? this.buffer + source : source;
                            this.lineEndPos = null;
                        }
                        this.atEnd = !incomplete;
                        next = (_this_next = this.next) !== null && _this_next !== undefined ? _this_next : 'stream';
                        _state.label = 1;
                    case 1:
                        if (!(next && (incomplete || this.hasChars(1)))) return [
                            3,
                            3
                        ];
                        return [
                            5,
                            _ts_values$1(this.parseNext(next))
                        ];
                    case 2:
                        next = _state.sent();
                        return [
                            3,
                            1
                        ];
                    case 3:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.atLineEnd = function atLineEnd() {
            var i = this.pos;
            var ch = this.buffer[i];
            while(ch === ' ' || ch === '\t')ch = this.buffer[++i];
            if (!ch || ch === '#' || ch === '\n') return true;
            if (ch === '\r') return this.buffer[i + 1] === '\n';
            return false;
        };
        _proto.charAt = function charAt(n) {
            return this.buffer[this.pos + n];
        };
        _proto.continueScalar = function continueScalar(offset) {
            var ch = this.buffer[offset];
            if (this.indentNext > 0) {
                var indent = 0;
                while(ch === ' ')ch = this.buffer[++indent + offset];
                if (ch === '\r') {
                    var next = this.buffer[indent + offset + 1];
                    if (next === '\n' || !next && !this.atEnd) return offset + indent + 1;
                }
                return ch === '\n' || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
            }
            if (ch === '-' || ch === '.') {
                var dt = this.buffer.substr(offset, 3);
                if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3])) return -1;
            }
            return offset;
        };
        _proto.getLine = function getLine() {
            var end = this.lineEndPos;
            if (typeof end !== 'number' || end !== -1 && end < this.pos) {
                end = this.buffer.indexOf('\n', this.pos);
                this.lineEndPos = end;
            }
            if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
            if (this.buffer[end - 1] === '\r') end -= 1;
            return this.buffer.substring(this.pos, end);
        };
        _proto.hasChars = function hasChars(n) {
            return this.pos + n <= this.buffer.length;
        };
        _proto.setNext = function setNext(state) {
            this.buffer = this.buffer.substring(this.pos);
            this.pos = 0;
            this.lineEndPos = null;
            this.next = state;
            return null;
        };
        _proto.peek = function peek(n) {
            return this.buffer.substr(this.pos, n);
        };
        _proto.parseNext = function parseNext(next) {
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        switch(next){
                            case 'stream':
                                return [
                                    3,
                                    1
                                ];
                            case 'line-start':
                                return [
                                    3,
                                    3
                                ];
                            case 'block-start':
                                return [
                                    3,
                                    5
                                ];
                            case 'doc':
                                return [
                                    3,
                                    7
                                ];
                            case 'flow':
                                return [
                                    3,
                                    9
                                ];
                            case 'quoted-scalar':
                                return [
                                    3,
                                    11
                                ];
                            case 'block-scalar':
                                return [
                                    3,
                                    13
                                ];
                            case 'plain-scalar':
                                return [
                                    3,
                                    15
                                ];
                        }
                        return [
                            3,
                            17
                        ];
                    case 1:
                        return [
                            5,
                            _ts_values$1(this.parseStream())
                        ];
                    case 2:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 3:
                        return [
                            5,
                            _ts_values$1(this.parseLineStart())
                        ];
                    case 4:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 5:
                        return [
                            5,
                            _ts_values$1(this.parseBlockStart())
                        ];
                    case 6:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 7:
                        return [
                            5,
                            _ts_values$1(this.parseDocument())
                        ];
                    case 8:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 9:
                        return [
                            5,
                            _ts_values$1(this.parseFlowCollection())
                        ];
                    case 10:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 11:
                        return [
                            5,
                            _ts_values$1(this.parseQuotedScalar())
                        ];
                    case 12:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 13:
                        return [
                            5,
                            _ts_values$1(this.parseBlockScalar())
                        ];
                    case 14:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 15:
                        return [
                            5,
                            _ts_values$1(this.parsePlainScalar())
                        ];
                    case 16:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 17:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.parseStream = function parseStream() {
            var line, dirEnd, cs, ch, ch1, n, _, sp;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        line = this.getLine();
                        if (line === null) return [
                            2,
                            this.setNext('stream')
                        ];
                        if (!(line[0] === cst.BOM)) return [
                            3,
                            2
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 1:
                        _state.sent();
                        line = line.substring(1);
                        _state.label = 2;
                    case 2:
                        if (!(line[0] === '%')) return [
                            3,
                            6
                        ];
                        dirEnd = line.length;
                        cs = line.indexOf('#');
                        while(cs !== -1){
                            ch = line[cs - 1];
                            if (ch === ' ' || ch === '\t') {
                                dirEnd = cs - 1;
                                break;
                            } else {
                                cs = line.indexOf('#', cs + 1);
                            }
                        }
                        while(true){
                            ch1 = line[dirEnd - 1];
                            if (ch1 === ' ' || ch1 === '\t') dirEnd -= 1;
                            else break;
                        }
                        return [
                            5,
                            _ts_values$1(this.pushCount(dirEnd))
                        ];
                    case 3:
                        _ = _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 4:
                        n = _ + _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushCount(line.length - n))
                        ];
                    case 5:
                        _state.sent(); // possible comment
                        this.pushNewline();
                        return [
                            2,
                            'stream'
                        ];
                    case 6:
                        if (!this.atLineEnd()) return [
                            3,
                            10
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 7:
                        sp = _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushCount(line.length - sp))
                        ];
                    case 8:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushNewline())
                        ];
                    case 9:
                        _state.sent();
                        return [
                            2,
                            'stream'
                        ];
                    case 10:
                        return [
                            4,
                            cst.DOCUMENT
                        ];
                    case 11:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.parseLineStart())
                        ];
                    case 12:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        };
        _proto.parseLineStart = function parseLineStart() {
            var ch, s, _;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        ch = this.charAt(0);
                        if (!ch && !this.atEnd) return [
                            2,
                            this.setNext('line-start')
                        ];
                        if (!(ch === '-' || ch === '.')) return [
                            3,
                            2
                        ];
                        if (!this.atEnd && !this.hasChars(4)) return [
                            2,
                            this.setNext('line-start')
                        ];
                        s = this.peek(3);
                        if (!((s === '---' || s === '...') && isEmpty(this.charAt(3)))) return [
                            3,
                            2
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushCount(3))
                        ];
                    case 1:
                        _state.sent();
                        this.indentValue = 0;
                        this.indentNext = 0;
                        return [
                            2,
                            s === '---' ? 'doc' : 'stream'
                        ];
                    case 2:
                        _ = this;
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(false))
                        ];
                    case 3:
                        _.indentValue = _state.sent();
                        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
                        return [
                            5,
                            _ts_values$1(this.parseBlockStart())
                        ];
                    case 4:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        };
        _proto.parseBlockStart = function parseBlockStart() {
            var _this_peek, ch0, ch1, n, _;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this_peek = _sliced_to_array$4(this.peek(2), 2), ch0 = _this_peek[0], ch1 = _this_peek[1];
                        if (!ch1 && !this.atEnd) return [
                            2,
                            this.setNext('block-start')
                        ];
                        if (!((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1))) return [
                            3,
                            4
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 1:
                        _ = _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 2:
                        n = _ + _state.sent();
                        this.indentNext = this.indentValue + 1;
                        this.indentValue += n;
                        return [
                            5,
                            _ts_values$1(this.parseBlockStart())
                        ];
                    case 3:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 4:
                        return [
                            2,
                            'doc'
                        ];
                }
            });
        };
        _proto.parseDocument = function parseDocument() {
            var line, n, _;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 1:
                        _state.sent();
                        line = this.getLine();
                        if (line === null) return [
                            2,
                            this.setNext('doc')
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushIndicators())
                        ];
                    case 2:
                        n = _state.sent();
                        _ = line[n];
                        switch(_){
                            case '#':
                                return [
                                    3,
                                    3
                                ];
                            case undefined:
                                return [
                                    3,
                                    5
                                ];
                            case '{':
                                return [
                                    3,
                                    8
                                ];
                            case '[':
                                return [
                                    3,
                                    8
                                ];
                            case '}':
                                return [
                                    3,
                                    10
                                ];
                            case ']':
                                return [
                                    3,
                                    10
                                ];
                            case '*':
                                return [
                                    3,
                                    12
                                ];
                            case '"':
                                return [
                                    3,
                                    14
                                ];
                            case "'":
                                return [
                                    3,
                                    14
                                ];
                            case '|':
                                return [
                                    3,
                                    16
                                ];
                            case '>':
                                return [
                                    3,
                                    16
                                ];
                        }
                        return [
                            3,
                            22
                        ];
                    case 3:
                        return [
                            5,
                            _ts_values$1(this.pushCount(line.length - n))
                        ];
                    case 4:
                        _state.sent();
                        _state.label = 5;
                    case 5:
                        return [
                            5,
                            _ts_values$1(this.pushNewline())
                        ];
                    case 6:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.parseLineStart())
                        ];
                    case 7:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 8:
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 9:
                        _state.sent();
                        this.flowKey = false;
                        this.flowLevel = 1;
                        return [
                            2,
                            'flow'
                        ];
                    case 10:
                        // this is an error
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 11:
                        _state.sent();
                        return [
                            2,
                            'doc'
                        ];
                    case 12:
                        return [
                            5,
                            _ts_values$1(this.pushUntil(isNotAnchorChar))
                        ];
                    case 13:
                        _state.sent();
                        return [
                            2,
                            'doc'
                        ];
                    case 14:
                        return [
                            5,
                            _ts_values$1(this.parseQuotedScalar())
                        ];
                    case 15:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 16:
                        return [
                            5,
                            _ts_values$1(this.parseBlockScalarHeader())
                        ];
                    case 17:
                        n += _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 18:
                        n += _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushCount(line.length - n))
                        ];
                    case 19:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushNewline())
                        ];
                    case 20:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.parseBlockScalar())
                        ];
                    case 21:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 22:
                        return [
                            5,
                            _ts_values$1(this.parsePlainScalar())
                        ];
                    case 23:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 24:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.parseFlowCollection = function parseFlowCollection() {
            var nl, sp, indent, line, atFlowEndMarker, n, _, next;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        indent = -1;
                        _state.label = 1;
                    case 1:
                        return [
                            5,
                            _ts_values$1(this.pushNewline())
                        ];
                    case 2:
                        nl = _state.sent();
                        if (!(nl > 0)) return [
                            3,
                            4
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(false))
                        ];
                    case 3:
                        sp = _state.sent();
                        this.indentValue = indent = sp;
                        return [
                            3,
                            5
                        ];
                    case 4:
                        sp = 0;
                        _state.label = 5;
                    case 5:
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 6:
                        sp += _state.sent();
                        _state.label = 7;
                    case 7:
                        if (nl + sp > 0) return [
                            3,
                            1
                        ];
                        _state.label = 8;
                    case 8:
                        line = this.getLine();
                        if (line === null) return [
                            2,
                            this.setNext('flow')
                        ];
                        if (!(indent !== -1 && indent < this.indentNext && line[0] !== '#' || indent === 0 && (line.startsWith('---') || line.startsWith('...')) && isEmpty(line[3]))) return [
                            3,
                            11
                        ];
                        // Allowing for the terminal ] or } at the same (rather than greater)
                        // indent level as the initial [ or { is technically invalid, but
                        // failing here would be surprising to users.
                        atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === ']' || line[0] === '}');
                        if (!!atFlowEndMarker) return [
                            3,
                            11
                        ];
                        // this is an error
                        this.flowLevel = 0;
                        return [
                            4,
                            cst.FLOW_END
                        ];
                    case 9:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.parseLineStart())
                        ];
                    case 10:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 11:
                        n = 0;
                        _state.label = 12;
                    case 12:
                        if (!(line[n] === ',')) return [
                            3,
                            15
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 13:
                        n += _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 14:
                        n += _state.sent();
                        this.flowKey = false;
                        return [
                            3,
                            12
                        ];
                    case 15:
                        return [
                            5,
                            _ts_values$1(this.pushIndicators())
                        ];
                    case 16:
                        n += _state.sent();
                        _ = line[n];
                        switch(_){
                            case undefined:
                                return [
                                    3,
                                    17
                                ];
                            case '#':
                                return [
                                    3,
                                    18
                                ];
                            case '{':
                                return [
                                    3,
                                    20
                                ];
                            case '[':
                                return [
                                    3,
                                    20
                                ];
                            case '}':
                                return [
                                    3,
                                    22
                                ];
                            case ']':
                                return [
                                    3,
                                    22
                                ];
                            case '*':
                                return [
                                    3,
                                    24
                                ];
                            case '"':
                                return [
                                    3,
                                    26
                                ];
                            case "'":
                                return [
                                    3,
                                    26
                                ];
                            case ':':
                                return [
                                    3,
                                    28
                                ];
                        }
                        return [
                            3,
                            31
                        ];
                    case 17:
                        return [
                            2,
                            'flow'
                        ];
                    case 18:
                        return [
                            5,
                            _ts_values$1(this.pushCount(line.length - n))
                        ];
                    case 19:
                        _state.sent();
                        return [
                            2,
                            'flow'
                        ];
                    case 20:
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 21:
                        _state.sent();
                        this.flowKey = false;
                        this.flowLevel += 1;
                        return [
                            2,
                            'flow'
                        ];
                    case 22:
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 23:
                        _state.sent();
                        this.flowKey = true;
                        this.flowLevel -= 1;
                        return [
                            2,
                            this.flowLevel ? 'flow' : 'doc'
                        ];
                    case 24:
                        return [
                            5,
                            _ts_values$1(this.pushUntil(isNotAnchorChar))
                        ];
                    case 25:
                        _state.sent();
                        return [
                            2,
                            'flow'
                        ];
                    case 26:
                        this.flowKey = true;
                        return [
                            5,
                            _ts_values$1(this.parseQuotedScalar())
                        ];
                    case 27:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 28:
                        next = this.charAt(1);
                        if (!(this.flowKey || isEmpty(next) || next === ',')) return [
                            3,
                            31
                        ];
                        this.flowKey = false;
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 29:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 30:
                        _state.sent();
                        return [
                            2,
                            'flow'
                        ];
                    case 31:
                        this.flowKey = false;
                        return [
                            5,
                            _ts_values$1(this.parsePlainScalar())
                        ];
                    case 32:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 33:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.parseQuotedScalar = function parseQuotedScalar() {
            var quote, end, n, qb, nl, cs;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        quote = this.charAt(0);
                        end = this.buffer.indexOf(quote, this.pos + 1);
                        if (quote === "'") {
                            while(end !== -1 && this.buffer[end + 1] === "'")end = this.buffer.indexOf("'", end + 2);
                        } else {
                            // double-quote
                            while(end !== -1){
                                n = 0;
                                while(this.buffer[end - 1 - n] === '\\')n += 1;
                                if (n % 2 === 0) break;
                                end = this.buffer.indexOf('"', end + 1);
                            }
                        }
                        // Only looking for newlines within the quotes
                        qb = this.buffer.substring(0, end);
                        nl = qb.indexOf('\n', this.pos);
                        if (nl !== -1) {
                            while(nl !== -1){
                                cs = this.continueScalar(nl + 1);
                                if (cs === -1) break;
                                nl = qb.indexOf('\n', cs);
                            }
                            if (nl !== -1) {
                                // this is an error caused by an unexpected unindent
                                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
                            }
                        }
                        if (end === -1) {
                            if (!this.atEnd) return [
                                2,
                                this.setNext('quoted-scalar')
                            ];
                            end = this.buffer.length;
                        }
                        return [
                            5,
                            _ts_values$1(this.pushToIndex(end + 1, false))
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2,
                            this.flowLevel ? 'flow' : 'doc'
                        ];
                }
            });
        };
        _proto.parseBlockScalarHeader = function parseBlockScalarHeader() {
            var i, ch;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        this.blockScalarIndent = -1;
                        this.blockScalarKeep = false;
                        i = this.pos;
                        while(true){
                            ch = this.buffer[++i];
                            if (ch === '+') this.blockScalarKeep = true;
                            else if (ch > '0' && ch <= '9') this.blockScalarIndent = Number(ch) - 1;
                            else if (ch !== '-') break;
                        }
                        return [
                            5,
                            _ts_values$1(this.pushUntil(function(ch) {
                                return isEmpty(ch) || ch === '#';
                            }))
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        };
        _proto.parseBlockScalar = function parseBlockScalar() {
            var nl, indent, ch, i, next, cs, i1, i2, ch1, lastChar;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        nl = this.pos - 1; // may be -1 if this.pos === 0
                        indent = 0;
                        loop: for(i = this.pos; ch = this.buffer[i]; ++i){
                            switch(ch){
                                case ' ':
                                    indent += 1;
                                    break;
                                case '\n':
                                    nl = i;
                                    indent = 0;
                                    break;
                                case '\r':
                                    {
                                        next = this.buffer[i + 1];
                                        if (!next && !this.atEnd) return [
                                            2,
                                            this.setNext('block-scalar')
                                        ];
                                        if (next === '\n') break;
                                    }
                                default:
                                    break loop;
                            }
                        }
                        if (!ch && !this.atEnd) return [
                            2,
                            this.setNext('block-scalar')
                        ];
                        if (indent >= this.indentNext) {
                            if (this.blockScalarIndent === -1) this.indentNext = indent;
                            else {
                                this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
                            }
                            do {
                                cs = this.continueScalar(nl + 1);
                                if (cs === -1) break;
                                nl = this.buffer.indexOf('\n', cs);
                            }while (nl !== -1);
                            if (nl === -1) {
                                if (!this.atEnd) return [
                                    2,
                                    this.setNext('block-scalar')
                                ];
                                nl = this.buffer.length;
                            }
                        }
                        // Trailing insufficiently indented tabs are invalid.
                        // To catch that during parsing, we include them in the block scalar value.
                        i1 = nl + 1;
                        ch = this.buffer[i1];
                        while(ch === ' ')ch = this.buffer[++i1];
                        if (ch === '\t') {
                            while(ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')ch = this.buffer[++i1];
                            nl = i1 - 1;
                        } else if (!this.blockScalarKeep) {
                            do {
                                i2 = nl - 1;
                                ch1 = this.buffer[i2];
                                if (ch1 === '\r') ch1 = this.buffer[--i2];
                                lastChar = i2; // Drop the line if last char not more indented
                                while(ch1 === ' ')ch1 = this.buffer[--i2];
                                if (ch1 === '\n' && i2 >= this.pos && i2 + 1 + indent > lastChar) nl = i2;
                                else break;
                            }while (true);
                        }
                        return [
                            4,
                            cst.SCALAR
                        ];
                    case 1:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushToIndex(nl + 1, true))
                        ];
                    case 2:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.parseLineStart())
                        ];
                    case 3:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        };
        _proto.parsePlainScalar = function parsePlainScalar() {
            var inFlow, end, i, ch, next, next1, cs;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        inFlow = this.flowLevel > 0;
                        end = this.pos - 1;
                        i = this.pos - 1;
                        while(ch = this.buffer[++i]){
                            if (ch === ':') {
                                next = this.buffer[i + 1];
                                if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
                                end = i;
                            } else if (isEmpty(ch)) {
                                next1 = this.buffer[i + 1];
                                if (ch === '\r') {
                                    if (next1 === '\n') {
                                        i += 1;
                                        ch = '\n';
                                        next1 = this.buffer[i + 1];
                                    } else end = i;
                                }
                                if (next1 === '#' || inFlow && flowIndicatorChars.has(next1)) break;
                                if (ch === '\n') {
                                    cs = this.continueScalar(i + 1);
                                    if (cs === -1) break;
                                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                                }
                            } else {
                                if (inFlow && flowIndicatorChars.has(ch)) break;
                                end = i;
                            }
                        }
                        if (!ch && !this.atEnd) return [
                            2,
                            this.setNext('plain-scalar')
                        ];
                        return [
                            4,
                            cst.SCALAR
                        ];
                    case 1:
                        _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushToIndex(end + 1, true))
                        ];
                    case 2:
                        _state.sent();
                        return [
                            2,
                            inFlow ? 'flow' : 'doc'
                        ];
                }
            });
        };
        _proto.pushCount = function pushCount(n) {
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!(n > 0)) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            this.buffer.substr(this.pos, n)
                        ];
                    case 1:
                        _state.sent();
                        this.pos += n;
                        return [
                            2,
                            n
                        ];
                    case 2:
                        return [
                            2,
                            0
                        ];
                }
            });
        };
        _proto.pushToIndex = function pushToIndex(i, allowEmpty) {
            var s;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        s = this.buffer.slice(this.pos, i);
                        if (!s) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            s
                        ];
                    case 1:
                        _state.sent();
                        this.pos += s.length;
                        return [
                            2,
                            s.length
                        ];
                    case 2:
                        if (!allowEmpty) return [
                            3,
                            4
                        ];
                        return [
                            4,
                            ''
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        return [
                            2,
                            0
                        ];
                }
            });
        };
        _proto.pushIndicators = function pushIndicators() {
            var _, _1, _2, _3, _4, inFlow, ch1, _5, _6;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _ = this.charAt(0);
                        switch(_){
                            case '!':
                                return [
                                    3,
                                    1
                                ];
                            case '&':
                                return [
                                    3,
                                    5
                                ];
                            case '-':
                                return [
                                    3,
                                    9
                                ];
                            case '?':
                                return [
                                    3,
                                    9
                                ];
                            case ':':
                                return [
                                    3,
                                    9
                                ];
                        }
                        return [
                            3,
                            13
                        ];
                    case 1:
                        return [
                            5,
                            _ts_values$1(this.pushTag())
                        ];
                    case 2:
                        _1 = _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 3:
                        _2 = _1 + _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushIndicators())
                        ];
                    case 4:
                        return [
                            2,
                            _2 + _state.sent()
                        ];
                    case 5:
                        return [
                            5,
                            _ts_values$1(this.pushUntil(isNotAnchorChar))
                        ];
                    case 6:
                        _3 = _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 7:
                        _4 = _3 + _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushIndicators())
                        ];
                    case 8:
                        return [
                            2,
                            _4 + _state.sent()
                        ];
                    case 9:
                        inFlow = this.flowLevel > 0;
                        ch1 = this.charAt(1);
                        if (!(isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1))) return [
                            3,
                            13
                        ];
                        if (!inFlow) this.indentNext = this.indentValue + 1;
                        else if (this.flowKey) this.flowKey = false;
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 10:
                        _5 = _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushSpaces(true))
                        ];
                    case 11:
                        _6 = _5 + _state.sent();
                        return [
                            5,
                            _ts_values$1(this.pushIndicators())
                        ];
                    case 12:
                        return [
                            2,
                            _6 + _state.sent()
                        ];
                    case 13:
                        return [
                            2,
                            0
                        ];
                }
            });
        };
        _proto.pushTag = function pushTag() {
            var i, ch, i1, ch1;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!(this.charAt(1) === '<')) return [
                            3,
                            2
                        ];
                        i = this.pos + 2;
                        ch = this.buffer[i];
                        while(!isEmpty(ch) && ch !== '>')ch = this.buffer[++i];
                        return [
                            5,
                            _ts_values$1(this.pushToIndex(ch === '>' ? i + 1 : i, false))
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 2:
                        i1 = this.pos + 1;
                        ch1 = this.buffer[i1];
                        while(ch1){
                            if (tagChars.has(ch1)) ch1 = this.buffer[++i1];
                            else if (ch1 === '%' && hexDigits.has(this.buffer[i1 + 1]) && hexDigits.has(this.buffer[i1 + 2])) {
                                ch1 = this.buffer[i1 += 3];
                            } else break;
                        }
                        return [
                            5,
                            _ts_values$1(this.pushToIndex(i1, false))
                        ];
                    case 3:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.pushNewline = function pushNewline() {
            var ch;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        ch = this.buffer[this.pos];
                        if (!(ch === '\n')) return [
                            3,
                            2
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushCount(1))
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 2:
                        if (!(ch === '\r' && this.charAt(1) === '\n')) return [
                            3,
                            4
                        ];
                        return [
                            5,
                            _ts_values$1(this.pushCount(2))
                        ];
                    case 3:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 4:
                        return [
                            2,
                            0
                        ];
                    case 5:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.pushSpaces = function pushSpaces(allowTabs) {
            var i, ch, n;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        i = this.pos - 1;
                        do {
                            ch = this.buffer[++i];
                        }while (ch === ' ' || allowTabs && ch === '\t');
                        n = i - this.pos;
                        if (!(n > 0)) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            this.buffer.substr(this.pos, n)
                        ];
                    case 1:
                        _state.sent();
                        this.pos = i;
                        _state.label = 2;
                    case 2:
                        return [
                            2,
                            n
                        ];
                }
            });
        };
        _proto.pushUntil = function pushUntil(test) {
            var i, ch;
            return _ts_generator$1(this, function(_state) {
                switch(_state.label){
                    case 0:
                        i = this.pos;
                        ch = this.buffer[i];
                        while(!test(ch))ch = this.buffer[++i];
                        return [
                            5,
                            _ts_values$1(this.pushToIndex(i, false))
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        };
        return Lexer;
    }();
    lexer.Lexer = Lexer;
    return lexer;
}

var lineCounter = {};

function _class_call_check$j(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var hasRequiredLineCounter;
function requireLineCounter() {
    if (hasRequiredLineCounter) return lineCounter;
    hasRequiredLineCounter = 1;
    /**
	 * Tracks newlines during parsing in order to provide an efficient API for
	 * determining the one-indexed `{ line, col }` position for any offset
	 * within the input.
	 */ var LineCounter = function LineCounter() {
        var _this = this;
        _class_call_check$j(this, LineCounter);
        this.lineStarts = [];
        /**
	         * Should be called in ascending order. Otherwise, call
	         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
	         */ this.addNewLine = function(offset) {
            return _this.lineStarts.push(offset);
        };
        /**
	         * Performs a binary search and returns the 1-indexed { line, col }
	         * position of `offset`. If `line === 0`, `addNewLine` has never been
	         * called or `offset` is before the first known newline.
	         */ this.linePos = function(offset) {
            var low = 0;
            var high = _this.lineStarts.length;
            while(low < high){
                var mid = low + high >> 1; // Math.floor((low + high) / 2)
                if (_this.lineStarts[mid] < offset) low = mid + 1;
                else high = mid;
            }
            if (_this.lineStarts[low] === offset) return {
                line: low + 1,
                col: 1
            };
            if (low === 0) return {
                line: 0,
                col: offset
            };
            var start = _this.lineStarts[low - 1];
            return {
                line: low,
                col: offset - start + 1
            };
        };
    };
    lineCounter.LineCounter = LineCounter;
    return lineCounter;
}

var parser = {};

function _class_call_check$i(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$6(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$6(Constructor, protoProps, staticProps) {
    _defineProperties$6(Constructor.prototype, protoProps);
    return Constructor;
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : undefined,
            done: true
        };
    }
}
function _ts_values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = undefined;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var hasRequiredParser;
function requireParser() {
    if (hasRequiredParser) return parser;
    hasRequiredParser = 1;
    var node_process = require$$0$4;
    var cst = requireCst();
    var lexer = requireLexer();
    function includesToken(list, type) {
        for(var i = 0; i < list.length; ++i)if (list[i].type === type) return true;
        return false;
    }
    function findNonEmptyIndex(list) {
        for(var i = 0; i < list.length; ++i){
            switch(list[i].type){
                case 'space':
                case 'comment':
                case 'newline':
                    break;
                default:
                    return i;
            }
        }
        return -1;
    }
    function isFlowToken(token) {
        switch(token === null || token === undefined ? undefined : token.type){
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
            case 'flow-collection':
                return true;
            default:
                return false;
        }
    }
    function getPrevProps(parent) {
        switch(parent.type){
            case 'document':
                return parent.start;
            case 'block-map':
                {
                    var it = parent.items[parent.items.length - 1];
                    var _it_sep;
                    return (_it_sep = it.sep) !== null && _it_sep !== undefined ? _it_sep : it.start;
                }
            case 'block-seq':
                return parent.items[parent.items.length - 1].start;
            /* istanbul ignore next should not happen */ default:
                return [];
        }
    }
    /** Note: May modify input array */ function getFirstKeyStartProps(prev) {
        var _prev_;
        if (prev.length === 0) return [];
        var i = prev.length;
        loop: while(--i >= 0){
            switch(prev[i].type){
                case 'doc-start':
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                case 'newline':
                    break loop;
            }
        }
        while(((_prev_ = prev[++i]) === null || _prev_ === undefined ? undefined : _prev_.type) === 'space'){
        /* loop */ }
        return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
        if (fc.start.type === 'flow-seq-start') {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = fc.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var it = _step.value;
                    if (it.sep && !it.value && !includesToken(it.start, 'explicit-key-ind') && !includesToken(it.sep, 'map-value-ind')) {
                        if (it.key) it.value = it.key;
                        delete it.key;
                        if (isFlowToken(it.value)) {
                            if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
                            else it.value.end = it.sep;
                        } else Array.prototype.push.apply(it.start, it.sep);
                        delete it.sep;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    /**
	 * A YAML concrete syntax tree (CST) parser
	 *
	 * ```ts
	 * const src: string = ...
	 * for (const token of new Parser().parse(src)) {
	 *   // token: Token
	 * }
	 * ```
	 *
	 * To use the parser with a user-provided lexer:
	 *
	 * ```ts
	 * function* parse(source: string, lexer: Lexer) {
	 *   const parser = new Parser()
	 *   for (const lexeme of lexer.lex(source))
	 *     yield* parser.next(lexeme)
	 *   yield* parser.end()
	 * }
	 *
	 * const src: string = ...
	 * const lexer = new Lexer()
	 * for (const token of parse(src, lexer)) {
	 *   // token: Token
	 * }
	 * ```
	 */ var Parser = /*#__PURE__*/ function() {
        function Parser(onNewLine) {
            _class_call_check$i(this, Parser);
            /** If true, space and sequence indicators count as indentation */ this.atNewLine = true;
            /** If true, next token is a scalar value */ this.atScalar = false;
            /** Current indentation level */ this.indent = 0;
            /** Current offset since the start of parsing */ this.offset = 0;
            /** On the same line with a block map key */ this.onKeyLine = false;
            /** Top indicates the node that's currently being built */ this.stack = [];
            /** The source of the current token, set in parse() */ this.source = '';
            /** The type of the current token, set in parse() */ this.type = '';
            // Must be defined after `next()`
            this.lexer = new lexer.Lexer();
            this.onNewLine = onNewLine;
        }
        var _proto = Parser.prototype;
        /**
	     * Parse `source` as a YAML stream.
	     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
	     *
	     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
	     *
	     * @returns A generator of tokens representing each directive, document, and other structure.
	     */ _proto.parse = function parse(source) {
            var incomplete, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, lexeme, err;
            var _arguments = arguments;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        incomplete = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                        if (this.onNewLine && this.offset === 0) this.onNewLine(0);
                        _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        _state.label = 1;
                    case 1:
                        _state.trys.push([
                            1,
                            6,
                            7,
                            8
                        ]);
                        _iterator = this.lexer.lex(source, incomplete)[Symbol.iterator]();
                        _state.label = 2;
                    case 2:
                        if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                            3,
                            5
                        ];
                        lexeme = _step.value;
                        return [
                            5,
                            _ts_values(this.next(lexeme))
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        _iteratorNormalCompletion = true;
                        return [
                            3,
                            2
                        ];
                    case 5:
                        return [
                            3,
                            8
                        ];
                    case 6:
                        err = _state.sent();
                        _didIteratorError = true;
                        _iteratorError = err;
                        return [
                            3,
                            8
                        ];
                    case 7:
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                        return [
                            7
                        ];
                    case 8:
                        if (!!incomplete) return [
                            3,
                            10
                        ];
                        return [
                            5,
                            _ts_values(this.end())
                        ];
                    case 9:
                        _state.sent();
                        _state.label = 10;
                    case 10:
                        return [
                            2
                        ];
                }
            });
        };
        /**
	     * Advance the parser by the `source` of one lexical token.
	     */ _proto.next = function next(source) {
            var type, message;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        this.source = source;
                        if (node_process.env.LOG_TOKENS) console.log('|', cst.prettyToken(source));
                        if (!this.atScalar) return [
                            3,
                            2
                        ];
                        this.atScalar = false;
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 1:
                        _state.sent();
                        this.offset += source.length;
                        return [
                            2
                        ];
                    case 2:
                        type = cst.tokenType(source);
                        if (!!type) return [
                            3,
                            4
                        ];
                        message = "Not a YAML token: ".concat(source);
                        return [
                            5,
                            _ts_values(this.pop({
                                type: 'error',
                                offset: this.offset,
                                message: message,
                                source: source
                            }))
                        ];
                    case 3:
                        _state.sent();
                        this.offset += source.length;
                        return [
                            3,
                            7
                        ];
                    case 4:
                        if (!(type === 'scalar')) return [
                            3,
                            5
                        ];
                        this.atNewLine = false;
                        this.atScalar = true;
                        this.type = 'scalar';
                        return [
                            3,
                            7
                        ];
                    case 5:
                        this.type = type;
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 6:
                        _state.sent();
                        switch(type){
                            case 'newline':
                                this.atNewLine = true;
                                this.indent = 0;
                                if (this.onNewLine) this.onNewLine(this.offset + source.length);
                                break;
                            case 'space':
                                if (this.atNewLine && source[0] === ' ') this.indent += source.length;
                                break;
                            case 'explicit-key-ind':
                            case 'map-value-ind':
                            case 'seq-item-ind':
                                if (this.atNewLine) this.indent += source.length;
                                break;
                            case 'doc-mode':
                            case 'flow-error-end':
                                return [
                                    2
                                ];
                            default:
                                this.atNewLine = false;
                        }
                        this.offset += source.length;
                        _state.label = 7;
                    case 7:
                        return [
                            2
                        ];
                }
            });
        };
        /** Call at end of input to push out any remaining constructions */ _proto.end = function end() {
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!(this.stack.length > 0)) return [
                            3,
                            2
                        ];
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 1:
                        _state.sent();
                        return [
                            3,
                            0
                        ];
                    case 2:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.step = function step() {
            var top, _;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        top = this.peek(1);
                        if (!(this.type === 'doc-end' && (!top || top.type !== 'doc-end'))) return [
                            3,
                            4
                        ];
                        _state.label = 1;
                    case 1:
                        if (!(this.stack.length > 0)) return [
                            3,
                            3
                        ];
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 2:
                        _state.sent();
                        return [
                            3,
                            1
                        ];
                    case 3:
                        this.stack.push({
                            type: 'doc-end',
                            offset: this.offset,
                            source: this.source
                        });
                        return [
                            2
                        ];
                    case 4:
                        if (!!top) return [
                            3,
                            6
                        ];
                        return [
                            5,
                            _ts_values(this.stream())
                        ];
                    case 5:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 6:
                        _ = top.type;
                        switch(_){
                            case 'document':
                                return [
                                    3,
                                    7
                                ];
                            case 'alias':
                                return [
                                    3,
                                    9
                                ];
                            case 'scalar':
                                return [
                                    3,
                                    9
                                ];
                            case 'single-quoted-scalar':
                                return [
                                    3,
                                    9
                                ];
                            case 'double-quoted-scalar':
                                return [
                                    3,
                                    9
                                ];
                            case 'block-scalar':
                                return [
                                    3,
                                    11
                                ];
                            case 'block-map':
                                return [
                                    3,
                                    13
                                ];
                            case 'block-seq':
                                return [
                                    3,
                                    15
                                ];
                            case 'flow-collection':
                                return [
                                    3,
                                    17
                                ];
                            case 'doc-end':
                                return [
                                    3,
                                    19
                                ];
                        }
                        return [
                            3,
                            21
                        ];
                    case 7:
                        return [
                            5,
                            _ts_values(this.document(top))
                        ];
                    case 8:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 9:
                        return [
                            5,
                            _ts_values(this.scalar(top))
                        ];
                    case 10:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 11:
                        return [
                            5,
                            _ts_values(this.blockScalar(top))
                        ];
                    case 12:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 13:
                        return [
                            5,
                            _ts_values(this.blockMap(top))
                        ];
                    case 14:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 15:
                        return [
                            5,
                            _ts_values(this.blockSequence(top))
                        ];
                    case 16:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 17:
                        return [
                            5,
                            _ts_values(this.flowCollection(top))
                        ];
                    case 18:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 19:
                        return [
                            5,
                            _ts_values(this.documentEnd(top))
                        ];
                    case 20:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 21:
                        /* istanbul ignore next should not happen */ return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 22:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        };
        _proto.peek = function peek(n) {
            return this.stack[this.stack.length - n];
        };
        _proto.pop = function pop(error) {
            var token, message, top, _, it, it1, it2, last;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        token = error !== null && error !== undefined ? error : this.stack.pop();
                        if (!!token) return [
                            3,
                            2
                        ];
                        message = 'Tried to pop an empty stack';
                        return [
                            4,
                            {
                                type: 'error',
                                offset: this.offset,
                                source: '',
                                message: message
                            }
                        ];
                    case 1:
                        _state.sent();
                        return [
                            3,
                            14
                        ];
                    case 2:
                        if (!(this.stack.length === 0)) return [
                            3,
                            4
                        ];
                        return [
                            4,
                            token
                        ];
                    case 3:
                        _state.sent();
                        return [
                            3,
                            14
                        ];
                    case 4:
                        top = this.peek(1);
                        if (token.type === 'block-scalar') {
                            // Block scalars use their parent rather than header indent
                            token.indent = 'indent' in top ? top.indent : 0;
                        } else if (token.type === 'flow-collection' && top.type === 'document') {
                            // Ignore all indent for top-level flow collections
                            token.indent = 0;
                        }
                        if (token.type === 'flow-collection') fixFlowSeqItems(token);
                        _ = top.type;
                        switch(_){
                            case 'document':
                                return [
                                    3,
                                    5
                                ];
                            case 'block-scalar':
                                return [
                                    3,
                                    6
                                ];
                            case 'block-map':
                                return [
                                    3,
                                    7
                                ];
                            case 'block-seq':
                                return [
                                    3,
                                    8
                                ];
                            case 'flow-collection':
                                return [
                                    3,
                                    9
                                ];
                        }
                        return [
                            3,
                            10
                        ];
                    case 5:
                        top.value = token;
                        return [
                            3,
                            13
                        ];
                    case 6:
                        top.props.push(token); // error
                        return [
                            3,
                            13
                        ];
                    case 7:
                        {
                            it = top.items[top.items.length - 1];
                            if (it.value) {
                                top.items.push({
                                    start: [],
                                    key: token,
                                    sep: []
                                });
                                this.onKeyLine = true;
                                return [
                                    2
                                ];
                            } else if (it.sep) {
                                it.value = token;
                            } else {
                                Object.assign(it, {
                                    key: token,
                                    sep: []
                                });
                                this.onKeyLine = !it.explicitKey;
                                return [
                                    2
                                ];
                            }
                            return [
                                3,
                                13
                            ];
                        }
                    case 8:
                        {
                            it1 = top.items[top.items.length - 1];
                            if (it1.value) top.items.push({
                                start: [],
                                value: token
                            });
                            else it1.value = token;
                            return [
                                3,
                                13
                            ];
                        }
                    case 9:
                        {
                            it2 = top.items[top.items.length - 1];
                            if (!it2 || it2.value) top.items.push({
                                start: [],
                                key: token,
                                sep: []
                            });
                            else if (it2.sep) it2.value = token;
                            else Object.assign(it2, {
                                key: token,
                                sep: []
                            });
                            return [
                                2
                            ];
                        }
                    case 10:
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 11:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.pop(token))
                        ];
                    case 12:
                        _state.sent();
                        _state.label = 13;
                    case 13:
                        if ((top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') && (token.type === 'block-map' || token.type === 'block-seq')) {
                            last = token.items[token.items.length - 1];
                            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(function(st) {
                                return st.type !== 'comment' || st.indent < token.indent;
                            }))) {
                                if (top.type === 'document') top.end = last.start;
                                else top.items.push({
                                    start: last.start
                                });
                                token.items.splice(-1, 1);
                            }
                        }
                        _state.label = 14;
                    case 14:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.stream = function stream() {
            var _, doc;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _ = this.type;
                        switch(_){
                            case 'directive-line':
                                return [
                                    3,
                                    1
                                ];
                            case 'byte-order-mark':
                                return [
                                    3,
                                    3
                                ];
                            case 'space':
                                return [
                                    3,
                                    3
                                ];
                            case 'comment':
                                return [
                                    3,
                                    3
                                ];
                            case 'newline':
                                return [
                                    3,
                                    3
                                ];
                            case 'doc-mode':
                                return [
                                    3,
                                    5
                                ];
                            case 'doc-start':
                                return [
                                    3,
                                    5
                                ];
                        }
                        return [
                            3,
                            6
                        ];
                    case 1:
                        return [
                            4,
                            {
                                type: 'directive',
                                offset: this.offset,
                                source: this.source
                            }
                        ];
                    case 2:
                        _state.sent();
                        return [
                            2
                        ];
                    case 3:
                        return [
                            4,
                            this.sourceToken
                        ];
                    case 4:
                        _state.sent();
                        return [
                            2
                        ];
                    case 5:
                        {
                            doc = {
                                type: 'document',
                                offset: this.offset,
                                start: []
                            };
                            if (this.type === 'doc-start') doc.start.push(this.sourceToken);
                            this.stack.push(doc);
                            return [
                                2
                            ];
                        }
                    case 6:
                        return [
                            4,
                            {
                                type: 'error',
                                offset: this.offset,
                                message: "Unexpected ".concat(this.type, " token in YAML stream"),
                                source: this.source
                            }
                        ];
                    case 7:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        };
        _proto.document = function document(doc) {
            var _, bv;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!doc.value) return [
                            3,
                            2
                        ];
                        return [
                            5,
                            _ts_values(this.lineEnd(doc))
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                    case 2:
                        _ = this.type;
                        switch(_){
                            case 'doc-start':
                                return [
                                    3,
                                    3
                                ];
                            case 'anchor':
                                return [
                                    3,
                                    8
                                ];
                            case 'tag':
                                return [
                                    3,
                                    8
                                ];
                            case 'space':
                                return [
                                    3,
                                    8
                                ];
                            case 'comment':
                                return [
                                    3,
                                    8
                                ];
                            case 'newline':
                                return [
                                    3,
                                    8
                                ];
                        }
                        return [
                            3,
                            9
                        ];
                    case 3:
                        if (!(findNonEmptyIndex(doc.start) !== -1)) return [
                            3,
                            6
                        ];
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 4:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 5:
                        _state.sent();
                        return [
                            3,
                            7
                        ];
                    case 6:
                        doc.start.push(this.sourceToken);
                        _state.label = 7;
                    case 7:
                        return [
                            2
                        ];
                    case 8:
                        doc.start.push(this.sourceToken);
                        return [
                            2
                        ];
                    case 9:
                        bv = this.startBlockValue(doc);
                        if (!bv) return [
                            3,
                            10
                        ];
                        this.stack.push(bv);
                        return [
                            3,
                            12
                        ];
                    case 10:
                        return [
                            4,
                            {
                                type: 'error',
                                offset: this.offset,
                                message: "Unexpected ".concat(this.type, " token in YAML document"),
                                source: this.source
                            }
                        ];
                    case 11:
                        _state.sent();
                        _state.label = 12;
                    case 12:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.scalar = function scalar(scalar) {
            var prev, start, sep, map;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!(this.type === 'map-value-ind')) return [
                            3,
                            1
                        ];
                        prev = getPrevProps(this.peek(2));
                        start = getFirstKeyStartProps(prev);
                        if (scalar.end) {
                            sep = scalar.end;
                            sep.push(this.sourceToken);
                            delete scalar.end;
                        } else sep = [
                            this.sourceToken
                        ];
                        map = {
                            type: 'block-map',
                            offset: scalar.offset,
                            indent: scalar.indent,
                            items: [
                                {
                                    start: start,
                                    key: scalar,
                                    sep: sep
                                }
                            ]
                        };
                        this.onKeyLine = true;
                        this.stack[this.stack.length - 1] = map;
                        return [
                            3,
                            3
                        ];
                    case 1:
                        return [
                            5,
                            _ts_values(this.lineEnd(scalar))
                        ];
                    case 2:
                        _state.sent();
                        _state.label = 3;
                    case 3:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.blockScalar = function blockScalar(scalar) {
            var _, nl;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _ = this.type;
                        switch(_){
                            case 'space':
                                return [
                                    3,
                                    1
                                ];
                            case 'comment':
                                return [
                                    3,
                                    1
                                ];
                            case 'newline':
                                return [
                                    3,
                                    1
                                ];
                            case 'scalar':
                                return [
                                    3,
                                    2
                                ];
                        }
                        return [
                            3,
                            4
                        ];
                    case 1:
                        scalar.props.push(this.sourceToken);
                        return [
                            2
                        ];
                    case 2:
                        scalar.source = this.source;
                        // block-scalar source includes trailing newline
                        this.atNewLine = true;
                        this.indent = 0;
                        if (this.onNewLine) {
                            nl = this.source.indexOf('\n') + 1;
                            while(nl !== 0){
                                this.onNewLine(this.offset + nl);
                                nl = this.source.indexOf('\n', nl) + 1;
                            }
                        }
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 3:
                        _state.sent();
                        return [
                            3,
                            7
                        ];
                    case 4:
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 5:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 6:
                        _state.sent();
                        _state.label = 7;
                    case 7:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.blockMap = function blockMap(map) {
            var it, end, last, _prev_value, prev, end1, atMapIndent, atNextItem, start, nl, i, st, start1, start2, key, sep, fs, bv;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        it = map.items[map.items.length - 1];
                        // it.sep is true-ish if pair already has key or : separator
                        switch(this.type){
                            case 'newline':
                                this.onKeyLine = false;
                                if (it.value) {
                                    end = 'end' in it.value ? it.value.end : undefined;
                                    last = Array.isArray(end) ? end[end.length - 1] : undefined;
                                    if ((last === null || last === undefined ? undefined : last.type) === 'comment') end === null || end === undefined ? undefined : end.push(this.sourceToken);
                                    else map.items.push({
                                        start: [
                                            this.sourceToken
                                        ]
                                    });
                                } else if (it.sep) {
                                    it.sep.push(this.sourceToken);
                                } else {
                                    it.start.push(this.sourceToken);
                                }
                                return [
                                    2
                                ];
                            case 'space':
                            case 'comment':
                                if (it.value) {
                                    map.items.push({
                                        start: [
                                            this.sourceToken
                                        ]
                                    });
                                } else if (it.sep) {
                                    it.sep.push(this.sourceToken);
                                } else {
                                    if (this.atIndentedComment(it.start, map.indent)) {
                                        prev = map.items[map.items.length - 2];
                                        end1 = prev === null || prev === undefined ? undefined : (_prev_value = prev.value) === null || _prev_value === undefined ? undefined : _prev_value.end;
                                        if (Array.isArray(end1)) {
                                            Array.prototype.push.apply(end1, it.start);
                                            end1.push(this.sourceToken);
                                            map.items.pop();
                                            return [
                                                2
                                            ];
                                        }
                                    }
                                    it.start.push(this.sourceToken);
                                }
                                return [
                                    2
                                ];
                        }
                        if (this.indent >= map.indent) {
                            atMapIndent = !this.onKeyLine && this.indent === map.indent;
                            atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== 'seq-item-ind';
                            // For empty nodes, assign newline-separated not indented empty tokens to following node
                            start = [];
                            if (atNextItem && it.sep && !it.value) {
                                nl = [];
                                for(i = 0; i < it.sep.length; ++i){
                                    st = it.sep[i];
                                    switch(st.type){
                                        case 'newline':
                                            nl.push(i);
                                            break;
                                        case 'space':
                                            break;
                                        case 'comment':
                                            if (st.indent > map.indent) nl.length = 0;
                                            break;
                                        default:
                                            nl.length = 0;
                                    }
                                }
                                if (nl.length >= 2) start = it.sep.splice(nl[1]);
                            }
                            switch(this.type){
                                case 'anchor':
                                case 'tag':
                                    if (atNextItem || it.value) {
                                        start.push(this.sourceToken);
                                        map.items.push({
                                            start: start
                                        });
                                        this.onKeyLine = true;
                                    } else if (it.sep) {
                                        it.sep.push(this.sourceToken);
                                    } else {
                                        it.start.push(this.sourceToken);
                                    }
                                    return [
                                        2
                                    ];
                                case 'explicit-key-ind':
                                    if (!it.sep && !it.explicitKey) {
                                        it.start.push(this.sourceToken);
                                        it.explicitKey = true;
                                    } else if (atNextItem || it.value) {
                                        start.push(this.sourceToken);
                                        map.items.push({
                                            start: start,
                                            explicitKey: true
                                        });
                                    } else {
                                        this.stack.push({
                                            type: 'block-map',
                                            offset: this.offset,
                                            indent: this.indent,
                                            items: [
                                                {
                                                    start: [
                                                        this.sourceToken
                                                    ],
                                                    explicitKey: true
                                                }
                                            ]
                                        });
                                    }
                                    this.onKeyLine = true;
                                    return [
                                        2
                                    ];
                                case 'map-value-ind':
                                    if (it.explicitKey) {
                                        if (!it.sep) {
                                            if (includesToken(it.start, 'newline')) {
                                                Object.assign(it, {
                                                    key: null,
                                                    sep: [
                                                        this.sourceToken
                                                    ]
                                                });
                                            } else {
                                                start1 = getFirstKeyStartProps(it.start);
                                                this.stack.push({
                                                    type: 'block-map',
                                                    offset: this.offset,
                                                    indent: this.indent,
                                                    items: [
                                                        {
                                                            start: start1,
                                                            key: null,
                                                            sep: [
                                                                this.sourceToken
                                                            ]
                                                        }
                                                    ]
                                                });
                                            }
                                        } else if (it.value) {
                                            map.items.push({
                                                start: [],
                                                key: null,
                                                sep: [
                                                    this.sourceToken
                                                ]
                                            });
                                        } else if (includesToken(it.sep, 'map-value-ind')) {
                                            this.stack.push({
                                                type: 'block-map',
                                                offset: this.offset,
                                                indent: this.indent,
                                                items: [
                                                    {
                                                        start: start,
                                                        key: null,
                                                        sep: [
                                                            this.sourceToken
                                                        ]
                                                    }
                                                ]
                                            });
                                        } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {
                                            start2 = getFirstKeyStartProps(it.start);
                                            key = it.key;
                                            sep = it.sep;
                                            sep.push(this.sourceToken);
                                            // @ts-expect-error type guard is wrong here
                                            delete it.key;
                                            // @ts-expect-error type guard is wrong here
                                            delete it.sep;
                                            this.stack.push({
                                                type: 'block-map',
                                                offset: this.offset,
                                                indent: this.indent,
                                                items: [
                                                    {
                                                        start: start2,
                                                        key: key,
                                                        sep: sep
                                                    }
                                                ]
                                            });
                                        } else if (start.length > 0) {
                                            // Not actually at next item
                                            it.sep = it.sep.concat(start, this.sourceToken);
                                        } else {
                                            it.sep.push(this.sourceToken);
                                        }
                                    } else {
                                        if (!it.sep) {
                                            Object.assign(it, {
                                                key: null,
                                                sep: [
                                                    this.sourceToken
                                                ]
                                            });
                                        } else if (it.value || atNextItem) {
                                            map.items.push({
                                                start: start,
                                                key: null,
                                                sep: [
                                                    this.sourceToken
                                                ]
                                            });
                                        } else if (includesToken(it.sep, 'map-value-ind')) {
                                            this.stack.push({
                                                type: 'block-map',
                                                offset: this.offset,
                                                indent: this.indent,
                                                items: [
                                                    {
                                                        start: [],
                                                        key: null,
                                                        sep: [
                                                            this.sourceToken
                                                        ]
                                                    }
                                                ]
                                            });
                                        } else {
                                            it.sep.push(this.sourceToken);
                                        }
                                    }
                                    this.onKeyLine = true;
                                    return [
                                        2
                                    ];
                                case 'alias':
                                case 'scalar':
                                case 'single-quoted-scalar':
                                case 'double-quoted-scalar':
                                    {
                                        fs = this.flowScalar(this.type);
                                        if (atNextItem || it.value) {
                                            map.items.push({
                                                start: start,
                                                key: fs,
                                                sep: []
                                            });
                                            this.onKeyLine = true;
                                        } else if (it.sep) {
                                            this.stack.push(fs);
                                        } else {
                                            Object.assign(it, {
                                                key: fs,
                                                sep: []
                                            });
                                            this.onKeyLine = true;
                                        }
                                        return [
                                            2
                                        ];
                                    }
                                default:
                                    {
                                        bv = this.startBlockValue(map);
                                        if (bv) {
                                            if (atMapIndent && bv.type !== 'block-seq') {
                                                map.items.push({
                                                    start: start
                                                });
                                            }
                                            this.stack.push(bv);
                                            return [
                                                2
                                            ];
                                        }
                                    }
                            }
                        }
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 1:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 2:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        };
        _proto.blockSequence = function blockSequence(seq) {
            var it, end, last, _prev_value, prev, end1, bv;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        it = seq.items[seq.items.length - 1];
                        switch(this.type){
                            case 'newline':
                                if (it.value) {
                                    end = 'end' in it.value ? it.value.end : undefined;
                                    last = Array.isArray(end) ? end[end.length - 1] : undefined;
                                    if ((last === null || last === undefined ? undefined : last.type) === 'comment') end === null || end === undefined ? undefined : end.push(this.sourceToken);
                                    else seq.items.push({
                                        start: [
                                            this.sourceToken
                                        ]
                                    });
                                } else it.start.push(this.sourceToken);
                                return [
                                    2
                                ];
                            case 'space':
                            case 'comment':
                                if (it.value) seq.items.push({
                                    start: [
                                        this.sourceToken
                                    ]
                                });
                                else {
                                    if (this.atIndentedComment(it.start, seq.indent)) {
                                        prev = seq.items[seq.items.length - 2];
                                        end1 = prev === null || prev === undefined ? undefined : (_prev_value = prev.value) === null || _prev_value === undefined ? undefined : _prev_value.end;
                                        if (Array.isArray(end1)) {
                                            Array.prototype.push.apply(end1, it.start);
                                            end1.push(this.sourceToken);
                                            seq.items.pop();
                                            return [
                                                2
                                            ];
                                        }
                                    }
                                    it.start.push(this.sourceToken);
                                }
                                return [
                                    2
                                ];
                            case 'anchor':
                            case 'tag':
                                if (it.value || this.indent <= seq.indent) break;
                                it.start.push(this.sourceToken);
                                return [
                                    2
                                ];
                            case 'seq-item-ind':
                                if (this.indent !== seq.indent) break;
                                if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({
                                    start: [
                                        this.sourceToken
                                    ]
                                });
                                else it.start.push(this.sourceToken);
                                return [
                                    2
                                ];
                        }
                        if (this.indent > seq.indent) {
                            bv = this.startBlockValue(seq);
                            if (bv) {
                                this.stack.push(bv);
                                return [
                                    2
                                ];
                            }
                        }
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 1:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 2:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        };
        _proto.flowCollection = function flowCollection(fc) {
            var it, top, fs, bv, parent, prev, start, sep, map;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        it = fc.items[fc.items.length - 1];
                        if (!(this.type === 'flow-error-end')) return [
                            3,
                            5
                        ];
                        _state.label = 1;
                    case 1:
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 2:
                        _state.sent();
                        top = this.peek(1);
                        _state.label = 3;
                    case 3:
                        if (top && top.type === 'flow-collection') return [
                            3,
                            1
                        ];
                        _state.label = 4;
                    case 4:
                        return [
                            3,
                            16
                        ];
                    case 5:
                        if (!(fc.end.length === 0)) return [
                            3,
                            10
                        ];
                        switch(this.type){
                            case 'comma':
                            case 'explicit-key-ind':
                                if (!it || it.sep) fc.items.push({
                                    start: [
                                        this.sourceToken
                                    ]
                                });
                                else it.start.push(this.sourceToken);
                                return [
                                    2
                                ];
                            case 'map-value-ind':
                                if (!it || it.value) fc.items.push({
                                    start: [],
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                });
                                else if (it.sep) it.sep.push(this.sourceToken);
                                else Object.assign(it, {
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                });
                                return [
                                    2
                                ];
                            case 'space':
                            case 'comment':
                            case 'newline':
                            case 'anchor':
                            case 'tag':
                                if (!it || it.value) fc.items.push({
                                    start: [
                                        this.sourceToken
                                    ]
                                });
                                else if (it.sep) it.sep.push(this.sourceToken);
                                else it.start.push(this.sourceToken);
                                return [
                                    2
                                ];
                            case 'alias':
                            case 'scalar':
                            case 'single-quoted-scalar':
                            case 'double-quoted-scalar':
                                {
                                    fs = this.flowScalar(this.type);
                                    if (!it || it.value) fc.items.push({
                                        start: [],
                                        key: fs,
                                        sep: []
                                    });
                                    else if (it.sep) this.stack.push(fs);
                                    else Object.assign(it, {
                                        key: fs,
                                        sep: []
                                    });
                                    return [
                                        2
                                    ];
                                }
                            case 'flow-map-end':
                            case 'flow-seq-end':
                                fc.end.push(this.sourceToken);
                                return [
                                    2
                                ];
                        }
                        bv = this.startBlockValue(fc);
                        if (!bv) return [
                            3,
                            6
                        ];
                        this.stack.push(bv);
                        return [
                            3,
                            9
                        ];
                    case 6:
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 7:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 8:
                        _state.sent();
                        _state.label = 9;
                    case 9:
                        return [
                            3,
                            16
                        ];
                    case 10:
                        parent = this.peek(2);
                        if (!(parent.type === 'block-map' && (this.type === 'map-value-ind' && parent.indent === fc.indent || this.type === 'newline' && !parent.items[parent.items.length - 1].sep))) return [
                            3,
                            13
                        ];
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 11:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 12:
                        _state.sent();
                        return [
                            3,
                            16
                        ];
                    case 13:
                        if (!(this.type === 'map-value-ind' && parent.type !== 'flow-collection')) return [
                            3,
                            14
                        ];
                        prev = getPrevProps(parent);
                        start = getFirstKeyStartProps(prev);
                        fixFlowSeqItems(fc);
                        sep = fc.end.splice(1, fc.end.length);
                        sep.push(this.sourceToken);
                        map = {
                            type: 'block-map',
                            offset: fc.offset,
                            indent: fc.indent,
                            items: [
                                {
                                    start: start,
                                    key: fc,
                                    sep: sep
                                }
                            ]
                        };
                        this.onKeyLine = true;
                        this.stack[this.stack.length - 1] = map;
                        return [
                            3,
                            16
                        ];
                    case 14:
                        return [
                            5,
                            _ts_values(this.lineEnd(fc))
                        ];
                    case 15:
                        _state.sent();
                        _state.label = 16;
                    case 16:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.flowScalar = function flowScalar(type) {
            if (this.onNewLine) {
                var nl = this.source.indexOf('\n') + 1;
                while(nl !== 0){
                    this.onNewLine(this.offset + nl);
                    nl = this.source.indexOf('\n', nl) + 1;
                }
            }
            return {
                type: type,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            };
        };
        _proto.startBlockValue = function startBlockValue(parent) {
            switch(this.type){
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar':
                    return this.flowScalar(this.type);
                case 'block-scalar-header':
                    return {
                        type: 'block-scalar',
                        offset: this.offset,
                        indent: this.indent,
                        props: [
                            this.sourceToken
                        ],
                        source: ''
                    };
                case 'flow-map-start':
                case 'flow-seq-start':
                    return {
                        type: 'flow-collection',
                        offset: this.offset,
                        indent: this.indent,
                        start: this.sourceToken,
                        items: [],
                        end: []
                    };
                case 'seq-item-ind':
                    return {
                        type: 'block-seq',
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: [
                                    this.sourceToken
                                ]
                            }
                        ]
                    };
                case 'explicit-key-ind':
                    {
                        this.onKeyLine = true;
                        var prev = getPrevProps(parent);
                        var start = getFirstKeyStartProps(prev);
                        start.push(this.sourceToken);
                        return {
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [
                                {
                                    start: start,
                                    explicitKey: true
                                }
                            ]
                        };
                    }
                case 'map-value-ind':
                    {
                        this.onKeyLine = true;
                        var prev1 = getPrevProps(parent);
                        var start1 = getFirstKeyStartProps(prev1);
                        return {
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [
                                {
                                    start: start1,
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                }
                            ]
                        };
                    }
            }
            return null;
        };
        _proto.atIndentedComment = function atIndentedComment(start, indent) {
            if (this.type !== 'comment') return false;
            if (this.indent <= indent) return false;
            return start.every(function(st) {
                return st.type === 'newline' || st.type === 'space';
            });
        };
        _proto.documentEnd = function documentEnd(docEnd) {
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!(this.type !== 'doc-mode')) return [
                            3,
                            2
                        ];
                        if (docEnd.end) docEnd.end.push(this.sourceToken);
                        else docEnd.end = [
                            this.sourceToken
                        ];
                        if (!(this.type === 'newline')) return [
                            3,
                            2
                        ];
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 1:
                        _state.sent();
                        _state.label = 2;
                    case 2:
                        return [
                            2
                        ];
                }
            });
        };
        _proto.lineEnd = function lineEnd(token) {
            var _;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _ = this.type;
                        switch(_){
                            case 'comma':
                                return [
                                    3,
                                    1
                                ];
                            case 'doc-start':
                                return [
                                    3,
                                    1
                                ];
                            case 'doc-end':
                                return [
                                    3,
                                    1
                                ];
                            case 'flow-seq-end':
                                return [
                                    3,
                                    1
                                ];
                            case 'flow-map-end':
                                return [
                                    3,
                                    1
                                ];
                            case 'map-value-ind':
                                return [
                                    3,
                                    1
                                ];
                            case 'newline':
                                return [
                                    3,
                                    4
                                ];
                            case 'space':
                                return [
                                    3,
                                    5
                                ];
                            case 'comment':
                                return [
                                    3,
                                    5
                                ];
                        }
                        return [
                            3,
                            5
                        ];
                    case 1:
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 2:
                        _state.sent();
                        return [
                            5,
                            _ts_values(this.step())
                        ];
                    case 3:
                        _state.sent();
                        return [
                            3,
                            7
                        ];
                    case 4:
                        this.onKeyLine = false;
                        _state.label = 5;
                    case 5:
                        // all other values are errors
                        if (token.end) token.end.push(this.sourceToken);
                        else token.end = [
                            this.sourceToken
                        ];
                        if (!(this.type === 'newline')) return [
                            3,
                            7
                        ];
                        return [
                            5,
                            _ts_values(this.pop())
                        ];
                    case 6:
                        _state.sent();
                        _state.label = 7;
                    case 7:
                        return [
                            2
                        ];
                }
            });
        };
        _create_class$6(Parser, [
            {
                key: "sourceToken",
                get: function get() {
                    var st = {
                        type: this.type,
                        offset: this.offset,
                        indent: this.indent,
                        source: this.source
                    };
                    return st;
                }
            }
        ]);
        return Parser;
    }();
    parser.Parser = Parser;
    return parser;
}

var publicApi = {};

function _type_of$h(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var hasRequiredPublicApi;
function requirePublicApi() {
    if (hasRequiredPublicApi) return publicApi;
    hasRequiredPublicApi = 1;
    var composer = requireComposer();
    var Document = requireDocument();
    var errors = requireErrors();
    var log = requireLog();
    var identity = requireIdentity();
    var lineCounter = requireLineCounter();
    var parser = requireParser();
    function parseOptions(options) {
        var prettyErrors = options.prettyErrors !== false;
        var lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
        return {
            lineCounter: lineCounter$1,
            prettyErrors: prettyErrors
        };
    }
    /**
	 * Parse the input as a stream of YAML documents.
	 *
	 * Documents should be separated from each other by `...` or `---` marker lines.
	 *
	 * @returns If an empty `docs` array is returned, it will be of type
	 *   EmptyStream and contain additional stream information. In
	 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
	 */ function parseAllDocuments(source) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _parseOptions = parseOptions(options), lineCounter = _parseOptions.lineCounter, prettyErrors = _parseOptions.prettyErrors;
        var parser$1 = new parser.Parser(lineCounter === null || lineCounter === undefined ? undefined : lineCounter.addNewLine);
        var composer$1 = new composer.Composer(options);
        var docs = Array.from(composer$1.compose(parser$1.parse(source)));
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        if (prettyErrors && lineCounter) try {
            for(var _iterator = docs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var doc = _step.value;
                doc.errors.forEach(errors.prettifyError(source, lineCounter));
                doc.warnings.forEach(errors.prettifyError(source, lineCounter));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (docs.length > 0) return docs;
        return Object.assign([], {
            empty: true
        }, composer$1.streamInfo());
    }
    /** Parse an input string into a single YAML.Document */ function parseDocument(source) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _parseOptions = parseOptions(options), lineCounter = _parseOptions.lineCounter, prettyErrors = _parseOptions.prettyErrors;
        var parser$1 = new parser.Parser(lineCounter === null || lineCounter === undefined ? undefined : lineCounter.addNewLine);
        var composer$1 = new composer.Composer(options);
        // `doc` is always set by compose.end(true) at the very latest
        var doc = null;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = composer$1.compose(parser$1.parse(source), true, source.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _doc = _step.value;
                if (!doc) doc = _doc;
                else if (doc.options.logLevel !== 'silent') {
                    doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
                    break;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (prettyErrors && lineCounter) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
        return doc;
    }
    function parse(src, reviver, options) {
        var _reviver = undefined;
        if (typeof reviver === 'function') {
            _reviver = reviver;
        } else if (options === undefined && reviver && (typeof reviver === "undefined" ? "undefined" : _type_of$h(reviver)) === 'object') {
            options = reviver;
        }
        var doc = parseDocument(src, options);
        if (!doc) return null;
        doc.warnings.forEach(function(warning) {
            return log.warn(doc.options.logLevel, warning);
        });
        if (doc.errors.length > 0) {
            if (doc.options.logLevel !== 'silent') throw doc.errors[0];
            else doc.errors = [];
        }
        return doc.toJS(Object.assign({
            reviver: _reviver
        }, options));
    }
    function stringify(value, replacer, options) {
        var _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        } else if (options === undefined && replacer) {
            options = replacer;
        }
        if (typeof options === 'string') options = options.length;
        if (typeof options === 'number') {
            var indent = Math.round(options);
            options = indent < 1 ? undefined : indent > 8 ? {
                indent: 8
            } : {
                indent: indent
            };
        }
        if (value === undefined) {
            var _ref;
            var keepUndefined = ((_ref = options !== null && options !== undefined ? options : replacer) !== null && _ref !== undefined ? _ref : {}).keepUndefined;
            if (!keepUndefined) return undefined;
        }
        if (identity.isDocument(value) && !_replacer) return value.toString(options);
        return new Document.Document(value, _replacer, options).toString(options);
    }
    publicApi.parse = parse;
    publicApi.parseAllDocuments = parseAllDocuments;
    publicApi.parseDocument = parseDocument;
    publicApi.stringify = stringify;
    return publicApi;
}

var hasRequiredDist;
function requireDist() {
    if (hasRequiredDist) return dist;
    hasRequiredDist = 1;
    var composer = requireComposer();
    var Document = requireDocument();
    var Schema = requireSchema();
    var errors = requireErrors();
    var Alias = requireAlias();
    var identity = requireIdentity();
    var Pair = requirePair();
    var Scalar = requireScalar();
    var YAMLMap = requireYAMLMap();
    var YAMLSeq = requireYAMLSeq();
    var cst = requireCst();
    var lexer = requireLexer();
    var lineCounter = requireLineCounter();
    var parser = requireParser();
    var publicApi = requirePublicApi();
    var visit = requireVisit();
    dist.Composer = composer.Composer;
    dist.Document = Document.Document;
    dist.Schema = Schema.Schema;
    dist.YAMLError = errors.YAMLError;
    dist.YAMLParseError = errors.YAMLParseError;
    dist.YAMLWarning = errors.YAMLWarning;
    dist.Alias = Alias.Alias;
    dist.isAlias = identity.isAlias;
    dist.isCollection = identity.isCollection;
    dist.isDocument = identity.isDocument;
    dist.isMap = identity.isMap;
    dist.isNode = identity.isNode;
    dist.isPair = identity.isPair;
    dist.isScalar = identity.isScalar;
    dist.isSeq = identity.isSeq;
    dist.Pair = Pair.Pair;
    dist.Scalar = Scalar.Scalar;
    dist.YAMLMap = YAMLMap.YAMLMap;
    dist.YAMLSeq = YAMLSeq.YAMLSeq;
    dist.CST = cst;
    dist.Lexer = lexer.Lexer;
    dist.LineCounter = lineCounter.LineCounter;
    dist.Parser = parser.Parser;
    dist.parse = publicApi.parse;
    dist.parseAllDocuments = publicApi.parseAllDocuments;
    dist.parseDocument = publicApi.parseDocument;
    dist.stringify = publicApi.stringify;
    dist.visit = visit.visit;
    dist.visitAsync = visit.visitAsync;
    return dist;
}

var distExports = requireDist();

function _array_like_to_array$8(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$3(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes$6(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$8(arr);
}
function _assert_this_initialized$8(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$8(_this, derived, args) {
    derived = _get_prototype_of$8(derived);
    return _possible_constructor_return$8(_this, _is_native_reflect_construct$8() ? Reflect.construct(derived, [], _get_prototype_of$8(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$h(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct$2(Parent, args, Class) {
    if (_is_native_reflect_construct$8()) {
        _construct$2 = Reflect.construct;
    } else {
        _construct$2 = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of$8(instance, Class.prototype);
            return instance;
        };
    }
    return _construct$2.apply(null, arguments);
}
function _defineProperties$5(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$5(Constructor, protoProps, staticProps) {
    _defineProperties$5(Constructor.prototype, protoProps);
    return Constructor;
}
function _get_prototype_of$8(o) {
    _get_prototype_of$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$8(o);
}
function _inherits$8(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$8(subClass, superClass);
}
function _is_native_function$2(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array$6(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit$3(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$3() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread$6() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$8(self, call) {
    if (call && (_type_of$g(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$8(self);
}
function _set_prototype_of$8(o, p) {
    _set_prototype_of$8 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$8(o, p);
}
function _sliced_to_array$3(arr, i) {
    return _array_with_holes$3(arr) || _iterable_to_array_limit$3(arr, i) || _unsupported_iterable_to_array$8(arr, i) || _non_iterable_rest$3();
}
function _to_consumable_array$6(arr) {
    return _array_without_holes$6(arr) || _iterable_to_array$6(arr) || _unsupported_iterable_to_array$8(arr) || _non_iterable_spread$6();
}
function _type_of$g(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$8(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$8(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$8(o, minLen);
}
function _wrap_native_super$2(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super$2 = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function$2(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct$2(Class, arguments, _get_prototype_of$8(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of$8(Wrapper, Class);
    };
    return _wrap_native_super$2(Class);
}
function _is_native_reflect_construct$8() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$8 = function() {
        return !!result;
    })();
}
var lastCollapsedNodeId = 0;
var CyclicPackageGraphNode = /*#__PURE__*/ function(Map1) {
    _inherits$8(CyclicPackageGraphNode, Map1);
    function CyclicPackageGraphNode() {
        _class_call_check$h(this, CyclicPackageGraphNode);
        var _this;
        _this = _call_super$8(this, CyclicPackageGraphNode);
        _this.name = "(cycle) ".concat(lastCollapsedNodeId += 1);
        _this.localDependencies = new Map();
        _this.localDependents = new Map();
        return _this;
    }
    var _proto = CyclicPackageGraphNode.prototype;
    _proto.toString = function toString() {
        var parts = Array.from(this, function(param) {
            var _param = _sliced_to_array$3(param, 2), key = _param[0], node = _param[1];
            return node.isCycle ? "(nested cycle: ".concat(node.toString(), ")") : key;
        });
        parts.push(parts[0]);
        return parts.reverse().join(' -> ');
    };
    _proto.flatten = function flatten() {
        var result = [];
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = this.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var node = _step.value;
                if (node.isCycle) {
                    var _result;
                    (_result = result).push.apply(_result, _to_consumable_array$6(node.flatten()));
                } else {
                    result.push(node);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return result;
    };
    _proto.contains = function contains(name) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = this[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array$3(_step.value, 2), currentName = _step_value[0], currentNode = _step_value[1];
                if (currentNode.isCycle) {
                    if (currentNode.contains(name)) {
                        return true;
                    }
                } else if (currentName === name) {
                    return true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return false;
    };
    _proto.insert = function insert(node) {
        this.set(node.name, node);
        this.unlink(node);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = node.localDependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array$3(_step.value, 2), dependencyName = _step_value[0], dependencyNode = _step_value[1];
                if (!this.contains(dependencyName)) {
                    this.localDependencies.set(dependencyName, dependencyNode);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = node.localDependents[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var _step_value1 = _sliced_to_array$3(_step1.value, 2), dependentName = _step_value1[0], dependentNode = _step_value1[1];
                if (!this.contains(dependentName)) {
                    this.localDependents.set(dependentName, dependentNode);
                }
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
    };
    _proto.unlink = function unlink(candidateNode) {
        this.localDependencies.delete(candidateNode.name);
        this.localDependents.delete(candidateNode.name);
    };
    _create_class$5(CyclicPackageGraphNode, [
        {
            key: "isCycle",
            get: function get() {
                return true;
            }
        }
    ]);
    return CyclicPackageGraphNode;
} 
(_wrap_native_super$2(Map));

var re = {
    exports: {}
};

var constants;
var hasRequiredConstants;
function requireConstants() {
    if (hasRequiredConstants) return constants;
    hasRequiredConstants = 1;
    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    var SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
    // Max safe segment length for coercion.
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    // Max safe length for a build identifier. The max length minus 6 characters for
    // the shortest version with a build 0.0.0+BUILD.
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
        'major',
        'premajor',
        'minor',
        'preminor',
        'patch',
        'prepatch',
        'prerelease'
    ];
    constants = {
        MAX_LENGTH: MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
        RELEASE_TYPES: RELEASE_TYPES,
        SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
    };
    return constants;
}

function _array_like_to_array$7(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$5(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$7(arr);
}
function _iterable_to_array$5(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$5() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array$5(arr) {
    return _array_without_holes$5(arr) || _iterable_to_array$5(arr) || _unsupported_iterable_to_array$7(arr) || _non_iterable_spread$5();
}
function _type_of$f(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$7(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$7(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$7(o, minLen);
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
    var _console;
    if (hasRequiredDebug) return debug_1;
    hasRequiredDebug = 1;
    var debug = (typeof process === "undefined" ? "undefined" : _type_of$f(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return (_console = console).error.apply(_console, [
            'SEMVER'
        ].concat(_to_consumable_array$5(args)));
    } : function() {};
    debug_1 = debug;
    return debug_1;
}

function _array_like_to_array$6(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$2(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$2(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$2(arr, i) {
    return _array_with_holes$2(arr) || _iterable_to_array_limit$2(arr, i) || _unsupported_iterable_to_array$6(arr, i) || _non_iterable_rest$2();
}
function _unsupported_iterable_to_array$6(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$6(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$6(o, minLen);
}
var hasRequiredRe;
function requireRe() {
    if (hasRequiredRe) return re.exports;
    hasRequiredRe = 1;
    (function(module, exports) {
        var _require$$0 = requireConstants(), MAX_SAFE_COMPONENT_LENGTH = _require$$0.MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH = _require$$0.MAX_SAFE_BUILD_LENGTH, MAX_LENGTH = _require$$0.MAX_LENGTH;
        var debug = requireDebug();
        exports = module.exports = {};
        // The actual regexps go on exports.re
        var re = exports.re = [];
        var safeRe = exports.safeRe = [];
        var src = exports.src = [];
        var t = exports.t = {};
        var R = 0;
        var LETTERDASHNUMBER = '[a-zA-Z0-9-]';
        // Replace some greedy regex tokens to prevent regex dos issues. These regex are
        // used internally via the safeRe object since all inputs in this library get
        // normalized first to trim and collapse all extra whitespace. The original
        // regexes are exported for userland consumption and lower level usage. A
        // future breaking change could export the safer regex only with a note that
        // all input should have extra whitespace removed.
        var safeRegexReplacements = [
            [
                '\\s',
                1
            ],
            [
                '\\d',
                MAX_LENGTH
            ],
            [
                LETTERDASHNUMBER,
                MAX_SAFE_BUILD_LENGTH
            ]
        ];
        var makeSafeRegex = function(value) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = safeRegexReplacements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array$2(_step.value, 2), token = _step_value[0], max = _step_value[1];
                    value = value.split("".concat(token, "*")).join("".concat(token, "{0,").concat(max, "}")).split("".concat(token, "+")).join("".concat(token, "{1,").concat(max, "}"));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return value;
        };
        var createToken = function(name, value, isGlobal) {
            var safe = makeSafeRegex(value);
            var index = R++;
            debug(name, index, value);
            t[name] = index;
            src[index] = value;
            re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
            safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
        };
        // The following Regular Expressions can be used for tokenizing,
        // validating, and parsing SemVer version strings.
        // ## Numeric Identifier
        // A single `0`, or a non-zero digit followed by zero or more digits.
        createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
        createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
        // ## Non-numeric Identifier
        // Zero or more digits, followed by a letter or hyphen, and then zero or
        // more letters, digits, or hyphens.
        createToken('NONNUMERICIDENTIFIER', "\\d*[a-zA-Z-]".concat(LETTERDASHNUMBER, "*"));
        // ## Main Version
        // Three dot-separated numeric identifiers.
        createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
        createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")"));
        // ## Pre-release Version Identifier
        // A numeric identifier, or a non-numeric identifier.
        createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
        createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
        // ## Pre-release Version
        // Hyphen, followed by one or more dot-separated pre-release version
        // identifiers.
        createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
        createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))"));
        // ## Build Metadata Identifier
        // Any combination of digits, letters, or hyphens.
        createToken('BUILDIDENTIFIER', "".concat(LETTERDASHNUMBER, "+"));
        // ## Build Metadata
        // Plus sign, followed by one or more period-separated build metadata
        // identifiers.
        createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))"));
        // ## Full Version String
        // A main version, followed optionally by a pre-release version and
        // build metadata.
        // Note that the only major, minor, patch, and pre-release sections of
        // the version string are capturing groups.  The build metadata is not a
        // capturing group, because it should not ever be used in version
        // comparison.
        createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
        createToken('FULL', "^".concat(src[t.FULLPLAIN], "$"));
        // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
        // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
        // common in the npm registry.
        createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
        createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
        createToken('GTLT', '((?:<|>)?=?)');
        // Something like "2.*" or "1.2.x".
        // Note that "x.x" is a valid xRange identifer, meaning "any version"
        // Only the first item is strictly required.
        createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
        createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
        createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
        createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
        createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
        createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$"));
        // Coercion.
        // Extract anything that could conceivably be a part of a valid semver
        createToken('COERCEPLAIN', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?"));
        createToken('COERCE', "".concat(src[t.COERCEPLAIN], "(?:$|[^\\d])"));
        createToken('COERCEFULL', src[t.COERCEPLAIN] + "(?:".concat(src[t.PRERELEASE], ")?") + "(?:".concat(src[t.BUILD], ")?") + "(?:$|[^\\d])");
        createToken('COERCERTL', src[t.COERCE], true);
        createToken('COERCERTLFULL', src[t.COERCEFULL], true);
        // Tilde ranges.
        // Meaning is "reasonably at or greater than"
        createToken('LONETILDE', '(?:~>?)');
        createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
        exports.tildeTrimReplace = '$1~';
        createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
        createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$"));
        // Caret ranges.
        // Meaning is "at least and backwards compatible with"
        createToken('LONECARET', '(?:\\^)');
        createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
        exports.caretTrimReplace = '$1^';
        createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
        createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$"));
        // A simple gt/lt/eq thing, or just "" to indicate "any version"
        createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
        createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$"));
        // An expression to strip any whitespace between the gtlt and the thing
        // it modifies, so that `> 1.2.3` ==> `>1.2.3`
        createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
        exports.comparatorTrimReplace = '$1$2$3';
        // Something like `1.2.3 - 1.2.4`
        // Note that these all use the loose form, because they'll be
        // checked against either the strict or loose comparator form
        // later.
        createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
        createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$");
        // Star ranges basically just allow anything at all.
        createToken('STAR', '(<|>)?=?\\s*\\*');
        // >=0.0.0 is like a star
        createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
        createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    })(re, re.exports);
    return re.exports;
}

function _type_of$e(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
    if (hasRequiredParseOptions) return parseOptions_1;
    hasRequiredParseOptions = 1;
    // parse out just the options we care about
    var looseOption = Object.freeze({
        loose: true
    });
    var emptyOpts = Object.freeze({});
    var parseOptions = function(options) {
        if (!options) {
            return emptyOpts;
        }
        if ((typeof options === "undefined" ? "undefined" : _type_of$e(options)) !== 'object') {
            return looseOption;
        }
        return options;
    };
    parseOptions_1 = parseOptions;
    return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
    if (hasRequiredIdentifiers) return identifiers;
    hasRequiredIdentifiers = 1;
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = function(a, b) {
        var anum = numeric.test(a);
        var bnum = numeric.test(b);
        if (anum && bnum) {
            a = +a;
            b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = function(a, b) {
        return compareIdentifiers(b, a);
    };
    identifiers = {
        compareIdentifiers: compareIdentifiers,
        rcompareIdentifiers: rcompareIdentifiers
    };
    return identifiers;
}

function _class_call_check$g(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _instanceof$8(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _type_of$d(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var semver$2;
var hasRequiredSemver$1;
function requireSemver$1() {
    if (hasRequiredSemver$1) return semver$2;
    hasRequiredSemver$1 = 1;
    var debug = requireDebug();
    var _require$$1 = requireConstants(), MAX_LENGTH = _require$$1.MAX_LENGTH, MAX_SAFE_INTEGER = _require$$1.MAX_SAFE_INTEGER;
    var _require$$2 = requireRe(), re = _require$$2.safeRe, t = _require$$2.t;
    var parseOptions = requireParseOptions();
    var compareIdentifiers = requireIdentifiers().compareIdentifiers;
    var SemVer = /*#__PURE__*/ function() {
        function SemVer(version, options) {
            _class_call_check$g(this, SemVer);
            options = parseOptions(options);
            if (_instanceof$8(version, SemVer)) {
                if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                    return version;
                } else {
                    version = version.version;
                }
            } else if (typeof version !== 'string') {
                throw new TypeError('Invalid version. Must be a string. Got type "'.concat(typeof version === "undefined" ? "undefined" : _type_of$d(version), '".'));
            }
            if (version.length > MAX_LENGTH) {
                throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
            }
            debug('SemVer', version, options);
            this.options = options;
            this.loose = !!options.loose;
            // this isn't actually relevant for versions, but keep it so that we
            // don't run into trouble passing this.options around.
            this.includePrerelease = !!options.includePrerelease;
            var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
            if (!m) {
                throw new TypeError("Invalid Version: ".concat(version));
            }
            this.raw = version;
            // these are actually numbers
            this.major = +m[1];
            this.minor = +m[2];
            this.patch = +m[3];
            if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
                throw new TypeError('Invalid major version');
            }
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
                throw new TypeError('Invalid minor version');
            }
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
                throw new TypeError('Invalid patch version');
            }
            // numberify any prerelease numeric ids
            if (!m[4]) {
                this.prerelease = [];
            } else {
                this.prerelease = m[4].split('.').map(function(id) {
                    if (/^[0-9]+$/.test(id)) {
                        var num = +id;
                        if (num >= 0 && num < MAX_SAFE_INTEGER) {
                            return num;
                        }
                    }
                    return id;
                });
            }
            this.build = m[5] ? m[5].split('.') : [];
            this.format();
        }
        var _proto = SemVer.prototype;
        _proto.format = function format() {
            this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
            if (this.prerelease.length) {
                this.version += "-".concat(this.prerelease.join('.'));
            }
            return this.version;
        };
        _proto.toString = function toString() {
            return this.version;
        };
        _proto.compare = function compare(other) {
            debug('SemVer.compare', this.version, this.options, other);
            if (!_instanceof$8(other, SemVer)) {
                if (typeof other === 'string' && other === this.version) {
                    return 0;
                }
                other = new SemVer(other, this.options);
            }
            if (other.version === this.version) {
                return 0;
            }
            return this.compareMain(other) || this.comparePre(other);
        };
        _proto.compareMain = function compareMain(other) {
            if (!_instanceof$8(other, SemVer)) {
                other = new SemVer(other, this.options);
            }
            return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        };
        _proto.comparePre = function comparePre(other) {
            if (!_instanceof$8(other, SemVer)) {
                other = new SemVer(other, this.options);
            }
            // NOT having a prerelease is > having one
            if (this.prerelease.length && !other.prerelease.length) {
                return -1;
            } else if (!this.prerelease.length && other.prerelease.length) {
                return 1;
            } else if (!this.prerelease.length && !other.prerelease.length) {
                return 0;
            }
            var i = 0;
            do {
                var a = this.prerelease[i];
                var b = other.prerelease[i];
                debug('prerelease compare', i, a, b);
                if (a === undefined && b === undefined) {
                    return 0;
                } else if (b === undefined) {
                    return 1;
                } else if (a === undefined) {
                    return -1;
                } else if (a === b) {
                    continue;
                } else {
                    return compareIdentifiers(a, b);
                }
            }while (++i);
        };
        _proto.compareBuild = function compareBuild(other) {
            if (!_instanceof$8(other, SemVer)) {
                other = new SemVer(other, this.options);
            }
            var i = 0;
            do {
                var a = this.build[i];
                var b = other.build[i];
                debug('build compare', i, a, b);
                if (a === undefined && b === undefined) {
                    return 0;
                } else if (b === undefined) {
                    return 1;
                } else if (a === undefined) {
                    return -1;
                } else if (a === b) {
                    continue;
                } else {
                    return compareIdentifiers(a, b);
                }
            }while (++i);
        };
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        _proto.inc = function inc(release, identifier, identifierBase) {
            switch(release){
                case 'premajor':
                    this.prerelease.length = 0;
                    this.patch = 0;
                    this.minor = 0;
                    this.major++;
                    this.inc('pre', identifier, identifierBase);
                    break;
                case 'preminor':
                    this.prerelease.length = 0;
                    this.patch = 0;
                    this.minor++;
                    this.inc('pre', identifier, identifierBase);
                    break;
                case 'prepatch':
                    // If this is already a prerelease, it will bump to the next version
                    // drop any prereleases that might already exist, since they are not
                    // relevant at this point.
                    this.prerelease.length = 0;
                    this.inc('patch', identifier, identifierBase);
                    this.inc('pre', identifier, identifierBase);
                    break;
                // If the input is a non-prerelease version, this acts the same as
                // prepatch.
                case 'prerelease':
                    if (this.prerelease.length === 0) {
                        this.inc('patch', identifier, identifierBase);
                    }
                    this.inc('pre', identifier, identifierBase);
                    break;
                case 'major':
                    // If this is a pre-major version, bump up to the same major version.
                    // Otherwise increment major.
                    // 1.0.0-5 bumps to 1.0.0
                    // 1.1.0 bumps to 2.0.0
                    if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                        this.major++;
                    }
                    this.minor = 0;
                    this.patch = 0;
                    this.prerelease = [];
                    break;
                case 'minor':
                    // If this is a pre-minor version, bump up to the same minor version.
                    // Otherwise increment minor.
                    // 1.2.0-5 bumps to 1.2.0
                    // 1.2.1 bumps to 1.3.0
                    if (this.patch !== 0 || this.prerelease.length === 0) {
                        this.minor++;
                    }
                    this.patch = 0;
                    this.prerelease = [];
                    break;
                case 'patch':
                    // If this is not a pre-release version, it will increment the patch.
                    // If it is a pre-release it will bump up to the same patch version.
                    // 1.2.0-5 patches to 1.2.0
                    // 1.2.0 patches to 1.2.1
                    if (this.prerelease.length === 0) {
                        this.patch++;
                    }
                    this.prerelease = [];
                    break;
                // This probably shouldn't be used publicly.
                // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
                case 'pre':
                    {
                        var base = Number(identifierBase) ? 1 : 0;
                        if (!identifier && identifierBase === false) {
                            throw new Error('invalid increment argument: identifier is empty');
                        }
                        if (this.prerelease.length === 0) {
                            this.prerelease = [
                                base
                            ];
                        } else {
                            var i = this.prerelease.length;
                            while(--i >= 0){
                                if (typeof this.prerelease[i] === 'number') {
                                    this.prerelease[i]++;
                                    i = -2;
                                }
                            }
                            if (i === -1) {
                                // didn't increment anything
                                if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                    throw new Error('invalid increment argument: identifier already exists');
                                }
                                this.prerelease.push(base);
                            }
                        }
                        if (identifier) {
                            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                            var prerelease = [
                                identifier,
                                base
                            ];
                            if (identifierBase === false) {
                                prerelease = [
                                    identifier
                                ];
                            }
                            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                                if (isNaN(this.prerelease[1])) {
                                    this.prerelease = prerelease;
                                }
                            } else {
                                this.prerelease = prerelease;
                            }
                        }
                        break;
                    }
                default:
                    throw new Error("invalid increment argument: ".concat(release));
            }
            this.raw = this.format();
            if (this.build.length) {
                this.raw += "+".concat(this.build.join('.'));
            }
            return this;
        };
        return SemVer;
    }();
    semver$2 = SemVer;
    return semver$2;
}

function _instanceof$7(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var parse_1;
var hasRequiredParse;
function requireParse() {
    if (hasRequiredParse) return parse_1;
    hasRequiredParse = 1;
    var SemVer = requireSemver$1();
    var parse = function(version, options) {
        var throwErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (_instanceof$7(version, SemVer)) {
            return version;
        }
        try {
            return new SemVer(version, options);
        } catch (er) {
            if (!throwErrors) {
                return null;
            }
            throw er;
        }
    };
    parse_1 = parse;
    return parse_1;
}

var valid_1;
var hasRequiredValid$1;
function requireValid$1() {
    if (hasRequiredValid$1) return valid_1;
    hasRequiredValid$1 = 1;
    var parse = requireParse();
    var valid = function(version, options) {
        var v = parse(version, options);
        return v ? v.version : null;
    };
    valid_1 = valid;
    return valid_1;
}

var clean_1;
var hasRequiredClean;
function requireClean() {
    if (hasRequiredClean) return clean_1;
    hasRequiredClean = 1;
    var parse = requireParse();
    var clean = function(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ''), options);
        return s ? s.version : null;
    };
    clean_1 = clean;
    return clean_1;
}

function _instanceof$6(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var inc_1;
var hasRequiredInc;
function requireInc() {
    if (hasRequiredInc) return inc_1;
    hasRequiredInc = 1;
    var SemVer = requireSemver$1();
    var inc = function(version, release, options, identifier, identifierBase) {
        if (typeof options === 'string') {
            identifierBase = identifier;
            identifier = options;
            options = undefined;
        }
        try {
            return new SemVer(_instanceof$6(version, SemVer) ? version.version : version, options).inc(release, identifier, identifierBase).version;
        } catch (er) {
            return null;
        }
    };
    inc_1 = inc;
    return inc_1;
}

var diff_1;
var hasRequiredDiff;
function requireDiff() {
    if (hasRequiredDiff) return diff_1;
    hasRequiredDiff = 1;
    var parse = requireParse();
    var diff = function(version1, version2) {
        var v1 = parse(version1, null, true);
        var v2 = parse(version2, null, true);
        var comparison = v1.compare(v2);
        if (comparison === 0) {
            return null;
        }
        var v1Higher = comparison > 0;
        var highVersion = v1Higher ? v1 : v2;
        var lowVersion = v1Higher ? v2 : v1;
        var highHasPre = !!highVersion.prerelease.length;
        var lowHasPre = !!lowVersion.prerelease.length;
        if (lowHasPre && !highHasPre) {
            // Going from prerelease -> no prerelease requires some special casing
            // If the low version has only a major, then it will always be a major
            // Some examples:
            // 1.0.0-1 -> 1.0.0
            // 1.0.0-1 -> 1.1.1
            // 1.0.0-1 -> 2.0.0
            if (!lowVersion.patch && !lowVersion.minor) {
                return 'major';
            }
            // Otherwise it can be determined by checking the high version
            if (highVersion.patch) {
                // anything higher than a patch bump would result in the wrong version
                return 'patch';
            }
            if (highVersion.minor) {
                // anything higher than a minor bump would result in the wrong version
                return 'minor';
            }
            // bumping major/minor/patch all have same result
            return 'major';
        }
        // add the `pre` prefix if we are going to a prerelease version
        var prefix = highHasPre ? 'pre' : '';
        if (v1.major !== v2.major) {
            return prefix + 'major';
        }
        if (v1.minor !== v2.minor) {
            return prefix + 'minor';
        }
        if (v1.patch !== v2.patch) {
            return prefix + 'patch';
        }
        // high and low are preleases
        return 'prerelease';
    };
    diff_1 = diff;
    return diff_1;
}

var major_1;
var hasRequiredMajor;
function requireMajor() {
    if (hasRequiredMajor) return major_1;
    hasRequiredMajor = 1;
    var SemVer = requireSemver$1();
    var major = function(a, loose) {
        return new SemVer(a, loose).major;
    };
    major_1 = major;
    return major_1;
}

var minor_1;
var hasRequiredMinor;
function requireMinor() {
    if (hasRequiredMinor) return minor_1;
    hasRequiredMinor = 1;
    var SemVer = requireSemver$1();
    var minor = function(a, loose) {
        return new SemVer(a, loose).minor;
    };
    minor_1 = minor;
    return minor_1;
}

var patch_1;
var hasRequiredPatch;
function requirePatch() {
    if (hasRequiredPatch) return patch_1;
    hasRequiredPatch = 1;
    var SemVer = requireSemver$1();
    var patch = function(a, loose) {
        return new SemVer(a, loose).patch;
    };
    patch_1 = patch;
    return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;
function requirePrerelease() {
    if (hasRequiredPrerelease) return prerelease_1;
    hasRequiredPrerelease = 1;
    var parse = requireParse();
    var prerelease = function(version, options) {
        var parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    prerelease_1 = prerelease;
    return prerelease_1;
}

var compare_1;
var hasRequiredCompare;
function requireCompare() {
    if (hasRequiredCompare) return compare_1;
    hasRequiredCompare = 1;
    var SemVer = requireSemver$1();
    var compare = function(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose));
    };
    compare_1 = compare;
    return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;
function requireRcompare() {
    if (hasRequiredRcompare) return rcompare_1;
    hasRequiredRcompare = 1;
    var compare = requireCompare();
    var rcompare = function(a, b, loose) {
        return compare(b, a, loose);
    };
    rcompare_1 = rcompare;
    return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;
function requireCompareLoose() {
    if (hasRequiredCompareLoose) return compareLoose_1;
    hasRequiredCompareLoose = 1;
    var compare = requireCompare();
    var compareLoose = function(a, b) {
        return compare(a, b, true);
    };
    compareLoose_1 = compareLoose;
    return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;
function requireCompareBuild() {
    if (hasRequiredCompareBuild) return compareBuild_1;
    hasRequiredCompareBuild = 1;
    var SemVer = requireSemver$1();
    var compareBuild = function(a, b, loose) {
        var versionA = new SemVer(a, loose);
        var versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    compareBuild_1 = compareBuild;
    return compareBuild_1;
}

var sort_1;
var hasRequiredSort;
function requireSort() {
    if (hasRequiredSort) return sort_1;
    hasRequiredSort = 1;
    var compareBuild = requireCompareBuild();
    var sort = function(list, loose) {
        return list.sort(function(a, b) {
            return compareBuild(a, b, loose);
        });
    };
    sort_1 = sort;
    return sort_1;
}

var rsort_1;
var hasRequiredRsort;
function requireRsort() {
    if (hasRequiredRsort) return rsort_1;
    hasRequiredRsort = 1;
    var compareBuild = requireCompareBuild();
    var rsort = function(list, loose) {
        return list.sort(function(a, b) {
            return compareBuild(b, a, loose);
        });
    };
    rsort_1 = rsort;
    return rsort_1;
}

var gt_1;
var hasRequiredGt;
function requireGt() {
    if (hasRequiredGt) return gt_1;
    hasRequiredGt = 1;
    var compare = requireCompare();
    var gt = function(a, b, loose) {
        return compare(a, b, loose) > 0;
    };
    gt_1 = gt;
    return gt_1;
}

var lt_1;
var hasRequiredLt;
function requireLt() {
    if (hasRequiredLt) return lt_1;
    hasRequiredLt = 1;
    var compare = requireCompare();
    var lt = function(a, b, loose) {
        return compare(a, b, loose) < 0;
    };
    lt_1 = lt;
    return lt_1;
}

var eq_1;
var hasRequiredEq;
function requireEq() {
    if (hasRequiredEq) return eq_1;
    hasRequiredEq = 1;
    var compare = requireCompare();
    var eq = function(a, b, loose) {
        return compare(a, b, loose) === 0;
    };
    eq_1 = eq;
    return eq_1;
}

var neq_1;
var hasRequiredNeq;
function requireNeq() {
    if (hasRequiredNeq) return neq_1;
    hasRequiredNeq = 1;
    var compare = requireCompare();
    var neq = function(a, b, loose) {
        return compare(a, b, loose) !== 0;
    };
    neq_1 = neq;
    return neq_1;
}

var gte_1;
var hasRequiredGte;
function requireGte() {
    if (hasRequiredGte) return gte_1;
    hasRequiredGte = 1;
    var compare = requireCompare();
    var gte = function(a, b, loose) {
        return compare(a, b, loose) >= 0;
    };
    gte_1 = gte;
    return gte_1;
}

var lte_1;
var hasRequiredLte;
function requireLte() {
    if (hasRequiredLte) return lte_1;
    hasRequiredLte = 1;
    var compare = requireCompare();
    var lte = function(a, b, loose) {
        return compare(a, b, loose) <= 0;
    };
    lte_1 = lte;
    return lte_1;
}

function _type_of$c(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
    if (hasRequiredCmp) return cmp_1;
    hasRequiredCmp = 1;
    var eq = requireEq();
    var neq = requireNeq();
    var gt = requireGt();
    var gte = requireGte();
    var lt = requireLt();
    var lte = requireLte();
    var cmp = function(a, op, b, loose) {
        switch(op){
            case '===':
                if ((typeof a === "undefined" ? "undefined" : _type_of$c(a)) === 'object') {
                    a = a.version;
                }
                if ((typeof b === "undefined" ? "undefined" : _type_of$c(b)) === 'object') {
                    b = b.version;
                }
                return a === b;
            case '!==':
                if ((typeof a === "undefined" ? "undefined" : _type_of$c(a)) === 'object') {
                    a = a.version;
                }
                if ((typeof b === "undefined" ? "undefined" : _type_of$c(b)) === 'object') {
                    b = b.version;
                }
                return a !== b;
            case '':
            case '=':
            case '==':
                return eq(a, b, loose);
            case '!=':
                return neq(a, b, loose);
            case '>':
                return gt(a, b, loose);
            case '>=':
                return gte(a, b, loose);
            case '<':
                return lt(a, b, loose);
            case '<=':
                return lte(a, b, loose);
            default:
                throw new TypeError("Invalid operator: ".concat(op));
        }
    };
    cmp_1 = cmp;
    return cmp_1;
}

function _instanceof$5(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
    if (hasRequiredCoerce) return coerce_1;
    hasRequiredCoerce = 1;
    var SemVer = requireSemver$1();
    var parse = requireParse();
    var _require$$2 = requireRe(), re = _require$$2.safeRe, t = _require$$2.t;
    var coerce = function(version, options) {
        if (_instanceof$5(version, SemVer)) {
            return version;
        }
        if (typeof version === 'number') {
            version = String(version);
        }
        if (typeof version !== 'string') {
            return null;
        }
        options = options || {};
        var match = null;
        if (!options.rtl) {
            match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
        } else {
            // Find the right-most coercible string that does not share
            // a terminus with a more left-ward coercible string.
            // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
            // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
            //
            // Walk through the string checking with a /g regexp
            // Manually set the index so as to pick up overlapping matches.
            // Stop when we get a match that ends at the string end, since no
            // coercible string can be more right-ward without the same terminus.
            var coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
            var next;
            while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
                if (!match || next.index + next[0].length !== match.index + match[0].length) {
                    match = next;
                }
                coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
            }
            // leave it in a clean state
            coerceRtlRegex.lastIndex = -1;
        }
        if (match === null) {
            return null;
        }
        var major = match[2];
        var minor = match[3] || '0';
        var patch = match[4] || '0';
        var prerelease = options.includePrerelease && match[5] ? "-".concat(match[5]) : '';
        var build = options.includePrerelease && match[6] ? "+".concat(match[6]) : '';
        return parse("".concat(major, ".").concat(minor, ".").concat(patch).concat(prerelease).concat(build), options);
    };
    coerce_1 = coerce;
    return coerce_1;
}

function _class_call_check$f(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
    if (hasRequiredLrucache) return lrucache;
    hasRequiredLrucache = 1;
    var LRUCache = /*#__PURE__*/ function() {
        function LRUCache() {
            _class_call_check$f(this, LRUCache);
            this.max = 1000;
            this.map = new Map();
        }
        var _proto = LRUCache.prototype;
        _proto.get = function get(key) {
            var value = this.map.get(key);
            if (value === undefined) {
                return undefined;
            } else {
                // Remove the key from the map and add it to the end
                this.map.delete(key);
                this.map.set(key, value);
                return value;
            }
        };
        _proto.delete = function _delete(key) {
            return this.map.delete(key);
        };
        _proto.set = function set(key, value) {
            var deleted = this.delete(key);
            if (!deleted && value !== undefined) {
                // If cache is full, delete the least recently used item
                if (this.map.size >= this.max) {
                    var firstKey = this.map.keys().next().value;
                    this.delete(firstKey);
                }
                this.map.set(key, value);
            }
            return this;
        };
        return LRUCache;
    }();
    lrucache = LRUCache;
    return lrucache;
}

function _array_like_to_array$5(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$4(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$5(arr);
}
function _class_call_check$e(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$4(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$4(Constructor, protoProps, staticProps) {
    _defineProperties$4(Constructor.prototype, protoProps);
    return Constructor;
}
function _instanceof$4(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array$4(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$4() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array$4(arr) {
    return _array_without_holes$4(arr) || _iterable_to_array$4(arr) || _unsupported_iterable_to_array$5(arr) || _non_iterable_spread$4();
}
function _unsupported_iterable_to_array$5(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$5(o, minLen);
}
var range;
var hasRequiredRange;
function requireRange() {
    if (hasRequiredRange) return range;
    hasRequiredRange = 1;
    var SPACE_CHARACTERS = /\s+/g;
    // hoisted class for cyclic dependency
    var Range = /*#__PURE__*/ function() {
        function Range(range, options) {
            var _this = this;
            _class_call_check$e(this, Range);
            options = parseOptions(options);
            if (_instanceof$4(range, Range)) {
                if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                    return range;
                } else {
                    return new Range(range.raw, options);
                }
            }
            if (_instanceof$4(range, Comparator)) {
                // just put it in the set and return
                this.raw = range.value;
                this.set = [
                    [
                        range
                    ]
                ];
                this.formatted = undefined;
                return this;
            }
            this.options = options;
            this.loose = !!options.loose;
            this.includePrerelease = !!options.includePrerelease;
            // First reduce all whitespace as much as possible so we do not have to rely
            // on potentially slow regexes like \s*. This is then stored and used for
            // future error messages as well.
            this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
            // First, split on ||
            this.set = this.raw.split('||')// map the range to a 2d array of comparators
            .map(function(r) {
                return _this.parseRange(r.trim());
            })// throw out any comparator lists that are empty
            // this generally means that it was not a valid range, which is allowed
            // in loose mode, but will still throw if the WHOLE range is invalid.
            .filter(function(c) {
                return c.length;
            });
            if (!this.set.length) {
                throw new TypeError("Invalid SemVer Range: ".concat(this.raw));
            }
            // if we have any that are not the null set, throw out null sets.
            if (this.set.length > 1) {
                // keep the first one, in case they're all null sets
                var first = this.set[0];
                this.set = this.set.filter(function(c) {
                    return !isNullSet(c[0]);
                });
                if (this.set.length === 0) {
                    this.set = [
                        first
                    ];
                } else if (this.set.length > 1) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        // if we have any that are *, then the range is just *
                        for(var _iterator = this.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var c = _step.value;
                            if (c.length === 1 && isAny(c[0])) {
                                this.set = [
                                    c
                                ];
                                break;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            }
            this.formatted = undefined;
        }
        var _proto = Range.prototype;
        _proto.format = function format() {
            return this.range;
        };
        _proto.toString = function toString() {
            return this.range;
        };
        _proto.parseRange = function parseRange(range) {
            var _this = this;
            // memoize range parsing for performance.
            // this is a very hot path, and fully deterministic.
            var memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
            var memoKey = memoOpts + ':' + range;
            var cached = cache.get(memoKey);
            if (cached) {
                return cached;
            }
            var loose = this.options.loose;
            // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
            var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
            range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
            debug('hyphen replace', range);
            // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
            range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
            debug('comparator trim', range);
            // `~ 1.2.3` => `~1.2.3`
            range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
            debug('tilde trim', range);
            // `^ 1.2.3` => `^1.2.3`
            range = range.replace(re[t.CARETTRIM], caretTrimReplace);
            debug('caret trim', range);
            // At this point, the range is completely trimmed and
            // ready to be split into comparators.
            var rangeList = range.split(' ').map(function(comp) {
                return parseComparator(comp, _this.options);
            }).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
            .map(function(comp) {
                return replaceGTE0(comp, _this.options);
            });
            if (loose) {
                // in loose mode, throw out any that are not valid comparators
                rangeList = rangeList.filter(function(comp) {
                    debug('loose invalid filter', comp, _this.options);
                    return !!comp.match(re[t.COMPARATORLOOSE]);
                });
            }
            debug('range list', rangeList);
            // if any comparators are the null set, then replace with JUST null set
            // if more than one comparator, remove any * comparators
            // also, don't include the same comparator more than once
            var rangeMap = new Map();
            var comparators = rangeList.map(function(comp) {
                return new Comparator(comp, _this.options);
            });
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = comparators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var comp = _step.value;
                    if (isNullSet(comp)) {
                        return [
                            comp
                        ];
                    }
                    rangeMap.set(comp.value, comp);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (rangeMap.size > 1 && rangeMap.has('')) {
                rangeMap.delete('');
            }
            var result = _to_consumable_array$4(rangeMap.values());
            cache.set(memoKey, result);
            return result;
        };
        _proto.intersects = function intersects(range, options) {
            if (!_instanceof$4(range, Range)) {
                throw new TypeError('a Range is required');
            }
            return this.set.some(function(thisComparators) {
                return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
                    return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                        return rangeComparators.every(function(rangeComparator) {
                            return thisComparator.intersects(rangeComparator, options);
                        });
                    });
                });
            });
        };
        // if ANY of the sets match ALL of its comparators, then pass
        _proto.test = function test(version) {
            if (!version) {
                return false;
            }
            if (typeof version === 'string') {
                try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
            }
            for(var i = 0; i < this.set.length; i++){
                if (testSet(this.set[i], version, this.options)) {
                    return true;
                }
            }
            return false;
        };
        _create_class$4(Range, [
            {
                key: "range",
                get: function get() {
                    if (this.formatted === undefined) {
                        this.formatted = '';
                        for(var i = 0; i < this.set.length; i++){
                            if (i > 0) {
                                this.formatted += '||';
                            }
                            var comps = this.set[i];
                            for(var k = 0; k < comps.length; k++){
                                if (k > 0) {
                                    this.formatted += ' ';
                                }
                                this.formatted += comps[k].toString().trim();
                            }
                        }
                    }
                    return this.formatted;
                }
            }
        ]);
        return Range;
    }();
    range = Range;
    var LRU = requireLrucache();
    var cache = new LRU();
    var parseOptions = requireParseOptions();
    var Comparator = requireComparator();
    var debug = requireDebug();
    var SemVer = requireSemver$1();
    var _require$$5 = requireRe(), re = _require$$5.safeRe, t = _require$$5.t, comparatorTrimReplace = _require$$5.comparatorTrimReplace, tildeTrimReplace = _require$$5.tildeTrimReplace, caretTrimReplace = _require$$5.caretTrimReplace;
    var _require$$6 = requireConstants(), FLAG_INCLUDE_PRERELEASE = _require$$6.FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE = _require$$6.FLAG_LOOSE;
    var isNullSet = function(c) {
        return c.value === '<0.0.0-0';
    };
    var isAny = function(c) {
        return c.value === '';
    };
    // take a set of comparators and determine whether there
    // exists a version which can satisfy it
    var isSatisfiable = function(comparators, options) {
        var result = true;
        var remainingComparators = comparators.slice();
        var testComparator = remainingComparators.pop();
        while(result && remainingComparators.length){
            result = remainingComparators.every(function(otherComparator) {
                return testComparator.intersects(otherComparator, options);
            });
            testComparator = remainingComparators.pop();
        }
        return result;
    };
    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    var parseComparator = function(comp, options) {
        debug('comp', comp, options);
        comp = replaceCarets(comp, options);
        debug('caret', comp);
        comp = replaceTildes(comp, options);
        debug('tildes', comp);
        comp = replaceXRanges(comp, options);
        debug('xrange', comp);
        comp = replaceStars(comp, options);
        debug('stars', comp);
        return comp;
    };
    var isX = function(id) {
        return !id || id.toLowerCase() === 'x' || id === '*';
    };
    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    // ~0.0.1 --> >=0.0.1 <0.1.0-0
    var replaceTildes = function(comp, options) {
        return comp.trim().split(/\s+/).map(function(c) {
            return replaceTilde(c, options);
        }).join(' ');
    };
    var replaceTilde = function(comp, options) {
        var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, function(_, M, m, p, pr) {
            debug('tilde', comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
                ret = '';
            } else if (isX(m)) {
                ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
            } else if (isX(p)) {
                // ~1.2 == >=1.2.0 <1.3.0-0
                ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
            } else if (pr) {
                debug('replaceTilde pr', pr);
                ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
            } else {
                // ~1.2.3 == >=1.2.3 <1.3.0-0
                ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
            }
            debug('tilde return', ret);
            return ret;
        });
    };
    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    // ^1.2.3 --> >=1.2.3 <2.0.0-0
    // ^1.2.0 --> >=1.2.0 <2.0.0-0
    // ^0.0.1 --> >=0.0.1 <0.0.2-0
    // ^0.1.0 --> >=0.1.0 <0.2.0-0
    var replaceCarets = function(comp, options) {
        return comp.trim().split(/\s+/).map(function(c) {
            return replaceCaret(c, options);
        }).join(' ');
    };
    var replaceCaret = function(comp, options) {
        debug('caret', comp, options);
        var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        var z = options.includePrerelease ? '-0' : '';
        return comp.replace(r, function(_, M, m, p, pr) {
            debug('caret', comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
                ret = '';
            } else if (isX(m)) {
                ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
            } else if (isX(p)) {
                if (M === '0') {
                    ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
                } else {
                    ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
                }
            } else if (pr) {
                debug('replaceCaret pr', pr);
                if (M === '0') {
                    if (m === '0') {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
                    } else {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                } else {
                    ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
                }
            } else {
                debug('no pr');
                if (M === '0') {
                    if (m === '0') {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
                    } else {
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                } else {
                    ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
                }
            }
            debug('caret return', ret);
            return ret;
        });
    };
    var replaceXRanges = function(comp, options) {
        debug('replaceXRanges', comp, options);
        return comp.split(/\s+/).map(function(c) {
            return replaceXRange(c, options);
        }).join(' ');
    };
    var replaceXRange = function(comp, options) {
        comp = comp.trim();
        var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
            debug('xRange', comp, ret, gtlt, M, m, p, pr);
            var xM = isX(M);
            var xm = xM || isX(m);
            var xp = xm || isX(p);
            var anyX = xp;
            if (gtlt === '=' && anyX) {
                gtlt = '';
            }
            // if we're including prereleases in the match, then we need
            // to fix this to -0, the lowest possible prerelease value
            pr = options.includePrerelease ? '-0' : '';
            if (xM) {
                if (gtlt === '>' || gtlt === '<') {
                    // nothing is allowed
                    ret = '<0.0.0-0';
                } else {
                    // nothing is forbidden
                    ret = '*';
                }
            } else if (gtlt && anyX) {
                // we know patch is an x, because we have any x at all.
                // replace X with 0
                if (xm) {
                    m = 0;
                }
                p = 0;
                if (gtlt === '>') {
                    // >1 => >=2.0.0
                    // >1.2 => >=1.3.0
                    gtlt = '>=';
                    if (xm) {
                        M = +M + 1;
                        m = 0;
                        p = 0;
                    } else {
                        m = +m + 1;
                        p = 0;
                    }
                } else if (gtlt === '<=') {
                    // <=0.7.x is actually <0.8.0, since any 0.7.x should
                    // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                    gtlt = '<';
                    if (xm) {
                        M = +M + 1;
                    } else {
                        m = +m + 1;
                    }
                }
                if (gtlt === '<') {
                    pr = '-0';
                }
                ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
            } else if (xm) {
                ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
            } else if (xp) {
                ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
            }
            debug('xRange return', ret);
            return ret;
        });
    };
    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    var replaceStars = function(comp, options) {
        debug('replaceStars', comp, options);
        // Looseness is ignored here.  star is always as loose as it gets!
        return comp.trim().replace(re[t.STAR], '');
    };
    var replaceGTE0 = function(comp, options) {
        debug('replaceGTE0', comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
    };
    // This function is passed to string.replace(re[t.HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0-0
    // TODO build?
    var hyphenReplace = function(incPr) {
        return function($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) {
            if (isX(fM)) {
                from = '';
            } else if (isX(fm)) {
                from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
            } else if (isX(fp)) {
                from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
            } else if (fpr) {
                from = ">=".concat(from);
            } else {
                from = ">=".concat(from).concat(incPr ? '-0' : '');
            }
            if (isX(tM)) {
                to = '';
            } else if (isX(tm)) {
                to = "<".concat(+tM + 1, ".0.0-0");
            } else if (isX(tp)) {
                to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
            } else if (tpr) {
                to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
            } else if (incPr) {
                to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
            } else {
                to = "<=".concat(to);
            }
            return "".concat(from, " ").concat(to).trim();
        };
    };
    var testSet = function(set, version, options) {
        for(var i = 0; i < set.length; i++){
            if (!set[i].test(version)) {
                return false;
            }
        }
        if (version.prerelease.length && !options.includePrerelease) {
            // Find the set of versions that are allowed to have prereleases
            // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
            // That should allow `1.2.3-pr.2` to pass.
            // However, `1.2.4-alpha.notready` should NOT be allowed,
            // even though it's within the range set by the comparators.
            for(var i1 = 0; i1 < set.length; i1++){
                debug(set[i1].semver);
                if (set[i1].semver === Comparator.ANY) {
                    continue;
                }
                if (set[i1].semver.prerelease.length > 0) {
                    var allowed = set[i1].semver;
                    if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                        return true;
                    }
                }
            }
            // Version has a -pre, but it's not one of the ones we like.
            return false;
        }
        return true;
    };
    return range;
}

function _class_call_check$d(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$3(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$3(Constructor, protoProps, staticProps) {
    _defineProperties$3(Constructor, staticProps);
    return Constructor;
}
function _instanceof$3(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
    if (hasRequiredComparator) return comparator;
    hasRequiredComparator = 1;
    var ANY = Symbol('SemVer ANY');
    // hoisted class for cyclic dependency
    var Comparator = /*#__PURE__*/ function() {
        function Comparator(comp, options) {
            _class_call_check$d(this, Comparator);
            options = parseOptions(options);
            if (_instanceof$3(comp, Comparator)) {
                if (comp.loose === !!options.loose) {
                    return comp;
                } else {
                    comp = comp.value;
                }
            }
            comp = comp.trim().split(/\s+/).join(' ');
            debug('comparator', comp, options);
            this.options = options;
            this.loose = !!options.loose;
            this.parse(comp);
            if (this.semver === ANY) {
                this.value = '';
            } else {
                this.value = this.operator + this.semver.version;
            }
            debug('comp', this);
        }
        var _proto = Comparator.prototype;
        _proto.parse = function parse(comp) {
            var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
            var m = comp.match(r);
            if (!m) {
                throw new TypeError("Invalid comparator: ".concat(comp));
            }
            this.operator = m[1] !== undefined ? m[1] : '';
            if (this.operator === '=') {
                this.operator = '';
            }
            // if it literally is just '>' or '' then allow anything.
            if (!m[2]) {
                this.semver = ANY;
            } else {
                this.semver = new SemVer(m[2], this.options.loose);
            }
        };
        _proto.toString = function toString() {
            return this.value;
        };
        _proto.test = function test(version) {
            debug('Comparator.test', version, this.options.loose);
            if (this.semver === ANY || version === ANY) {
                return true;
            }
            if (typeof version === 'string') {
                try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
            }
            return cmp(version, this.operator, this.semver, this.options);
        };
        _proto.intersects = function intersects(comp, options) {
            if (!_instanceof$3(comp, Comparator)) {
                throw new TypeError('a Comparator is required');
            }
            if (this.operator === '') {
                if (this.value === '') {
                    return true;
                }
                return new Range(comp.value, options).test(this.value);
            } else if (comp.operator === '') {
                if (comp.value === '') {
                    return true;
                }
                return new Range(this.value, options).test(comp.semver);
            }
            options = parseOptions(options);
            // Special cases where nothing can possibly be lower
            if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
                return false;
            }
            if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
                return false;
            }
            // Same direction increasing (> or >=)
            if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
                return true;
            }
            // Same direction decreasing (< or <=)
            if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
                return true;
            }
            // same SemVer and both sides are inclusive (<= or >=)
            if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
                return true;
            }
            // opposite directions less than
            if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
                return true;
            }
            // opposite directions greater than
            if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
                return true;
            }
            return false;
        };
        _create_class$3(Comparator, null, [
            {
                key: "ANY",
                get: function get() {
                    return ANY;
                }
            }
        ]);
        return Comparator;
    }();
    comparator = Comparator;
    var parseOptions = requireParseOptions();
    var _require$$1 = requireRe(), re = _require$$1.safeRe, t = _require$$1.t;
    var cmp = requireCmp();
    var debug = requireDebug();
    var SemVer = requireSemver$1();
    var Range = requireRange();
    return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
    if (hasRequiredSatisfies) return satisfies_1;
    hasRequiredSatisfies = 1;
    var Range = requireRange();
    var satisfies = function(version, range, options) {
        try {
            range = new Range(range, options);
        } catch (er) {
            return false;
        }
        return range.test(version);
    };
    satisfies_1 = satisfies;
    return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;
function requireToComparators() {
    if (hasRequiredToComparators) return toComparators_1;
    hasRequiredToComparators = 1;
    var Range = requireRange();
    // Mostly just for testing and legacy API reasons
    var toComparators = function(range, options) {
        return new Range(range, options).set.map(function(comp) {
            return comp.map(function(c) {
                return c.value;
            }).join(' ').trim().split(' ');
        });
    };
    toComparators_1 = toComparators;
    return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;
function requireMaxSatisfying() {
    if (hasRequiredMaxSatisfying) return maxSatisfying_1;
    hasRequiredMaxSatisfying = 1;
    var SemVer = requireSemver$1();
    var Range = requireRange();
    var maxSatisfying = function(versions, range, options) {
        var max = null;
        var maxSV = null;
        var rangeObj = null;
        try {
            rangeObj = new Range(range, options);
        } catch (er) {
            return null;
        }
        versions.forEach(function(v) {
            if (rangeObj.test(v)) {
                // satisfies(v, range, options)
                if (!max || maxSV.compare(v) === -1) {
                    // compare(max, v, true)
                    max = v;
                    maxSV = new SemVer(max, options);
                }
            }
        });
        return max;
    };
    maxSatisfying_1 = maxSatisfying;
    return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;
function requireMinSatisfying() {
    if (hasRequiredMinSatisfying) return minSatisfying_1;
    hasRequiredMinSatisfying = 1;
    var SemVer = requireSemver$1();
    var Range = requireRange();
    var minSatisfying = function(versions, range, options) {
        var min = null;
        var minSV = null;
        var rangeObj = null;
        try {
            rangeObj = new Range(range, options);
        } catch (er) {
            return null;
        }
        versions.forEach(function(v) {
            if (rangeObj.test(v)) {
                // satisfies(v, range, options)
                if (!min || minSV.compare(v) === 1) {
                    // compare(min, v, true)
                    min = v;
                    minSV = new SemVer(min, options);
                }
            }
        });
        return min;
    };
    minSatisfying_1 = minSatisfying;
    return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;
function requireMinVersion() {
    if (hasRequiredMinVersion) return minVersion_1;
    hasRequiredMinVersion = 1;
    var SemVer = requireSemver$1();
    var Range = requireRange();
    var gt = requireGt();
    var minVersion = function(range, loose) {
        var _loop = function(i) {
            var comparators = range.set[i];
            var setMin = null;
            comparators.forEach(function(comparator) {
                // Clone to avoid manipulating the comparator's semver object.
                var compver = new SemVer(comparator.semver.version);
                switch(comparator.operator){
                    case '>':
                        if (compver.prerelease.length === 0) {
                            compver.patch++;
                        } else {
                            compver.prerelease.push(0);
                        }
                        compver.raw = compver.format();
                    /* fallthrough */ case '':
                    case '>=':
                        if (!setMin || gt(compver, setMin)) {
                            setMin = compver;
                        }
                        break;
                    case '<':
                    case '<=':
                        break;
                    /* istanbul ignore next */ default:
                        throw new Error("Unexpected operation: ".concat(comparator.operator));
                }
            });
            if (setMin && (!minver || gt(minver, setMin))) {
                minver = setMin;
            }
        };
        range = new Range(range, loose);
        var minver = new SemVer('0.0.0');
        if (range.test(minver)) {
            return minver;
        }
        minver = new SemVer('0.0.0-0');
        if (range.test(minver)) {
            return minver;
        }
        minver = null;
        for(var i = 0; i < range.set.length; ++i)_loop(i);
        if (minver && range.test(minver)) {
            return minver;
        }
        return null;
    };
    minVersion_1 = minVersion;
    return minVersion_1;
}

var valid;
var hasRequiredValid;
function requireValid() {
    if (hasRequiredValid) return valid;
    hasRequiredValid = 1;
    var Range = requireRange();
    var validRange = function(range, options) {
        try {
            // Return '*' instead of '' so that truthiness works.
            // This will throw if it's invalid anyway
            return new Range(range, options).range || '*';
        } catch (er) {
            return null;
        }
    };
    valid = validRange;
    return valid;
}

function _type_of$b(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var outside_1;
var hasRequiredOutside;
function requireOutside() {
    if (hasRequiredOutside) return outside_1;
    hasRequiredOutside = 1;
    var SemVer = requireSemver$1();
    var Comparator = requireComparator();
    var ANY = Comparator.ANY;
    var Range = requireRange();
    var satisfies = requireSatisfies();
    var gt = requireGt();
    var lt = requireLt();
    var lte = requireLte();
    var gte = requireGte();
    var outside = function(version, range, hilo, options) {
        var _loop = function(i) {
            var comparators = range.set[i];
            var high = null;
            var low = null;
            comparators.forEach(function(comparator) {
                if (comparator.semver === ANY) {
                    comparator = new Comparator('>=0.0.0');
                }
                high = high || comparator;
                low = low || comparator;
                if (gtfn(comparator.semver, high.semver, options)) {
                    high = comparator;
                } else if (ltfn(comparator.semver, low.semver, options)) {
                    low = comparator;
                }
            });
            // If the edge version comparator has a operator then our version
            // isn't outside it
            if (high.operator === comp || high.operator === ecomp) {
                return {
                    v: false
                };
            }
            // If the lowest version comparator has an operator and our version
            // is less than it then it isn't higher than the range
            if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
                return {
                    v: false
                };
            } else if (low.operator === ecomp && ltfn(version, low.semver)) {
                return {
                    v: false
                };
            }
        };
        version = new SemVer(version, options);
        range = new Range(range, options);
        var gtfn, ltefn, ltfn, comp, ecomp;
        switch(hilo){
            case '>':
                gtfn = gt;
                ltefn = lte;
                ltfn = lt;
                comp = '>';
                ecomp = '>=';
                break;
            case '<':
                gtfn = lt;
                ltefn = gte;
                ltfn = gt;
                comp = '<';
                ecomp = '<=';
                break;
            default:
                throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        // If it satisfies the range it is not outside
        if (satisfies(version, range, options)) {
            return false;
        }
        // From now on, variable terms are as if we're in "gtr" mode.
        // but note that everything is flipped for the "ltr" function.
        for(var i = 0; i < range.set.length; ++i){
            var _ret = _loop(i);
            if (_type_of$b(_ret) === "object") return _ret.v;
        }
        return true;
    };
    outside_1 = outside;
    return outside_1;
}

var gtr_1;
var hasRequiredGtr;
function requireGtr() {
    if (hasRequiredGtr) return gtr_1;
    hasRequiredGtr = 1;
    // Determine if version is greater than all the versions possible in the range.
    var outside = requireOutside();
    var gtr = function(version, range, options) {
        return outside(version, range, '>', options);
    };
    gtr_1 = gtr;
    return gtr_1;
}

var ltr_1;
var hasRequiredLtr;
function requireLtr() {
    if (hasRequiredLtr) return ltr_1;
    hasRequiredLtr = 1;
    var outside = requireOutside();
    // Determine if version is less than all the versions possible in the range
    var ltr = function(version, range, options) {
        return outside(version, range, '<', options);
    };
    ltr_1 = ltr;
    return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;
function requireIntersects() {
    if (hasRequiredIntersects) return intersects_1;
    hasRequiredIntersects = 1;
    var Range = requireRange();
    var intersects = function(r1, r2, options) {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2, options);
    };
    intersects_1 = intersects;
    return intersects_1;
}

function _array_like_to_array$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$1(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$1(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$1(arr, i) {
    return _array_with_holes$1(arr) || _iterable_to_array_limit$1(arr, i) || _unsupported_iterable_to_array$4(arr, i) || _non_iterable_rest$1();
}
function _unsupported_iterable_to_array$4(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$4(o, minLen);
}
var simplify;
var hasRequiredSimplify;
function requireSimplify() {
    if (hasRequiredSimplify) return simplify;
    hasRequiredSimplify = 1;
    // given a set of versions and a range, create a "simplified" range
    // that includes the same versions that the original range does
    // If the original range is shorter than the simplified one, return that.
    var satisfies = requireSatisfies();
    var compare = requireCompare();
    simplify = function(versions, range, options) {
        var set = [];
        var first = null;
        var prev = null;
        var v = versions.sort(function(a, b) {
            return compare(a, b, options);
        });
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = v[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var version = _step.value;
                var included = satisfies(version, range, options);
                if (included) {
                    prev = version;
                    if (!first) {
                        first = version;
                    }
                } else {
                    if (prev) {
                        set.push([
                            first,
                            prev
                        ]);
                    }
                    prev = null;
                    first = null;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (first) {
            set.push([
                first,
                null
            ]);
        }
        var ranges = [];
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = set[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var _step_value = _sliced_to_array$1(_step1.value, 2), min = _step_value[0], max = _step_value[1];
                if (min === max) {
                    ranges.push(min);
                } else if (!max && min === v[0]) {
                    ranges.push('*');
                } else if (!max) {
                    ranges.push(">=".concat(min));
                } else if (min === v[0]) {
                    ranges.push("<=".concat(max));
                } else {
                    ranges.push("".concat(min, " - ").concat(max));
                }
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        var simplified = ranges.join(' || ');
        var original = typeof range.raw === 'string' ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
    };
    return simplify;
}

var subset_1;
var hasRequiredSubset;
function requireSubset() {
    if (hasRequiredSubset) return subset_1;
    hasRequiredSubset = 1;
    var Range = requireRange();
    var Comparator = requireComparator();
    var ANY = Comparator.ANY;
    var satisfies = requireSatisfies();
    var compare = requireCompare();
    // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
    // - Every simple range `r1, r2, ...` is a null set, OR
    // - Every simple range `r1, r2, ...` which is not a null set is a subset of
    //   some `R1, R2, ...`
    //
    // Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
    // - If c is only the ANY comparator
    //   - If C is only the ANY comparator, return true
    //   - Else if in prerelease mode, return false
    //   - else replace c with `[>=0.0.0]`
    // - If C is only the ANY comparator
    //   - if in prerelease mode, return true
    //   - else replace C with `[>=0.0.0]`
    // - Let EQ be the set of = comparators in c
    // - If EQ is more than one, return true (null set)
    // - Let GT be the highest > or >= comparator in c
    // - Let LT be the lowest < or <= comparator in c
    // - If GT and LT, and GT.semver > LT.semver, return true (null set)
    // - If any C is a = range, and GT or LT are set, return false
    // - If EQ
    //   - If GT, and EQ does not satisfy GT, return true (null set)
    //   - If LT, and EQ does not satisfy LT, return true (null set)
    //   - If EQ satisfies every C, return true
    //   - Else return false
    // - If GT
    //   - If GT.semver is lower than any > or >= comp in C, return false
    //   - If GT is >=, and GT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the GT.semver tuple, return false
    // - If LT
    //   - If LT.semver is greater than any < or <= comp in C, return false
    //   - If LT is <=, and LT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the LT.semver tuple, return false
    // - Else return true
    var subset = function(sub, dom) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (sub === dom) {
            return true;
        }
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        var sawNonNull = false;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            OUTER: for(var _iterator = sub.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var simpleSub = _step.value;
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = dom.set[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var simpleDom = _step1.value;
                        var isSub = simpleSubset(simpleSub, simpleDom, options);
                        sawNonNull = sawNonNull || isSub !== null;
                        if (isSub) {
                            continue OUTER;
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                // the null set is a subset of everything, but null simple ranges in
                // a complex range should be ignored.  so if we saw a non-null range,
                // then we know this isn't a subset, but if EVERY simple range was null,
                // then it is a subset.
                if (sawNonNull) {
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return true;
    };
    var minimumVersionWithPreRelease = [
        new Comparator('>=0.0.0-0')
    ];
    var minimumVersion = [
        new Comparator('>=0.0.0')
    ];
    var simpleSubset = function(sub, dom, options) {
        if (sub === dom) {
            return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
            if (dom.length === 1 && dom[0].semver === ANY) {
                return true;
            } else if (options.includePrerelease) {
                sub = minimumVersionWithPreRelease;
            } else {
                sub = minimumVersion;
            }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
            if (options.includePrerelease) {
                return true;
            } else {
                dom = minimumVersion;
            }
        }
        var eqSet = new Set();
        var gt, lt;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = sub[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var c = _step.value;
                if (c.operator === '>' || c.operator === '>=') {
                    gt = higherGT(gt, c, options);
                } else if (c.operator === '<' || c.operator === '<=') {
                    lt = lowerLT(lt, c, options);
                } else {
                    eqSet.add(c.semver);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (eqSet.size > 1) {
            return null;
        }
        var gtltComp;
        if (gt && lt) {
            gtltComp = compare(gt.semver, lt.semver, options);
            if (gtltComp > 0) {
                return null;
            } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
                return null;
            }
        }
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            // will iterate one or zero times
            for(var _iterator1 = eqSet[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var eq = _step1.value;
                if (gt && !satisfies(eq, String(gt), options)) {
                    return null;
                }
                if (lt && !satisfies(eq, String(lt), options)) {
                    return null;
                }
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                try {
                    for(var _iterator2 = dom[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                        var c1 = _step2.value;
                        if (!satisfies(eq, String(c1), options)) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                            _iterator2.return();
                        }
                    } finally{
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
                return true;
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        var higher, lower;
        var hasDomLT, hasDomGT;
        // if the subset has a prerelease, we need a comparator in the superset
        // with the same tuple and a prerelease, or it's not a subset
        var needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        var needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        // exception: <1.2.3-0 is the same as <1.2.3
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
            needDomLTPre = false;
        }
        var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
        try {
            for(var _iterator3 = dom[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                var c2 = _step3.value;
                hasDomGT = hasDomGT || c2.operator === '>' || c2.operator === '>=';
                hasDomLT = hasDomLT || c2.operator === '<' || c2.operator === '<=';
                if (gt) {
                    if (needDomGTPre) {
                        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
                            needDomGTPre = false;
                        }
                    }
                    if (c2.operator === '>' || c2.operator === '>=') {
                        higher = higherGT(gt, c2, options);
                        if (higher === c2 && higher !== gt) {
                            return false;
                        }
                    } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c2), options)) {
                        return false;
                    }
                }
                if (lt) {
                    if (needDomLTPre) {
                        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
                            needDomLTPre = false;
                        }
                    }
                    if (c2.operator === '<' || c2.operator === '<=') {
                        lower = lowerLT(lt, c2, options);
                        if (lower === c2 && lower !== lt) {
                            return false;
                        }
                    } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c2), options)) {
                        return false;
                    }
                }
                if (!c2.operator && (lt || gt) && gtltComp !== 0) {
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                    _iterator3.return();
                }
            } finally{
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }
        // if there was a < or >, and nothing in the dom, then must be false
        // UNLESS it was limited by another range in the other direction.
        // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
            return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
            return false;
        }
        // we needed a prerelease range in a specific tuple, but didn't get one
        // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
        // because it includes prereleases in the 1.2.3 tuple
        if (needDomGTPre || needDomLTPre) {
            return false;
        }
        return true;
    };
    // >=1.2.3 is lower than >1.2.3
    var higherGT = function(a, b, options) {
        if (!a) {
            return b;
        }
        var comp = compare(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
    };
    // <=1.2.3 is higher than <1.2.3
    var lowerLT = function(a, b, options) {
        if (!a) {
            return b;
        }
        var comp = compare(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
    };
    subset_1 = subset;
    return subset_1;
}

var semver$1;
var hasRequiredSemver;
function requireSemver() {
    if (hasRequiredSemver) return semver$1;
    hasRequiredSemver = 1;
    // just pre-load all the stuff that index.js lazily exports
    var internalRe = requireRe();
    var constants = requireConstants();
    var SemVer = requireSemver$1();
    var identifiers = requireIdentifiers();
    var parse = requireParse();
    var valid = requireValid$1();
    var clean = requireClean();
    var inc = requireInc();
    var diff = requireDiff();
    var major = requireMajor();
    var minor = requireMinor();
    var patch = requirePatch();
    var prerelease = requirePrerelease();
    var compare = requireCompare();
    var rcompare = requireRcompare();
    var compareLoose = requireCompareLoose();
    var compareBuild = requireCompareBuild();
    var sort = requireSort();
    var rsort = requireRsort();
    var gt = requireGt();
    var lt = requireLt();
    var eq = requireEq();
    var neq = requireNeq();
    var gte = requireGte();
    var lte = requireLte();
    var cmp = requireCmp();
    var coerce = requireCoerce();
    var Comparator = requireComparator();
    var Range = requireRange();
    var satisfies = requireSatisfies();
    var toComparators = requireToComparators();
    var maxSatisfying = requireMaxSatisfying();
    var minSatisfying = requireMinSatisfying();
    var minVersion = requireMinVersion();
    var validRange = requireValid();
    var outside = requireOutside();
    var gtr = requireGtr();
    var ltr = requireLtr();
    var intersects = requireIntersects();
    var simplifyRange = requireSimplify();
    var subset = requireSubset();
    semver$1 = {
        parse: parse,
        valid: valid,
        clean: clean,
        inc: inc,
        diff: diff,
        major: major,
        minor: minor,
        patch: patch,
        prerelease: prerelease,
        compare: compare,
        rcompare: rcompare,
        compareLoose: compareLoose,
        compareBuild: compareBuild,
        sort: sort,
        rsort: rsort,
        gt: gt,
        lt: lt,
        eq: eq,
        neq: neq,
        gte: gte,
        lte: lte,
        cmp: cmp,
        coerce: coerce,
        Comparator: Comparator,
        Range: Range,
        satisfies: satisfies,
        toComparators: toComparators,
        maxSatisfying: maxSatisfying,
        minSatisfying: minSatisfying,
        minVersion: minVersion,
        validRange: validRange,
        outside: outside,
        gtr: gtr,
        ltr: ltr,
        intersects: intersects,
        simplifyRange: simplifyRange,
        subset: subset,
        SemVer: SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: constants.RELEASE_TYPES,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
    return semver$1;
}

var semverExports = requireSemver();
var semver = /*@__PURE__*/ getDefaultExportFromCjs(semverExports);

function prereleaseIdFromVersion(version) {
    return (semver.prerelease(version) || []).shift();
}

function _class_call_check$c(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$2(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$2(Constructor, protoProps, staticProps) {
    _defineProperties$2(Constructor.prototype, protoProps);
    return Constructor;
}
var PKG = Symbol('pkg');
var PackageGraphNode = /*#__PURE__*/ function() {
    function PackageGraphNode(pkg) {
        _class_call_check$c(this, PackageGraphNode);
        var _pkg_name;
        this.name = (_pkg_name = pkg === null || pkg === undefined ? undefined : pkg.name) !== null && _pkg_name !== undefined ? _pkg_name : '';
        this[PKG] = pkg;
        Object.defineProperty(this, PKG, {
            enumerable: false
        });
        this.externalDependencies = new Map();
        this.localDependencies = new Map();
        this.localDependents = new Map();
    }
    var _proto = PackageGraphNode.prototype;
    _proto.satisfies = function satisfies(param) {
        var gitCommittish = param.gitCommittish, gitRange = param.gitRange, fetchSpec = param.fetchSpec;
        return semver.satisfies(this.version, gitCommittish || gitRange || fetchSpec);
    };
    _proto.toString = function toString() {
        return this.name;
    };
    _create_class$2(PackageGraphNode, [
        {
            key: "location",
            get: function get() {
                return this[PKG].location;
            }
        },
        {
            key: "pkg",
            get: function get() {
                return this[PKG];
            }
        },
        {
            key: "prereleaseId",
            get: function get() {
                return prereleaseIdFromVersion(this.version);
            }
        },
        {
            key: "version",
            get: function get() {
                return this[PKG].version;
            }
        }
    ]);
    return PackageGraphNode;
} 
();

var consoleControlStrings = {};

var hasRequiredConsoleControlStrings;
function requireConsoleControlStrings() {
    if (hasRequiredConsoleControlStrings) return consoleControlStrings;
    hasRequiredConsoleControlStrings = 1;
    // These tables borrowed from `ansi`
    var prefix = '\x1b[';
    consoleControlStrings.up = function up(num) {
        return prefix + (num || '') + 'A';
    };
    consoleControlStrings.down = function down(num) {
        return prefix + (num || '') + 'B';
    };
    consoleControlStrings.forward = function forward(num) {
        return prefix + (num || '') + 'C';
    };
    consoleControlStrings.back = function back(num) {
        return prefix + (num || '') + 'D';
    };
    consoleControlStrings.nextLine = function nextLine(num) {
        return prefix + (num || '') + 'E';
    };
    consoleControlStrings.previousLine = function previousLine(num) {
        return prefix + (num || '') + 'F';
    };
    consoleControlStrings.horizontalAbsolute = function horizontalAbsolute(num) {
        if (num == null) throw new Error('horizontalAboslute requires a column to position to');
        return prefix + num + 'G';
    };
    consoleControlStrings.eraseData = function eraseData() {
        return prefix + 'J';
    };
    consoleControlStrings.eraseLine = function eraseLine() {
        return prefix + 'K';
    };
    consoleControlStrings.goto = function(x, y) {
        return prefix + y + ';' + x + 'H';
    };
    consoleControlStrings.gotoSOL = function() {
        return '\r';
    };
    consoleControlStrings.beep = function() {
        return '\x07';
    };
    consoleControlStrings.hideCursor = function hideCursor() {
        return prefix + '?25l';
    };
    consoleControlStrings.showCursor = function showCursor() {
        return prefix + '?25h';
    };
    var colors = {
        reset: 0,
        // styles
        bold: 1,
        italic: 3,
        underline: 4,
        inverse: 7,
        // resets
        stopBold: 22,
        stopItalic: 23,
        stopUnderline: 24,
        stopInverse: 27,
        // colors
        white: 37,
        black: 30,
        blue: 34,
        cyan: 36,
        green: 32,
        magenta: 35,
        red: 31,
        yellow: 33,
        bgWhite: 47,
        bgBlack: 40,
        bgBlue: 44,
        bgCyan: 46,
        bgGreen: 42,
        bgMagenta: 45,
        bgRed: 41,
        bgYellow: 43,
        grey: 90,
        brightBlack: 90,
        brightRed: 91,
        brightGreen: 92,
        brightYellow: 93,
        brightBlue: 94,
        brightMagenta: 95,
        brightCyan: 96,
        brightWhite: 97,
        bgGrey: 100,
        bgBrightBlack: 100,
        bgBrightRed: 101,
        bgBrightGreen: 102,
        bgBrightYellow: 103,
        bgBrightBlue: 104,
        bgBrightMagenta: 105,
        bgBrightCyan: 106,
        bgBrightWhite: 107
    };
    consoleControlStrings.color = function color(colorWith) {
        if (arguments.length !== 1 || !Array.isArray(colorWith)) {
            colorWith = Array.prototype.slice.call(arguments);
        }
        return prefix + colorWith.map(colorNameToCode).join(';') + 'm';
    };
    function colorNameToCode(color) {
        if (colors[color] != null) return colors[color];
        throw new Error('Unknown color or style name: ' + color);
    }
    return consoleControlStrings;
}

var consoleControlStringsExports = requireConsoleControlStrings();
var consoleControl = /*@__PURE__*/ getDefaultExportFromCjs(consoleControlStringsExports);

var setBlocking$1;
var hasRequiredSetBlocking;
function requireSetBlocking() {
    if (hasRequiredSetBlocking) return setBlocking$1;
    hasRequiredSetBlocking = 1;
    setBlocking$1 = function setBlocking(blocking) {
        [
            process.stdout,
            process.stderr
        ].forEach(function(stream) {
            if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
                stream._handle.setBlocking(blocking);
            }
        });
    };
    return setBlocking$1;
}

var setBlockingExports = requireSetBlocking();
var setBlocking = /*@__PURE__*/ getDefaultExportFromCjs(setBlockingExports);

function _assert_this_initialized$7(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$7(_this, derived, args) {
    derived = _get_prototype_of$7(derived);
    return _possible_constructor_return$7(_this, _is_native_reflect_construct$7() ? Reflect.construct(derived, [], _get_prototype_of$7(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$b(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$7(o) {
    _get_prototype_of$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$7(o);
}
function _inherits$7(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$7(subClass, superClass);
}
function _possible_constructor_return$7(self, call) {
    if (call && (_type_of$a(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$7(self);
}
function _set_prototype_of$7(o, p) {
    _set_prototype_of$7 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$7(o, p);
}
function _type_of$a(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$7() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$7 = function() {
        return !!result;
    })();
}
var trackerId = 0;
var TrackerBase = /*#__PURE__*/ function(EventEmitter) {
    _inherits$7(TrackerBase, EventEmitter);
    function TrackerBase() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        _class_call_check$b(this, TrackerBase);
        var _this;
        _this = _call_super$7(this, TrackerBase);
        _this.id = ++trackerId;
        _this.name = name;
        return _this;
    }
    return TrackerBase;
} 
(EventEmitter$1);

function _assert_this_initialized$6(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$6(_this, derived, args) {
    derived = _get_prototype_of$6(derived);
    return _possible_constructor_return$6(_this, _is_native_reflect_construct$6() ? Reflect.construct(derived, args, _get_prototype_of$6(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$a(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$6(o) {
    _get_prototype_of$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$6(o);
}
function _inherits$6(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    _set_prototype_of$6(subClass, superClass);
}
function _possible_constructor_return$6(self, call) {
    if (call && (_type_of$9(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$6(self);
}
function _set_prototype_of$6(o, p) {
    _set_prototype_of$6 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$6(o, p);
}
function _type_of$9(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$6() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$6 = function() {
        return !!result;
    })();
}
var Tracker = /*#__PURE__*/ function(TrackerBase) {
    _inherits$6(Tracker, TrackerBase);
    function Tracker(name, todo) {
        _class_call_check$a(this, Tracker);
        var _this;
        _this = _call_super$6(this, Tracker, [
            name
        ]);
        _this.workDone = 0;
        _this.workTodo = todo || 0;
        return _this;
    }
    var _proto = Tracker.prototype;
    _proto.completed = function completed() {
        return this.workTodo === 0 ? 0 : this.workDone / this.workTodo;
    };
    _proto.addWork = function addWork(work) {
        this.workTodo += work;
        this.emit('change', this.name, this.completed(), this);
    };
    _proto.completeWork = function completeWork(work) {
        this.workDone += work;
        if (this.workDone > this.workTodo) {
            this.workDone = this.workTodo;
        }
        this.emit('change', this.name, this.completed(), this);
    };
    _proto.finish = function finish() {
        this.workTodo = this.workDone = 1;
        this.emit('change', this.name, 1, this);
    };
    return Tracker;
} 
(TrackerBase);

function _assert_this_initialized$5(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$5(_this, derived, args) {
    derived = _get_prototype_of$5(derived);
    return _possible_constructor_return$5(_this, _is_native_reflect_construct$5() ? Reflect.construct(derived, args, _get_prototype_of$5(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$5(o) {
    _get_prototype_of$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$5(o);
}
function _inherits$5(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$5(subClass, superClass);
}
function _possible_constructor_return$5(self, call) {
    if (call && (_type_of$8(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$5(self);
}
function _set_prototype_of$5(o, p) {
    _set_prototype_of$5 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$5(o, p);
}
function _type_of$8(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$5() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$5 = function() {
        return !!result;
    })();
}
var TrackerStream = /*#__PURE__*/ function(_stream_Transform) {
    _inherits$5(TrackerStream, _stream_Transform);
    function TrackerStream(name) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0, options = arguments.length > 2 ? arguments[2] : undefined;
        _class_call_check$9(this, TrackerStream);
        var _this;
        _this = _call_super$5(this, TrackerStream, [
            options
        ]);
        _this.tracker = new Tracker(name, size);
        _this.name = name;
        _this.id = _this.tracker.id;
        _this.tracker.on('change', _this.trackerChange.bind(_this));
        return _this;
    }
    var _proto = TrackerStream.prototype;
    _proto.trackerChange = function trackerChange(name, completion) {
        this.emit('change', name, completion, this);
    };
    _proto._transform = function _transform(data, encoding, cb) {
        this.tracker.completeWork(data.length ? data.length : 1);
        this.push(data);
        cb();
    };
    _proto._flush = function _flush(cb) {
        this.tracker.finish();
        cb();
    };
    _proto.completed = function completed() {
        return this.tracker.completed();
    };
    _proto.addWork = function addWork(work) {
        return this.tracker.addWork(work);
    };
    _proto.finish = function finish() {
        return this.tracker.finish();
    };
    return TrackerStream;
} 
(stream.Transform);

function _assert_this_initialized$4(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$4(_this, derived, args) {
    derived = _get_prototype_of$4(derived);
    return _possible_constructor_return$4(_this, _is_native_reflect_construct$4() ? Reflect.construct(derived, args || [], _get_prototype_of$4(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _get_prototype_of$4(o) {
    _get_prototype_of$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$4(o);
}
function _inherits$4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    _set_prototype_of$4(subClass, superClass);
}
function _instanceof$2(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _possible_constructor_return$4(self, call) {
    if (call && (_type_of$7(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$4(self);
}
function _set_prototype_of$4(o, p) {
    _set_prototype_of$4 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$4(o, p);
}
function _type_of$7(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$4() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$4 = function() {
        return !!result;
    })();
}
var TrackerGroup = /*#__PURE__*/ function(TrackerBase) {
    _inherits$4(TrackerGroup, TrackerBase);
    function TrackerGroup() {
        _class_call_check$8(this, TrackerGroup);
        var _this;
        _this = _call_super$4(this, TrackerGroup, arguments);
        _this.parentGroup = null;
        _this.trackers = [];
        _this.completion = {};
        _this.weight = {};
        _this.totalWeight = 0;
        _this.finished = false;
        _this.bubbleChange = bubbleChange(_this);
        return _this;
    }
    var _proto = TrackerGroup.prototype;
    _proto.nameInTree = function nameInTree() {
        var names = [];
        var from = this;
        while(from){
            names.unshift(from.name);
            from = from.parentGroup;
        }
        return names.join('/');
    };
    _proto.addUnit = function addUnit(unit) {
        var weight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        if (unit.addUnit) {
            var toTest = this;
            while(toTest){
                if (unit === toTest) {
                    throw new Error('Attempted to add tracker group ' + unit.name + ' to tree that already includes it ' + this.nameInTree());
                }
                toTest = toTest.parentGroup;
            }
            unit.parentGroup = this;
        }
        this.weight[unit.id] = weight || 1;
        this.totalWeight += this.weight[unit.id];
        this.trackers.push(unit);
        this.completion[unit.id] = unit.completed();
        unit.on('change', this.bubbleChange);
        if (!this.finished) {
            this.emit('change', unit.name, this.completion[unit.id], unit);
        }
        return unit;
    };
    _proto.completed = function completed() {
        if (this.trackers.length === 0) {
            return 0;
        }
        var valPerWeight = 1 / this.totalWeight;
        var completed = 0;
        for(var ii = 0; ii < this.trackers.length; ii++){
            var trackerId = this.trackers[ii].id;
            completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId];
        }
        return completed;
    };
    _proto.newGroup = function newGroup(name) {
        var weight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.addUnit(new TrackerGroup(name), weight);
    };
    _proto.newItem = function newItem(name, todo) {
        var weight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.addUnit(new Tracker(name, todo), weight);
    };
    _proto.newStream = function newStream(name, todo) {
        var weight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.addUnit(new TrackerStream(name, todo), weight);
    };
    _proto.finish = function finish() {
        this.finished = true;
        if (!this.trackers.length) {
            this.addUnit(new Tracker(), 1);
        }
        for(var ii = 0; ii < this.trackers.length; ii++){
            var tracker = this.trackers[ii];
            tracker.finish();
            tracker.removeListener('change', this.bubbleChange);
        }
        this.emit('change', this.name, 1, this);
    };
    _proto.debug = function debug() {
        var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var indent = ' '.repeat(depth);
        var output = "".concat(indent).concat(this.name || 'top', ": ").concat(this.completed(), "\n");
        this.trackers.forEach(function(tracker) {
            output += _instanceof$2(tracker, TrackerGroup) ? tracker.debug(depth + 1) : "".concat(indent, " ").concat(tracker.name, ": ").concat(tracker.completed(), "\n");
        });
        return output;
    };
    return TrackerGroup;
}(TrackerBase);
function bubbleChange(trackerGroup) {
    return function(name, completed, tracker) {
        trackerGroup.completion[tracker.id] = completed;
        if (trackerGroup.finished) {
            return;
        }
        trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup);
    };
}

var hasUnicode$1 = {
    exports: {}
};

var hasRequiredHasUnicode;
function requireHasUnicode() {
    if (hasRequiredHasUnicode) return hasUnicode$1.exports;
    hasRequiredHasUnicode = 1;
    var os = require$$5;
    hasUnicode$1.exports = function hasUnicode() {
        // Recent Win32 platforms (>XP) CAN support unicode in the console but
        // don't have to, and in non-english locales often use traditional local
        // code pages. There's no way, short of windows system calls or execing
        // the chcp command line program to figure this out. As such, we default
        // this to false and encourage your users to override it via config if
        // appropriate.
        if (os.type() == "Windows_NT") {
            return false;
        }
        var isUTF8 = /UTF-?8$/i;
        var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG;
        return isUTF8.test(ctype);
    };
    return hasUnicode$1.exports;
}

var hasUnicodeExports = requireHasUnicode();
var hasUnicode = /*@__PURE__*/ getDefaultExportFromCjs(hasUnicodeExports);

/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */ var signals = [];
signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if (process.platform !== 'win32') {
    signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
}
if (process.platform === 'linux') {
    signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
}

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
function _array_like_to_array$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$3(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$3(arr);
}
function _assert_this_initialized$3(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$3(_this, derived, args) {
    derived = _get_prototype_of$3(derived);
    return _possible_constructor_return$3(_this, _is_native_reflect_construct$3() ? Reflect.construct(derived, args || [], _get_prototype_of$3(_this).constructor) : derived.apply(_this, args));
}
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_call_check$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _get_prototype_of$3(o) {
    _get_prototype_of$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$3(o);
}
function _inherits$3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$3(subClass, superClass);
}
function _iterable_to_array$3(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$3() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$3(self, call) {
    if (call && (_type_of$6(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$3(self);
}
function _set_prototype_of$3(o, p) {
    _set_prototype_of$3 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$3(o, p);
}
function _to_consumable_array$3(arr) {
    return _array_without_holes$3(arr) || _iterable_to_array$3(arr) || _unsupported_iterable_to_array$3(arr) || _non_iterable_spread$3();
}
function _type_of$6(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$3(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$3(o, minLen);
}
function _is_native_reflect_construct$3() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$3 = function() {
        return !!result;
    })();
}
var processOk = function(process) {
    return !!process && (typeof process === "undefined" ? "undefined" : _type_of$6(process)) === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
};
var kExitEmitter = Symbol.for('signal-exit emitter');
var global$1 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
var Emitter = /*#__PURE__*/ function() {
    function Emitter() {
        _class_call_check$7(this, Emitter);
        this.emitted = {
            afterExit: false,
            exit: false
        };
        this.listeners = {
            afterExit: [],
            exit: []
        };
        this.count = 0;
        this.id = Math.random();
        if (global$1[kExitEmitter]) {
            return global$1[kExitEmitter];
        }
        ObjectDefineProperty(global$1, kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
    var _proto = Emitter.prototype;
    _proto.on = function on(ev, fn) {
        this.listeners[ev].push(fn);
    };
    _proto.removeListener = function removeListener(ev, fn) {
        var list = this.listeners[ev];
        var i = list.indexOf(fn);
        /* c8 ignore start */ if (i === -1) {
            return;
        }
        /* c8 ignore stop */ if (i === 0 && list.length === 1) {
            list.length = 0;
        } else {
            list.splice(i, 1);
        }
    };
    _proto.emit = function emit(ev, code, signal) {
        if (this.emitted[ev]) {
            return false;
        }
        this.emitted[ev] = true;
        var ret = false;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = this.listeners[ev][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var fn = _step.value;
                ret = fn(code, signal) === true || ret;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (ev === 'exit') {
            ret = this.emit('afterExit', code, signal) || ret;
        }
        return ret;
    };
    return Emitter;
}();
var SignalExitBase = function SignalExitBase() {
    _class_call_check$7(this, SignalExitBase);
};
var signalExitWrap = function(handler) {
    return {
        onExit: function onExit(cb, opts) {
            return handler.onExit(cb, opts);
        },
        load: function load() {
            return handler.load();
        },
        unload: function unload() {
            return handler.unload();
        }
    };
};
var SignalExitFallback = /*#__PURE__*/ function(SignalExitBase) {
    _inherits$3(SignalExitFallback, SignalExitBase);
    function SignalExitFallback() {
        _class_call_check$7(this, SignalExitFallback);
        return _call_super$3(this, SignalExitFallback, arguments);
    }
    var _proto = SignalExitFallback.prototype;
    _proto.onExit = function onExit() {
        return function() {};
    };
    _proto.load = function load() {};
    _proto.unload = function unload() {};
    return SignalExitFallback;
}(SignalExitBase);
var // "SIGHUP" throws an `ENOSYS` error on Windows,
// so use a supported signal instead
/* c8 ignore start */ _hupSig = /*#__PURE__*/ new WeakMap(), /* c8 ignore stop */ _emitter = /*#__PURE__*/ new WeakMap(), _process = /*#__PURE__*/ new WeakMap(), _originalProcessEmit = /*#__PURE__*/ new WeakMap(), _originalProcessReallyExit = /*#__PURE__*/ new WeakMap(), _sigListeners = /*#__PURE__*/ new WeakMap(), _loaded = /*#__PURE__*/ new WeakMap(), _processReallyExit = /*#__PURE__*/ new WeakSet(), _processEmit = /*#__PURE__*/ new WeakSet();
var SignalExit = /*#__PURE__*/ function(SignalExitBase) {
    _inherits$3(SignalExit, SignalExitBase);
    function SignalExit(process1) {
        _class_call_check$7(this, SignalExit);
        var _this;
        _this = _call_super$3(this, SignalExit), _class_private_method_init(_this, _processReallyExit), _class_private_method_init(_this, _processEmit), _class_private_field_init(_this, _hupSig, {
            writable: true,
            value: undefined
        }), _class_private_field_init(_this, _emitter, {
            writable: true,
            value: undefined
        }), _class_private_field_init(_this, _process, {
            writable: true,
            value: undefined
        }), _class_private_field_init(_this, _originalProcessEmit, {
            writable: true,
            value: undefined
        }), _class_private_field_init(_this, _originalProcessReallyExit, {
            writable: true,
            value: undefined
        }), _class_private_field_init(_this, _sigListeners, {
            writable: true,
            value: undefined
        }), _class_private_field_init(_this, _loaded, {
            writable: true,
            value: undefined
        }), _class_private_field_set(_this, _hupSig, process$1.platform === 'win32' ? 'SIGINT' : 'SIGHUP'), _class_private_field_set(_this, _emitter, new Emitter()), _class_private_field_set(_this, _sigListeners, {}), _class_private_field_set(_this, _loaded, false);
        _class_private_field_set(_this, _process, process1);
        // { <signal>: <listener fn>, ... }
        _class_private_field_set(_this, _sigListeners, {});
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function() {
                var sig = _step.value;
                _class_private_field_get(_this, _sigListeners)[sig] = function() {
                    // If there are no other listeners, an exit is coming!
                    // Simplest way: remove us and then re-send the signal.
                    // We know that this will kill the process, so we can
                    // safely emit now.
                    var listeners = _class_private_field_get(_this, _process).listeners(sig);
                    var count = _class_private_field_get(_this, _emitter).count;
                    // This is a workaround for the fact that signal-exit v3 and signal
                    // exit v4 are not aware of each other, and each will attempt to let
                    // the other handle it, so neither of them do. To correct this, we
                    // detect if we're the only handler *except* for previous versions
                    // of signal-exit, and increment by the count of listeners it has
                    // created.
                    /* c8 ignore start */ var p = process1;
                    if (_type_of$6(p.__signal_exit_emitter__) === 'object' && typeof p.__signal_exit_emitter__.count === 'number') {
                        count += p.__signal_exit_emitter__.count;
                    }
                    /* c8 ignore stop */ if (listeners.length === count) {
                        _this.unload();
                        var ret = _class_private_field_get(_this, _emitter).emit('exit', null, sig);
                        /* c8 ignore start */ var s = sig === 'SIGHUP' ? _class_private_field_get(_this, _hupSig) : sig;
                        if (!ret) process1.kill(process1.pid, s);
                    /* c8 ignore stop */ }
                };
            };
            for(var _iterator = signals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        _class_private_field_set(_this, _originalProcessReallyExit, process1.reallyExit);
        _class_private_field_set(_this, _originalProcessEmit, process1.emit);
        return _this;
    }
    var _proto = SignalExit.prototype;
    _proto.onExit = function onExit(cb, opts) {
        var _this = this;
        /* c8 ignore start */ if (!processOk(_class_private_field_get(this, _process))) {
            return function() {};
        }
        /* c8 ignore stop */ if (_class_private_field_get(this, _loaded) === false) {
            this.load();
        }
        var ev = (opts === null || opts === undefined ? undefined : opts.alwaysLast) ? 'afterExit' : 'exit';
        _class_private_field_get(this, _emitter).on(ev, cb);
        return function() {
            _class_private_field_get(_this, _emitter).removeListener(ev, cb);
            if (_class_private_field_get(_this, _emitter).listeners['exit'].length === 0 && _class_private_field_get(_this, _emitter).listeners['afterExit'].length === 0) {
                _this.unload();
            }
        };
    };
    _proto.load = function load() {
        var _this = this;
        var _this1 = this;
        if (_class_private_field_get(this, _loaded)) {
            return;
        }
        _class_private_field_set(this, _loaded, true);
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        _class_private_field_get(this, _emitter).count += 1;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = signals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var sig = _step.value;
                try {
                    var fn = _class_private_field_get(this, _sigListeners)[sig];
                    if (fn) _class_private_field_get(this, _process).on(sig, fn);
                } catch (_) {}
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        _class_private_field_get(this, _process).emit = function(ev) {
            for(var _len = arguments.length, a = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                a[_key - 1] = arguments[_key];
            }
            var _$_class_private_method_get;
            return (_$_class_private_method_get = _class_private_method_get(_this1, _processEmit, processEmit)).call.apply(_$_class_private_method_get, [
                _this1,
                ev
            ].concat(_to_consumable_array$3(a)));
        };
        _class_private_field_get(this, _process).reallyExit = function(code) {
            return _class_private_method_get(_this, _processReallyExit, processReallyExit).call(_this, code);
        };
    };
    _proto.unload = function unload() {
        var _this = this;
        if (!_class_private_field_get(this, _loaded)) {
            return;
        }
        _class_private_field_set(this, _loaded, false);
        signals.forEach(function(sig) {
            var listener = _class_private_field_get(_this, _sigListeners)[sig];
            /* c8 ignore start */ if (!listener) {
                throw new Error('Listener not defined for signal: ' + sig);
            }
            /* c8 ignore stop */ try {
                _class_private_field_get(_this, _process).removeListener(sig, listener);
            /* c8 ignore start */ } catch (_) {}
        /* c8 ignore stop */ });
        _class_private_field_get(this, _process).emit = _class_private_field_get(this, _originalProcessEmit);
        _class_private_field_get(this, _process).reallyExit = _class_private_field_get(this, _originalProcessReallyExit);
        _class_private_field_get(this, _emitter).count -= 1;
    };
    return SignalExit;
}(SignalExitBase);
function processReallyExit(code) {
    /* c8 ignore start */ if (!processOk(_class_private_field_get(this, _process))) {
        return 0;
    }
    _class_private_field_get(this, _process).exitCode = code || 0;
    /* c8 ignore stop */ _class_private_field_get(this, _emitter).emit('exit', _class_private_field_get(this, _process).exitCode, null);
    return _class_private_field_get(this, _originalProcessReallyExit).call(_class_private_field_get(this, _process), _class_private_field_get(this, _process).exitCode);
}
function processEmit(ev) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    var og = _class_private_field_get(this, _originalProcessEmit);
    if (ev === 'exit' && processOk(_class_private_field_get(this, _process))) {
        var _og;
        if (typeof args[0] === 'number') {
            _class_private_field_get(this, _process).exitCode = args[0];
        /* c8 ignore start */ }
        /* c8 ignore start */ var ret = (_og = og).call.apply(_og, [
            _class_private_field_get(this, _process),
            ev
        ].concat(_to_consumable_array$3(args)));
        /* c8 ignore start */ _class_private_field_get(this, _emitter).emit('exit', _class_private_field_get(this, _process).exitCode, null);
        /* c8 ignore stop */ return ret;
    } else {
        var _og1;
        return (_og1 = og).call.apply(_og1, [
            _class_private_field_get(this, _process),
            ev
        ].concat(_to_consumable_array$3(args)));
    }
}
var process$1 = globalThis.process;
var _signalExitWrap = signalExitWrap(processOk(process$1) ? new SignalExit(process$1) : new SignalExitFallback());
// wrap so that we call the method on the actual handler, without
// exporting it directly.
var /**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */ onExit = _signalExitWrap.onExit;

var colorSupport_1;
var hasRequiredColorSupport;
function requireColorSupport() {
    if (hasRequiredColorSupport) return colorSupport_1;
    hasRequiredColorSupport = 1;
    // call it on itself so we can test the export val for basic stuff
    colorSupport_1 = colorSupport({
        alwaysReturn: true
    }, colorSupport);
    function hasNone(obj, options) {
        obj.level = 0;
        obj.hasBasic = false;
        obj.has256 = false;
        obj.has16m = false;
        if (!options.alwaysReturn) {
            return false;
        }
        return obj;
    }
    function hasBasic(obj) {
        obj.hasBasic = true;
        obj.has256 = false;
        obj.has16m = false;
        obj.level = 1;
        return obj;
    }
    function has256(obj) {
        obj.hasBasic = true;
        obj.has256 = true;
        obj.has16m = false;
        obj.level = 2;
        return obj;
    }
    function has16m(obj) {
        obj.hasBasic = true;
        obj.has256 = true;
        obj.has16m = true;
        obj.level = 3;
        return obj;
    }
    function colorSupport(options, obj) {
        options = options || {};
        obj = obj || {};
        // if just requesting a specific level, then return that.
        if (typeof options.level === 'number') {
            switch(options.level){
                case 0:
                    return hasNone(obj, options);
                case 1:
                    return hasBasic(obj);
                case 2:
                    return has256(obj);
                case 3:
                    return has16m(obj);
            }
        }
        obj.level = 0;
        obj.hasBasic = false;
        obj.has256 = false;
        obj.has16m = false;
        if (typeof process === 'undefined' || !process || !process.stdout || !process.env || !process.platform) {
            return hasNone(obj, options);
        }
        var env = options.env || process.env;
        var stream = options.stream || process.stdout;
        var term = options.term || env.TERM || '';
        var platform = options.platform || process.platform;
        if (!options.ignoreTTY && !stream.isTTY) {
            return hasNone(obj, options);
        }
        if (!options.ignoreDumb && term === 'dumb' && !env.COLORTERM) {
            return hasNone(obj, options);
        }
        if (platform === 'win32') {
            return hasBasic(obj);
        }
        if (env.TMUX) {
            return has256(obj);
        }
        if (!options.ignoreCI && (env.CI || env.TEAMCITY_VERSION)) {
            if (env.TRAVIS) {
                return has256(obj);
            } else {
                return hasNone(obj, options);
            }
        }
        // TODO: add more term programs
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                var ver = env.TERM_PROGRAM_VERSION || '0.';
                if (/^[0-2]\./.test(ver)) {
                    return has256(obj);
                } else {
                    return has16m(obj);
                }
            case 'HyperTerm':
            case 'Hyper':
                return has16m(obj);
            case 'MacTerm':
                return has16m(obj);
            case 'Apple_Terminal':
                return has256(obj);
        }
        if (/^xterm-256/.test(term)) {
            return has256(obj);
        }
        if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(term)) {
            return hasBasic(obj);
        }
        if (env.COLORTERM) {
            return hasBasic(obj);
        }
        return hasNone(obj, options);
    }
    return colorSupport_1;
}

var colorSupportExports = requireColorSupport();
var colorSupport = /*@__PURE__*/ getDefaultExportFromCjs(colorSupportExports);

var hasColor = colorSupport().hasBasic;

function _instanceof$1(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _type_of$5(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var aproba;
var hasRequiredAproba;
function requireAproba() {
    if (hasRequiredAproba) return aproba;
    hasRequiredAproba = 1;
    aproba = validate;
    function isArguments(thingy) {
        return thingy != null && (typeof thingy === "undefined" ? "undefined" : _type_of$5(thingy)) === 'object' && thingy.hasOwnProperty('callee');
    }
    var types = {
        '*': {
            label: 'any',
            check: function() {
                return true;
            }
        },
        A: {
            label: 'array',
            check: function(_) {
                return Array.isArray(_) || isArguments(_);
            }
        },
        S: {
            label: 'string',
            check: function(_) {
                return typeof _ === 'string';
            }
        },
        N: {
            label: 'number',
            check: function(_) {
                return typeof _ === 'number';
            }
        },
        F: {
            label: 'function',
            check: function(_) {
                return typeof _ === 'function';
            }
        },
        O: {
            label: 'object',
            check: function(_) {
                return (typeof _ === "undefined" ? "undefined" : _type_of$5(_)) === 'object' && _ != null && !types.A.check(_) && !types.E.check(_);
            }
        },
        B: {
            label: 'boolean',
            check: function(_) {
                return typeof _ === 'boolean';
            }
        },
        E: {
            label: 'error',
            check: function(_) {
                return _instanceof$1(_, Error);
            }
        },
        Z: {
            label: 'null',
            check: function(_) {
                return _ == null;
            }
        }
    };
    function addSchema(schema, arity) {
        var group = arity[schema.length] = arity[schema.length] || [];
        if (group.indexOf(schema) === -1) group.push(schema);
    }
    function validate(rawSchemas, args) {
        var _loop = function(ii) {
            var newMatching = matching.filter(function(schema) {
                var type = schema[ii];
                var typeCheck = types[type].check;
                return typeCheck(args[ii]);
            });
            if (!newMatching.length) {
                var labels = matching.map(function(_) {
                    return types[_[ii]].label;
                }).filter(function(_) {
                    return _ != null;
                });
                throw invalidType(ii, labels, args[ii]);
            }
            matching = newMatching;
        };
        if (arguments.length !== 2) throw wrongNumberOfArgs([
            'SA'
        ], arguments.length);
        if (!rawSchemas) throw missingRequiredArg(0);
        if (!args) throw missingRequiredArg(1);
        if (!types.S.check(rawSchemas)) throw invalidType(0, [
            'string'
        ], rawSchemas);
        if (!types.A.check(args)) throw invalidType(1, [
            'array'
        ], args);
        var schemas = rawSchemas.split('|');
        var arity = {};
        schemas.forEach(function(schema) {
            for(var ii = 0; ii < schema.length; ++ii){
                var type = schema[ii];
                if (!types[type]) throw unknownType(ii, type);
            }
            if (/E.*E/.test(schema)) throw moreThanOneError(schema);
            addSchema(schema, arity);
            if (/E/.test(schema)) {
                addSchema(schema.replace(/E.*$/, 'E'), arity);
                addSchema(schema.replace(/E/, 'Z'), arity);
                if (schema.length === 1) addSchema('', arity);
            }
        });
        var matching = arity[args.length];
        if (!matching) {
            throw wrongNumberOfArgs(Object.keys(arity), args.length);
        }
        for(var ii = 0; ii < args.length; ++ii)_loop(ii);
    }
    function missingRequiredArg(num) {
        return newException('EMISSINGARG', 'Missing required argument #' + (num + 1));
    }
    function unknownType(num, type) {
        return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1));
    }
    function invalidType(num, expectedTypes, value) {
        var valueType;
        Object.keys(types).forEach(function(typeCode) {
            if (types[typeCode].check(value)) valueType = types[typeCode].label;
        });
        return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' + englishList(expectedTypes) + ' but got ' + valueType);
    }
    function englishList(list) {
        return list.join(', ').replace(/, ([^,]+)$/, ' or $1');
    }
    function wrongNumberOfArgs(expected, got) {
        var english = englishList(expected);
        var args = expected.every(function(ex) {
            return ex.length === 1;
        }) ? 'argument' : 'arguments';
        return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got);
    }
    function moreThanOneError(schema) {
        return newException('ETOOMANYERRORTYPES', 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
    }
    function newException(code, msg) {
        var err = new Error(msg);
        err.code = code;
        /* istanbul ignore else */ if (Error.captureStackTrace) Error.captureStackTrace(err, validate);
        return err;
    }
    return aproba;
}

var aprobaExports = requireAproba();
var validate$1 = /*@__PURE__*/ getDefaultExportFromCjs(aprobaExports);

var align$1 = {};

var ansiRegex;
var hasRequiredAnsiRegex;
function requireAnsiRegex() {
    if (hasRequiredAnsiRegex) return ansiRegex;
    hasRequiredAnsiRegex = 1;
    ansiRegex = function() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref_onlyFirst = _ref.onlyFirst, onlyFirst = _ref_onlyFirst === undefined ? false : _ref_onlyFirst;
        var pattern = [
            '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
            '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
        ].join('|');
        return new RegExp(pattern, onlyFirst ? undefined : 'g');
    };
    return ansiRegex;
}

var stripAnsi$1;
var hasRequiredStripAnsi;
function requireStripAnsi() {
    if (hasRequiredStripAnsi) return stripAnsi$1;
    hasRequiredStripAnsi = 1;
    var ansiRegex = requireAnsiRegex();
    stripAnsi$1 = function(string) {
        return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
    };
    return stripAnsi$1;
}

var stripAnsiExports = requireStripAnsi();
var stripAnsi = /*@__PURE__*/ getDefaultExportFromCjs(stripAnsiExports);

// Generated code.
function isAmbiguous(x) {
    return x === 0xA1 || x === 0xA4 || x === 0xA7 || x === 0xA8 || x === 0xAA || x === 0xAD || x === 0xAE || x >= 0xB0 && x <= 0xB4 || x >= 0xB6 && x <= 0xBA || x >= 0xBC && x <= 0xBF || x === 0xC6 || x === 0xD0 || x === 0xD7 || x === 0xD8 || x >= 0xDE && x <= 0xE1 || x === 0xE6 || x >= 0xE8 && x <= 0xEA || x === 0xEC || x === 0xED || x === 0xF0 || x === 0xF2 || x === 0xF3 || x >= 0xF7 && x <= 0xFA || x === 0xFC || x === 0xFE || x === 0x101 || x === 0x111 || x === 0x113 || x === 0x11B || x === 0x126 || x === 0x127 || x === 0x12B || x >= 0x131 && x <= 0x133 || x === 0x138 || x >= 0x13F && x <= 0x142 || x === 0x144 || x >= 0x148 && x <= 0x14B || x === 0x14D || x === 0x152 || x === 0x153 || x === 0x166 || x === 0x167 || x === 0x16B || x === 0x1CE || x === 0x1D0 || x === 0x1D2 || x === 0x1D4 || x === 0x1D6 || x === 0x1D8 || x === 0x1DA || x === 0x1DC || x === 0x251 || x === 0x261 || x === 0x2C4 || x === 0x2C7 || x >= 0x2C9 && x <= 0x2CB || x === 0x2CD || x === 0x2D0 || x >= 0x2D8 && x <= 0x2DB || x === 0x2DD || x === 0x2DF || x >= 0x300 && x <= 0x36F || x >= 0x391 && x <= 0x3A1 || x >= 0x3A3 && x <= 0x3A9 || x >= 0x3B1 && x <= 0x3C1 || x >= 0x3C3 && x <= 0x3C9 || x === 0x401 || x >= 0x410 && x <= 0x44F || x === 0x451 || x === 0x2010 || x >= 0x2013 && x <= 0x2016 || x === 0x2018 || x === 0x2019 || x === 0x201C || x === 0x201D || x >= 0x2020 && x <= 0x2022 || x >= 0x2024 && x <= 0x2027 || x === 0x2030 || x === 0x2032 || x === 0x2033 || x === 0x2035 || x === 0x203B || x === 0x203E || x === 0x2074 || x === 0x207F || x >= 0x2081 && x <= 0x2084 || x === 0x20AC || x === 0x2103 || x === 0x2105 || x === 0x2109 || x === 0x2113 || x === 0x2116 || x === 0x2121 || x === 0x2122 || x === 0x2126 || x === 0x212B || x === 0x2153 || x === 0x2154 || x >= 0x215B && x <= 0x215E || x >= 0x2160 && x <= 0x216B || x >= 0x2170 && x <= 0x2179 || x === 0x2189 || x >= 0x2190 && x <= 0x2199 || x === 0x21B8 || x === 0x21B9 || x === 0x21D2 || x === 0x21D4 || x === 0x21E7 || x === 0x2200 || x === 0x2202 || x === 0x2203 || x === 0x2207 || x === 0x2208 || x === 0x220B || x === 0x220F || x === 0x2211 || x === 0x2215 || x === 0x221A || x >= 0x221D && x <= 0x2220 || x === 0x2223 || x === 0x2225 || x >= 0x2227 && x <= 0x222C || x === 0x222E || x >= 0x2234 && x <= 0x2237 || x === 0x223C || x === 0x223D || x === 0x2248 || x === 0x224C || x === 0x2252 || x === 0x2260 || x === 0x2261 || x >= 0x2264 && x <= 0x2267 || x === 0x226A || x === 0x226B || x === 0x226E || x === 0x226F || x === 0x2282 || x === 0x2283 || x === 0x2286 || x === 0x2287 || x === 0x2295 || x === 0x2299 || x === 0x22A5 || x === 0x22BF || x === 0x2312 || x >= 0x2460 && x <= 0x24E9 || x >= 0x24EB && x <= 0x254B || x >= 0x2550 && x <= 0x2573 || x >= 0x2580 && x <= 0x258F || x >= 0x2592 && x <= 0x2595 || x === 0x25A0 || x === 0x25A1 || x >= 0x25A3 && x <= 0x25A9 || x === 0x25B2 || x === 0x25B3 || x === 0x25B6 || x === 0x25B7 || x === 0x25BC || x === 0x25BD || x === 0x25C0 || x === 0x25C1 || x >= 0x25C6 && x <= 0x25C8 || x === 0x25CB || x >= 0x25CE && x <= 0x25D1 || x >= 0x25E2 && x <= 0x25E5 || x === 0x25EF || x === 0x2605 || x === 0x2606 || x === 0x2609 || x === 0x260E || x === 0x260F || x === 0x261C || x === 0x261E || x === 0x2640 || x === 0x2642 || x === 0x2660 || x === 0x2661 || x >= 0x2663 && x <= 0x2665 || x >= 0x2667 && x <= 0x266A || x === 0x266C || x === 0x266D || x === 0x266F || x === 0x269E || x === 0x269F || x === 0x26BF || x >= 0x26C6 && x <= 0x26CD || x >= 0x26CF && x <= 0x26D3 || x >= 0x26D5 && x <= 0x26E1 || x === 0x26E3 || x === 0x26E8 || x === 0x26E9 || x >= 0x26EB && x <= 0x26F1 || x === 0x26F4 || x >= 0x26F6 && x <= 0x26F9 || x === 0x26FB || x === 0x26FC || x === 0x26FE || x === 0x26FF || x === 0x273D || x >= 0x2776 && x <= 0x277F || x >= 0x2B56 && x <= 0x2B59 || x >= 0x3248 && x <= 0x324F || x >= 0xE000 && x <= 0xF8FF || x >= 0xFE00 && x <= 0xFE0F || x === 0xFFFD || x >= 0x1F100 && x <= 0x1F10A || x >= 0x1F110 && x <= 0x1F12D || x >= 0x1F130 && x <= 0x1F169 || x >= 0x1F170 && x <= 0x1F18D || x === 0x1F18F || x === 0x1F190 || x >= 0x1F19B && x <= 0x1F1AC || x >= 0xE0100 && x <= 0xE01EF || x >= 0xF0000 && x <= 0xFFFFD || x >= 0x100000 && x <= 0x10FFFD;
}
function isFullWidth(x) {
    return x === 0x3000 || x >= 0xFF01 && x <= 0xFF60 || x >= 0xFFE0 && x <= 0xFFE6;
}
function isWide(x) {
    return x >= 0x1100 && x <= 0x115F || x === 0x231A || x === 0x231B || x === 0x2329 || x === 0x232A || x >= 0x23E9 && x <= 0x23EC || x === 0x23F0 || x === 0x23F3 || x === 0x25FD || x === 0x25FE || x === 0x2614 || x === 0x2615 || x >= 0x2630 && x <= 0x2637 || x >= 0x2648 && x <= 0x2653 || x === 0x267F || x >= 0x268A && x <= 0x268F || x === 0x2693 || x === 0x26A1 || x === 0x26AA || x === 0x26AB || x === 0x26BD || x === 0x26BE || x === 0x26C4 || x === 0x26C5 || x === 0x26CE || x === 0x26D4 || x === 0x26EA || x === 0x26F2 || x === 0x26F3 || x === 0x26F5 || x === 0x26FA || x === 0x26FD || x === 0x2705 || x === 0x270A || x === 0x270B || x === 0x2728 || x === 0x274C || x === 0x274E || x >= 0x2753 && x <= 0x2755 || x === 0x2757 || x >= 0x2795 && x <= 0x2797 || x === 0x27B0 || x === 0x27BF || x === 0x2B1B || x === 0x2B1C || x === 0x2B50 || x === 0x2B55 || x >= 0x2E80 && x <= 0x2E99 || x >= 0x2E9B && x <= 0x2EF3 || x >= 0x2F00 && x <= 0x2FD5 || x >= 0x2FF0 && x <= 0x2FFF || x >= 0x3001 && x <= 0x303E || x >= 0x3041 && x <= 0x3096 || x >= 0x3099 && x <= 0x30FF || x >= 0x3105 && x <= 0x312F || x >= 0x3131 && x <= 0x318E || x >= 0x3190 && x <= 0x31E5 || x >= 0x31EF && x <= 0x321E || x >= 0x3220 && x <= 0x3247 || x >= 0x3250 && x <= 0xA48C || x >= 0xA490 && x <= 0xA4C6 || x >= 0xA960 && x <= 0xA97C || x >= 0xAC00 && x <= 0xD7A3 || x >= 0xF900 && x <= 0xFAFF || x >= 0xFE10 && x <= 0xFE19 || x >= 0xFE30 && x <= 0xFE52 || x >= 0xFE54 && x <= 0xFE66 || x >= 0xFE68 && x <= 0xFE6B || x >= 0x16FE0 && x <= 0x16FE4 || x === 0x16FF0 || x === 0x16FF1 || x >= 0x17000 && x <= 0x187F7 || x >= 0x18800 && x <= 0x18CD5 || x >= 0x18CFF && x <= 0x18D08 || x >= 0x1AFF0 && x <= 0x1AFF3 || x >= 0x1AFF5 && x <= 0x1AFFB || x === 0x1AFFD || x === 0x1AFFE || x >= 0x1B000 && x <= 0x1B122 || x === 0x1B132 || x >= 0x1B150 && x <= 0x1B152 || x === 0x1B155 || x >= 0x1B164 && x <= 0x1B167 || x >= 0x1B170 && x <= 0x1B2FB || x >= 0x1D300 && x <= 0x1D356 || x >= 0x1D360 && x <= 0x1D376 || x === 0x1F004 || x === 0x1F0CF || x === 0x1F18E || x >= 0x1F191 && x <= 0x1F19A || x >= 0x1F200 && x <= 0x1F202 || x >= 0x1F210 && x <= 0x1F23B || x >= 0x1F240 && x <= 0x1F248 || x === 0x1F250 || x === 0x1F251 || x >= 0x1F260 && x <= 0x1F265 || x >= 0x1F300 && x <= 0x1F320 || x >= 0x1F32D && x <= 0x1F335 || x >= 0x1F337 && x <= 0x1F37C || x >= 0x1F37E && x <= 0x1F393 || x >= 0x1F3A0 && x <= 0x1F3CA || x >= 0x1F3CF && x <= 0x1F3D3 || x >= 0x1F3E0 && x <= 0x1F3F0 || x === 0x1F3F4 || x >= 0x1F3F8 && x <= 0x1F43E || x === 0x1F440 || x >= 0x1F442 && x <= 0x1F4FC || x >= 0x1F4FF && x <= 0x1F53D || x >= 0x1F54B && x <= 0x1F54E || x >= 0x1F550 && x <= 0x1F567 || x === 0x1F57A || x === 0x1F595 || x === 0x1F596 || x === 0x1F5A4 || x >= 0x1F5FB && x <= 0x1F64F || x >= 0x1F680 && x <= 0x1F6C5 || x === 0x1F6CC || x >= 0x1F6D0 && x <= 0x1F6D2 || x >= 0x1F6D5 && x <= 0x1F6D7 || x >= 0x1F6DC && x <= 0x1F6DF || x === 0x1F6EB || x === 0x1F6EC || x >= 0x1F6F4 && x <= 0x1F6FC || x >= 0x1F7E0 && x <= 0x1F7EB || x === 0x1F7F0 || x >= 0x1F90C && x <= 0x1F93A || x >= 0x1F93C && x <= 0x1F945 || x >= 0x1F947 && x <= 0x1F9FF || x >= 0x1FA70 && x <= 0x1FA7C || x >= 0x1FA80 && x <= 0x1FA89 || x >= 0x1FA8F && x <= 0x1FAC6 || x >= 0x1FACE && x <= 0x1FADC || x >= 0x1FADF && x <= 0x1FAE9 || x >= 0x1FAF0 && x <= 0x1FAF8 || x >= 0x20000 && x <= 0x2FFFD || x >= 0x30000 && x <= 0x3FFFD;
}

function _type_of$4(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function validate(codePoint) {
    if (!Number.isSafeInteger(codePoint)) {
        throw new TypeError("Expected a code point, got `".concat(typeof codePoint === "undefined" ? "undefined" : _type_of$4(codePoint), "`."));
    }
}
function eastAsianWidth(codePoint) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref_ambiguousAsWide = _ref.ambiguousAsWide, ambiguousAsWide = _ref_ambiguousAsWide === undefined ? false : _ref_ambiguousAsWide;
    validate(codePoint);
    if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
        return 2;
    }
    return 1;
}

var emojiRegex$1;
var hasRequiredEmojiRegex;
function requireEmojiRegex() {
    if (hasRequiredEmojiRegex) return emojiRegex$1;
    hasRequiredEmojiRegex = 1;
    emojiRegex$1 = function() {
        // https://mths.be/emoji
        return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    return emojiRegex$1;
}

var emojiRegexExports = requireEmojiRegex();
var emojiRegex = /*@__PURE__*/ getDefaultExportFromCjs(emojiRegexExports);

var segmenter = new Intl.Segmenter();
var defaultIgnorableCodePointRegex = RegExp("^\\p{Default_Ignorable_Code_Point}$", "u");
function stringWidth(string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (typeof string !== 'string' || string.length === 0) {
        return 0;
    }
    var _options_ambiguousIsNarrow = options.ambiguousIsNarrow, ambiguousIsNarrow = _options_ambiguousIsNarrow === undefined ? true : _options_ambiguousIsNarrow, _options_countAnsiEscapeCodes = options.countAnsiEscapeCodes, countAnsiEscapeCodes = _options_countAnsiEscapeCodes === undefined ? false : _options_countAnsiEscapeCodes;
    if (!countAnsiEscapeCodes) {
        string = stripAnsi(string);
    }
    if (string.length === 0) {
        return 0;
    }
    var width = 0;
    var eastAsianWidthOptions = {
        ambiguousAsWide: !ambiguousIsNarrow
    };
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segmenter.segment(string)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _step.value, character = _step_value.segment;
            var codePoint = character.codePointAt(0);
            // Ignore control characters
            if (codePoint <= 0x1F || codePoint >= 0x7F && codePoint <= 0x9F) {
                continue;
            }
            // Ignore zero-width characters
            if (codePoint >= 0x200B && codePoint <= 0x200F // Zero-width space, non-joiner, joiner, left-to-right mark, right-to-left mark
             || codePoint === 0xFEFF // Zero-width no-break space
            ) {
                continue;
            }
            // Ignore combining characters
            if (codePoint >= 0x300 && codePoint <= 0x36F // Combining diacritical marks
             || codePoint >= 0x1AB0 && codePoint <= 0x1AFF // Combining diacritical marks extended
             || codePoint >= 0x1DC0 && codePoint <= 0x1DFF // Combining diacritical marks supplement
             || codePoint >= 0x20D0 && codePoint <= 0x20FF // Combining diacritical marks for symbols
             || codePoint >= 0xFE20 && codePoint <= 0xFE2F // Combining half marks
            ) {
                continue;
            }
            // Ignore surrogate pairs
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                continue;
            }
            // Ignore variation selectors
            if (codePoint >= 0xFE00 && codePoint <= 0xFE0F) {
                continue;
            }
            // This covers some of the above cases, but we still keep them for performance reasons.
            if (defaultIgnorableCodePointRegex.test(character)) {
                continue;
            }
            // TODO: Use `/\p{RGI_Emoji}/v` when targeting Node.js 20.
            if (emojiRegex().test(character)) {
                width += 2;
                continue;
            }
            width += eastAsianWidth(codePoint, eastAsianWidthOptions);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return width;
}

var stringWidth$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: stringWidth
});

var require$$0 = /*@__PURE__*/ getAugmentedNamespace(stringWidth$1);

var hasRequiredAlign;
function requireAlign() {
    if (hasRequiredAlign) return align$1;
    hasRequiredAlign = 1;
    var stringWidth = require$$0;
    align$1.center = alignCenter;
    align$1.left = alignLeft;
    align$1.right = alignRight;
    // lodash's way of generating pad characters.
    function createPadding(width) {
        var result = '';
        var string = ' ';
        var n = width;
        do {
            if (n % 2) {
                result += string;
            }
            n = Math.floor(n / 2);
            string += string;
        }while (n);
        return result;
    }
    function alignLeft(str, width) {
        var trimmed = str.trimRight();
        if (trimmed.length === 0 && str.length >= width) return str;
        var padding = '';
        var strWidth = stringWidth(trimmed);
        if (strWidth < width) {
            padding = createPadding(width - strWidth);
        }
        return trimmed + padding;
    }
    function alignRight(str, width) {
        var trimmed = str.trimLeft();
        if (trimmed.length === 0 && str.length >= width) return str;
        var padding = '';
        var strWidth = stringWidth(trimmed);
        if (strWidth < width) {
            padding = createPadding(width - strWidth);
        }
        return padding + trimmed;
    }
    function alignCenter(str, width) {
        var trimmed = str.trim();
        if (trimmed.length === 0 && str.length >= width) return str;
        var padLeft = '';
        var padRight = '';
        var strWidth = stringWidth(trimmed);
        if (strWidth < width) {
            var padLeftBy = parseInt((width - strWidth) / 2, 10);
            padLeft = createPadding(padLeftBy);
            padRight = createPadding(width - (strWidth + padLeftBy));
        }
        return padLeft + trimmed + padRight;
    }
    return align$1;
}

var alignExports = requireAlign();
var align = /*@__PURE__*/ getDefaultExportFromCjs(alignExports);

var User = function(msg) {
    var err = new Error(msg);
    Error.captureStackTrace(err, User);
    err.code = 'EGAUGE';
    return err;
};
function MissingTemplateValue(item, values) {
    var err = User(util.format('Missing template value "%s"', item.type));
    Error.captureStackTrace(err, MissingTemplateValue);
    err.template = item;
    err.values = values;
    return err;
}
function Internal(msg) {
    var err = new Error(msg);
    Error.captureStackTrace(err, Internal);
    err.code = 'EGAUGEINTERNAL';
    return err;
}

function _class_call_check$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function isPercent(num) {
    if (typeof num !== 'string') {
        return false;
    }
    return num.slice(-1) === '%';
}
function percent(num) {
    return Number(num.slice(0, -1)) / 100;
}
var TemplateItem = /*#__PURE__*/ function() {
    function TemplateItem(values, outputLength) {
        _class_call_check$6(this, TemplateItem);
        this.type = null;
        this.value = null;
        this.length = null;
        this.maxLength = null;
        this.minLength = null;
        this.kerning = null;
        this.align = 'left';
        this.padLeft = 0;
        this.padRight = 0;
        this.index = null;
        this.first = null;
        this.last = null;
        this.overallOutputLength = outputLength;
        this.finished = false;
        this.type = null;
        this.value = null;
        this.length = null;
        this.maxLength = null;
        this.minLength = null;
        this.kerning = null;
        this.align = 'left';
        this.padLeft = 0;
        this.padRight = 0;
        this.index = null;
        this.first = null;
        this.last = null;
        if (typeof values === 'string') {
            this.value = values;
        } else {
            for(var prop in values){
                this[prop] = values[prop];
            }
        }
        if (isPercent(this.length)) {
            this.length = Math.round(this.overallOutputLength * percent(this.length));
        }
        if (isPercent(this.minLength)) {
            this.minLength = Math.round(this.overallOutputLength * percent(this.minLength));
        }
        if (isPercent(this.maxLength)) {
            this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength));
        }
        return this;
    }
    var _proto = TemplateItem.prototype;
    _proto.getBaseLength = function getBaseLength() {
        var length = this.length;
        if (length == null && typeof this.value === 'string' && this.maxLength == null && this.minLength == null) {
            length = stringWidth(this.value);
        }
        return length;
    };
    _proto.getLength = function getLength() {
        var length = this.getBaseLength();
        if (length == null) {
            return null;
        }
        return length + this.padLeft + this.padRight;
    };
    _proto.getMaxLength = function getMaxLength() {
        if (this.maxLength == null) {
            return null;
        }
        return this.maxLength + this.padLeft + this.padRight;
    };
    _proto.getMinLength = function getMinLength() {
        if (this.minLength == null) {
            return null;
        }
        return this.minLength + this.padLeft + this.padRight;
    };
    return TemplateItem;
} 
();

function wideTruncate(str, target) {
    if (stringWidth(str) === 0) {
        return str;
    }
    if (target <= 0) {
        return '';
    }
    if (stringWidth(str) <= target) {
        return str;
    }
    var noAnsi = util.stripVTControlCharacters(str);
    var ansiSize = str.length + noAnsi.length;
    var truncated = str.slice(0, target + ansiSize);
    while(stringWidth(truncated) > target){
        truncated = truncated.slice(0, -1);
    }
    return truncated;
}

function renderValueWithValues(values) {
    return function(item) {
        return renderValue(item, values);
    };
}
var renderTemplate = function renderTemplate(width, template, values) {
    var items = prepareItems(width, template, values);
    var rendered = items.map(renderValueWithValues(values)).join('');
    return align.left(wideTruncate(rendered, width), width);
};
function preType(item) {
    var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
    return 'pre' + cappedTypeName;
}
function postType(item) {
    var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
    return 'post' + cappedTypeName;
}
function hasPreOrPost(item, values) {
    if (!item.type) {
        return;
    }
    return values[preType(item)] || values[postType(item)];
}
function generatePreAndPost(baseItem, parentValues) {
    var item = Object.assign({}, baseItem);
    var values = Object.create(parentValues);
    var template = [];
    var pre = preType(item);
    var post = postType(item);
    if (values[pre]) {
        template.push({
            value: values[pre]
        });
        values[pre] = null;
    }
    item.minLength = null;
    item.length = null;
    item.maxLength = null;
    template.push(item);
    values[item.type] = values[item.type];
    if (values[post]) {
        template.push({
            value: values[post]
        });
        values[post] = null;
    }
    return function($1, $2, length) {
        return renderTemplate(length, template, values);
    };
}
function prepareItems(width, template, values) {
    function cloneAndObjectify(item, index, arr) {
        var cloned = new TemplateItem(item, width);
        var type = cloned.type;
        if (cloned.value == null) {
            if (!(type in values)) {
                if (cloned == null) {
                    throw MissingTemplateValue(cloned, values);
                } else {
                    cloned.value = cloned;
                }
            } else {
                cloned.value = values[type];
            }
        }
        if (cloned.value == null || cloned.value === '') {
            return null;
        }
        cloned.index = index;
        cloned.first = index === 0;
        cloned.last = index === arr.length - 1;
        if (hasPreOrPost(cloned, values)) {
            cloned.value = generatePreAndPost(cloned, values);
        }
        return cloned;
    }
    var output = template.map(cloneAndObjectify).filter(function(item) {
        return item != null;
    });
    var remainingSpace = width;
    var variableCount = output.length;
    function consumeSpace(length) {
        if (length > remainingSpace) {
            length = remainingSpace;
        }
        remainingSpace -= length;
    }
    function finishSizing(item, length) {
        if (item.finished) {
            throw Internal('Tried to finish template item that was already finished');
        }
        if (length === Infinity) {
            throw Internal('Length of template item cannot be infinity');
        }
        if (length != null) {
            item.length = length;
        }
        item.minLength = null;
        item.maxLength = null;
        --variableCount;
        item.finished = true;
        if (item.length == null) {
            item.length = item.getBaseLength();
        }
        if (item.length == null) {
            throw Internal('Finished template items must have a length');
        }
        consumeSpace(item.getLength());
    }
    output.forEach(function(item) {
        if (!item.kerning) {
            return;
        }
        var prevPadRight = item.first ? 0 : output[item.index - 1].padRight;
        if (!item.first && prevPadRight < item.kerning) {
            item.padLeft = item.kerning - prevPadRight;
        }
        if (!item.last) {
            item.padRight = item.kerning;
        }
    });
    output.forEach(function(item) {
        if (item.getBaseLength() == null) {
            return;
        }
        finishSizing(item);
    });
    var resized = 0;
    var resizing;
    var hunkSize;
    do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output.forEach(function(item) {
            if (item.finished) {
                return;
            }
            if (!item.maxLength) {
                return;
            }
            if (item.getMaxLength() < hunkSize) {
                finishSizing(item, item.maxLength);
                resizing = true;
            }
        });
    }while (resizing && resized++ < output.length);
    if (resizing) {
        throw Internal('Resize loop iterated too many times while determining maxLength');
    }
    resized = 0;
    do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output.forEach(function(item) {
            if (item.finished) {
                return;
            }
            if (!item.minLength) {
                return;
            }
            if (item.getMinLength() >= hunkSize) {
                finishSizing(item, item.minLength);
                resizing = true;
            }
        });
    }while (resizing && resized++ < output.length);
    if (resizing) {
        throw Internal('Resize loop iterated too many times while determining minLength');
    }
    hunkSize = Math.round(remainingSpace / variableCount);
    output.forEach(function(item) {
        if (item.finished) {
            return;
        }
        finishSizing(item, hunkSize);
    });
    return output;
}
function renderFunction(item, values, length) {
    validate$1('OON', arguments);
    if (item.type) {
        return item.value(values, values[item.type + 'Theme'] || {}, length);
    } else {
        return item.value(values, {}, length);
    }
}
function renderValue(item, values) {
    var length = item.getBaseLength();
    var value = typeof item.value === 'function' ? renderFunction(item, values, length) : item.value;
    if (value == null || value === '') {
        return '';
    }
    var alignWith = align[item.align] || align.left;
    var leftPadding = item.padLeft ? align.left('', item.padLeft) : '';
    var rightPadding = item.padRight ? align.right('', item.padRight) : '';
    var truncated = wideTruncate(String(value), length);
    var aligned = alignWith(truncated, length);
    return leftPadding + aligned + rightPadding;
}

function _class_call_check$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var Plumbing = /*#__PURE__*/ function() {
    function Plumbing(theme, template, width) {
        _class_call_check$5(this, Plumbing);
        if (!width) {
            width = 80;
        }
        validate$1('OAN', [
            theme,
            template,
            width
        ]);
        this.showing = false;
        this.theme = theme;
        this.width = width;
        this.template = template;
    }
    var _proto = Plumbing.prototype;
    _proto.setTheme = function setTheme(theme) {
        validate$1('O', [
            theme
        ]);
        this.theme = theme;
    };
    _proto.setTemplate = function setTemplate(template) {
        validate$1('A', [
            template
        ]);
        this.template = template;
    };
    _proto.setWidth = function setWidth(width) {
        validate$1('N', [
            width
        ]);
        this.width = width;
    };
    _proto.hideCursor = function hideCursor() {
        return consoleControl.hideCursor();
    };
    _proto.showCursor = function showCursor() {
        return consoleControl.showCursor();
    };
    _proto.hide = function hide() {
        return consoleControl.gotoSOL() + consoleControl.eraseLine();
    };
    _proto.show = function show(status) {
        var values = Object.create(this.theme);
        for(var key in status){
            values[key] = status[key];
        }
        return renderTemplate(this.width, this.template, values).trim() + consoleControl.color('reset') + consoleControl.eraseLine() + consoleControl.gotoSOL();
    };
    return Plumbing;
} 
();

function setImmediateFn() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    try {
        return window.setImmediate(args);
    } catch (_) {
        return process.nextTick(args);
    }
}

function progressBar(theme, width, completed) {
    validate$1('ONN', [
        theme,
        width,
        completed
    ]);
    if (completed < 0) {
        completed = 0;
    }
    if (completed > 1) {
        completed = 1;
    }
    if (width <= 0) {
        return '';
    }
    var sofar = Math.round(width * completed);
    var rest = width - sofar;
    var template = [
        {
            type: 'complete',
            value: repeat(theme.complete, sofar),
            length: sofar
        },
        {
            type: 'remaining',
            value: repeat(theme.remaining, rest),
            length: rest
        }
    ];
    return renderTemplate(width, template, theme);
}
function repeat(string, width) {
    var result = '';
    var n = width;
    do {
        if (n % 2) {
            result += string;
        }
        n = Math.floor(n / 2);
        string += string;
    }while (n && stringWidth(result) < width);
    return wideTruncate(result, width);
}

function spin(spinstr, spun) {
    return spinstr[spun % spinstr.length];
}

function activityIndicator(values, theme, _width) {
    if (values.spun == null) {
        return;
    }
    return spin(theme, values.spun);
}
function progressbar(values, theme, width) {
    if (values.completed == null) {
        return;
    }
    return progressBar(theme, width, values.completed);
}
var baseTheme = {
    activityIndicator: activityIndicator,
    progressbar: progressbar
};

var ThemeSetProto = {};
ThemeSetProto.baseTheme = baseTheme;
ThemeSetProto.newTheme = function(parent, theme) {
    if (!theme) {
        theme = parent;
        parent = this.baseTheme;
    }
    return Object.assign({}, parent, theme);
};
ThemeSetProto.getThemeNames = function() {
    return Object.keys(this.themes);
};
ThemeSetProto.addTheme = function(name, parent, theme) {
    this.themes[name] = this.newTheme(parent, theme);
};
ThemeSetProto.addToAllThemes = function(theme) {
    var themes = this.themes;
    Object.keys(themes).forEach(function(name) {
        Object.assign(themes[name], theme);
    });
    Object.assign(this.baseTheme, theme);
};
ThemeSetProto.getTheme = function(name) {
    if (!this.themes[name]) {
        throw this.newMissingThemeError(name);
    }
    return this.themes[name];
};
ThemeSetProto.setDefault = function(opts, name) {
    if (name == null) {
        name = opts;
        opts = {};
    }
    var platform = opts.platform == null ? 'fallback' : opts.platform;
    var hasUnicode = !!opts.hasUnicode;
    var hasColor = !!opts.hasColor;
    if (!this.defaults[platform]) {
        this.defaults[platform] = {
            true: {},
            false: {}
        };
    }
    this.defaults[platform][String(hasUnicode)][String(hasColor)] = name;
};
ThemeSetProto.getDefault = function(opts) {
    if (!opts) {
        opts = {};
    }
    var platformName = opts.platform || process.platform;
    var platform = this.defaults[platformName] || this.defaults.fallback;
    var hasUnicode = !!opts.hasUnicode;
    var hasColor = !!opts.hasColor;
    if (!platform) {
        throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
    }
    if (!platform[String(hasUnicode)][String(hasColor)]) {
        if (hasUnicode && hasColor && platform[String(!hasUnicode)][String(hasColor)]) {
            hasUnicode = false;
        } else if (hasUnicode && hasColor && platform[String(hasUnicode)][String(!hasColor)]) {
            hasColor = false;
        } else if (hasUnicode && hasColor && platform[String(!hasUnicode)][String(!hasColor)]) {
            hasUnicode = false;
            hasColor = false;
        } else if (hasUnicode && !hasColor && platform[String(!hasUnicode)][String(hasColor)]) {
            hasUnicode = false;
        } else if (!hasUnicode && hasColor && platform[String(hasUnicode)][String(!hasColor)]) {
            hasColor = false;
        } else if (platform === this.defaults.fallback) {
            throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
        }
    }
    if (platform[String(hasUnicode)][String(hasColor)]) {
        return this.getTheme(platform[String(hasUnicode)][String(hasColor)]);
    } else {
        return this.getDefault(Object.assign({}, opts, {
            platform: 'fallback'
        }));
    }
};
ThemeSetProto.newMissingThemeError = function newMissingThemeError(name) {
    var err = new Error('Could not find a gauge theme named "' + name + '"');
    Error.captureStackTrace.call(err, newMissingThemeError);
    err.theme = name;
    err.code = 'EMISSINGTHEME';
    return err;
};
ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError(platformName, hasUnicode, hasColor) {
    var err = new Error('Could not find a gauge theme for your platform/unicode/color use combo:\n' + '    platform = ' + platformName + '\n' + '    hasUnicode = ' + hasUnicode + '\n' + '    hasColor = ' + hasColor);
    Error.captureStackTrace.call(err, newMissingDefaultThemeError);
    err.platform = platformName;
    err.hasUnicode = hasUnicode;
    err.hasColor = hasColor;
    err.code = 'EMISSINGTHEME';
    return err;
};
ThemeSetProto.newThemeSet = function() {
    var themeset = function themeset1(opts) {
        return themeset.getDefault(opts);
    };
    return Object.assign(themeset, ThemeSetProto, {
        themes: Object.assign({}, this.themes),
        baseTheme: Object.assign({}, this.baseTheme),
        defaults: JSON.parse(JSON.stringify(this.defaults || {}))
    });
};
function ThemeSet() {
    return ThemeSetProto.newThemeSet();
}

var themes = ThemeSet();
themes.addTheme('ASCII', {
    preProgressbar: '[',
    postProgressbar: ']',
    progressbarTheme: {
        complete: '#',
        remaining: '.'
    },
    activityIndicatorTheme: '-\\|/',
    preSubsection: '>'
});
themes.addTheme('colorASCII', themes.getTheme('ASCII'), {
    progressbarTheme: {
        preComplete: consoleControlStringsExports.color('bgBrightWhite', 'brightWhite'),
        complete: '#',
        postComplete: consoleControlStringsExports.color('reset'),
        preRemaining: consoleControlStringsExports.color('bgBrightBlack', 'brightBlack'),
        remaining: '.',
        postRemaining: consoleControlStringsExports.color('reset')
    }
});
themes.addTheme('brailleSpinner', {
    preProgressbar: '(',
    postProgressbar: ')',
    progressbarTheme: {
        complete: '#',
        remaining: '⠂'
    },
    activityIndicatorTheme: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏',
    preSubsection: '>'
});
themes.addTheme('colorBrailleSpinner', themes.getTheme('brailleSpinner'), {
    progressbarTheme: {
        preComplete: consoleControlStringsExports.color('bgBrightWhite', 'brightWhite'),
        complete: '#',
        postComplete: consoleControlStringsExports.color('reset'),
        preRemaining: consoleControlStringsExports.color('bgBrightBlack', 'brightBlack'),
        remaining: '⠂',
        postRemaining: consoleControlStringsExports.color('reset')
    }
});
themes.setDefault({}, 'ASCII');
themes.setDefault({
    hasColor: true
}, 'colorASCII');
themes.setDefault({
    platform: 'darwin',
    hasUnicode: true
}, 'brailleSpinner');
themes.setDefault({
    platform: 'darwin',
    hasUnicode: true,
    hasColor: true
}, 'colorBrailleSpinner');
themes.setDefault({
    platform: 'linux',
    hasUnicode: true
}, 'brailleSpinner');
themes.setDefault({
    platform: 'linux',
    hasUnicode: true,
    hasColor: true
}, 'colorBrailleSpinner');

function _class_call_check$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _type_of$3(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function callWith(obj, method) {
    return function() {
        return method.call(obj);
    };
}
var Gauge = /*#__PURE__*/ function() {
    function Gauge(arg1, arg2) {
        _class_call_check$4(this, Gauge);
        var options, writeTo;
        if (arg1 && arg1.write) {
            writeTo = arg1;
            options = arg2 || {};
        } else if (arg2 && arg2.write) {
            writeTo = arg2;
            options = arg1 || {};
        } else {
            writeTo = process.stderr;
            options = arg1 || arg2 || {};
        }
        this._status = {
            spun: 0,
            section: '',
            subsection: ''
        };
        this._paused = false;
        this._disabled = true;
        this._showing = false;
        this._onScreen = false;
        this._needsRedraw = false;
        this._hideCursor = options.hideCursor == null ? true : options.hideCursor;
        this._fixedFramerate = options.fixedFramerate == null ? !/^v0\.8\./.test(process.version) : options.fixedFramerate;
        this._lastUpdateAt = null;
        this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval;
        this._themes = options.themes || themes;
        this._theme = options.theme;
        var theme = this._computeTheme(options.theme);
        var template = options.template || [
            {
                type: 'progressbar',
                length: 20
            },
            {
                type: 'activityIndicator',
                kerning: 1,
                length: 1
            },
            {
                type: 'section',
                kerning: 1,
                default: ''
            },
            {
                type: 'subsection',
                kerning: 1,
                default: ''
            }
        ];
        this.setWriteTo(writeTo, options.tty);
        var PlumbingClass = options.Plumbing || Plumbing;
        this._gauge = new PlumbingClass(theme, template, this.getWidth());
        this._$$doRedraw = callWith(this, this._doRedraw);
        this._$$handleSizeChange = callWith(this, this._handleSizeChange);
        this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit;
        this._removeOnExit = null;
        if (options.enabled || options.enabled == null && this._tty && this._tty.isTTY) {
            this.enable();
        } else {
            this.disable();
        }
    }
    var _proto = Gauge.prototype;
    _proto.isEnabled = function isEnabled() {
        return !this._disabled;
    };
    _proto.setTemplate = function setTemplate(template) {
        this._gauge.setTemplate(template);
        if (this._showing) {
            this._requestRedraw();
        }
    };
    _proto._computeTheme = function _computeTheme(theme) {
        if (!theme) {
            theme = {};
        }
        if (typeof theme === 'string') {
            theme = this._themes.getTheme(theme);
        } else if (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null) {
            var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;
            var useColor = theme.hasColor == null ? hasColor : theme.hasColor;
            theme = this._themes.getDefault({
                hasUnicode: useUnicode,
                hasColor: useColor,
                platform: theme.platform
            });
        }
        return theme;
    };
    _proto.setThemeset = function setThemeset(themes) {
        this._themes = themes;
        this.setTheme(this._theme);
    };
    _proto.setTheme = function setTheme(theme) {
        this._gauge.setTheme(this._computeTheme(theme));
        if (this._showing) {
            this._requestRedraw();
        }
        this._theme = theme;
    };
    _proto._requestRedraw = function _requestRedraw() {
        this._needsRedraw = true;
        if (!this._fixedFramerate) {
            this._doRedraw();
        }
    };
    _proto.getWidth = function getWidth() {
        return (this._tty && this._tty.columns || 80) - 1;
    };
    _proto.setWriteTo = function setWriteTo(writeTo, tty) {
        var enabled = !this._disabled;
        if (enabled) {
            this.disable();
        }
        this._writeTo = writeTo;
        this._tty = tty || writeTo === process.stderr && process.stdout.isTTY && process.stdout || writeTo.isTTY && writeTo || this._tty;
        if (this._gauge) {
            this._gauge.setWidth(this.getWidth());
        }
        if (enabled) {
            this.enable();
        }
    };
    _proto.enable = function enable() {
        if (!this._disabled) {
            return;
        }
        this._disabled = false;
        if (this._tty) {
            this._enableEvents();
        }
        if (this._showing) {
            this.show();
        }
    };
    _proto.disable = function disable() {
        if (this._disabled) {
            return;
        }
        if (this._showing) {
            this._lastUpdateAt = null;
            this._showing = false;
            this._doRedraw();
            this._showing = true;
        }
        this._disabled = true;
        if (this._tty) {
            this._disableEvents();
        }
    };
    _proto._enableEvents = function _enableEvents() {
        if (this._cleanupOnExit) {
            this._removeOnExit = onExit(callWith(this, this.disable));
        }
        this._tty.on('resize', this._$$handleSizeChange);
        if (this._fixedFramerate) {
            this.redrawTracker = setInterval(this._$$doRedraw, this._updateInterval);
            if (this.redrawTracker.unref) {
                this.redrawTracker.unref();
            }
        }
    };
    _proto._disableEvents = function _disableEvents() {
        this._tty.removeListener('resize', this._$$handleSizeChange);
        if (this._fixedFramerate) {
            clearInterval(this.redrawTracker);
        }
        if (this._removeOnExit) {
            this._removeOnExit();
        }
    };
    _proto.hide = function hide(cb) {
        if (this._disabled) {
            return cb && process.nextTick(cb);
        }
        if (!this._showing) {
            return cb && process.nextTick(cb);
        }
        this._showing = false;
        this._doRedraw();
        cb && setImmediateFn(cb);
    };
    _proto.show = function show(section, completed) {
        this._showing = true;
        if (typeof section === 'string') {
            this._status.section = section;
        } else if ((typeof section === "undefined" ? "undefined" : _type_of$3(section)) === 'object') {
            var sectionKeys = Object.keys(section);
            for(var ii = 0; ii < sectionKeys.length; ++ii){
                var key = sectionKeys[ii];
                this._status[key] = section[key];
            }
        }
        if (completed != null) {
            this._status.completed = completed;
        }
        if (this._disabled) {
            return;
        }
        this._requestRedraw();
    };
    _proto.pulse = function pulse(subsection) {
        this._status.subsection = subsection || '';
        this._status.spun++;
        if (this._disabled) {
            return;
        }
        if (!this._showing) {
            return;
        }
        this._requestRedraw();
    };
    _proto._handleSizeChange = function _handleSizeChange() {
        this._gauge.setWidth(this._tty.columns - 1);
        this._requestRedraw();
    };
    _proto._doRedraw = function _doRedraw() {
        if (this._disabled || this._paused) {
            return;
        }
        if (!this._fixedFramerate) {
            var now = Date.now();
            if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) {
                return;
            }
            this._lastUpdateAt = now;
        }
        if (!this._showing && this._onScreen) {
            this._onScreen = false;
            var result = this._gauge.hide();
            if (this._hideCursor) {
                result += this._gauge.showCursor();
            }
            return this._writeTo.write(result);
        }
        if (!this._showing && !this._onScreen) {
            return;
        }
        if (this._showing && !this._onScreen) {
            this._onScreen = true;
            this._needsRedraw = true;
            if (this._hideCursor) {
                this._writeTo.write(this._gauge.hideCursor());
            }
        }
        if (!this._needsRedraw) {
            return;
        }
        if (!this._writeTo.write(this._gauge.show(this._status))) {
            this._paused = true;
            this._writeTo.on('drain', callWith(this, function() {
                this._paused = false;
                this._doRedraw();
            }));
        }
    };
    return Gauge;
} 
();

function _array_like_to_array$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$2(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$2(arr);
}
function _assert_this_initialized$2(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$2(_this, derived, args) {
    derived = _get_prototype_of$2(derived);
    return _possible_constructor_return$2(_this, _is_native_reflect_construct$2() ? Reflect.construct(derived, [], _get_prototype_of$2(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$1(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    _defineProperties$1(Constructor.prototype, protoProps);
    return Constructor;
}
function _get_prototype_of$2(o) {
    _get_prototype_of$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$2(o);
}
function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$2(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array$2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$2(self, call) {
    if (call && (_type_of$2(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$2(self);
}
function _set_prototype_of$2(o, p) {
    _set_prototype_of$2 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$2(o, p);
}
function _to_consumable_array$2(arr) {
    return _array_without_holes$2(arr) || _iterable_to_array$2(arr) || _unsupported_iterable_to_array$2(arr) || _non_iterable_spread$2();
}
function _type_of$2(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$2(o, minLen);
}
function _is_native_reflect_construct$2() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$2 = function() {
        return !!result;
    })();
}
setBlocking(true);
var Logger = /*#__PURE__*/ function(EventEmitter) {
    _inherits$2(Logger, EventEmitter);
    function Logger() {
        _class_call_check$3(this, Logger);
        var _this;
        _this = _call_super$2(this, Logger);
        _this._stream = process.stderr;
        _this._paused = false;
        _this._buffer = [];
        _this.unicodeEnabled = false;
        _this.colorEnabled = undefined;
        _this.id = 0;
        _this.record = [];
        _this.maxRecordSize = 10000;
        _this.level = 'info';
        _this.prefixStyle = {
            fg: 'magenta'
        };
        _this.headingStyle = {
            fg: 'white',
            bg: 'black'
        };
        _this.style = {};
        _this.levels = {};
        _this.disp = {};
        _this.gauge = new Gauge(_this._stream, {
            enabled: false,
            theme: {
                hasColor: _this.useColor()
            },
            template: [
                {
                    type: 'progressbar',
                    length: 20
                },
                {
                    type: 'activityIndicator',
                    kerning: 1,
                    length: 1
                },
                {
                    type: 'section',
                    default: ''
                },
                ':',
                {
                    type: 'logline',
                    kerning: 1,
                    default: ''
                }
            ]
        });
        _this.tracker = new TrackerGroup();
        _this.progressEnabled = _this.gauge.isEnabled();
        _this.addLevel('silly', -Infinity, {
            inverse: true
        }, 'sill');
        _this.addLevel('verbose', 1000, {
            fg: 'cyan',
            bg: 'black'
        }, 'verb');
        _this.addLevel('info', 2000, {
            fg: 'green'
        });
        _this.addLevel('timing', 2500, {
            fg: 'green',
            bg: 'black'
        });
        _this.addLevel('http', 3000, {
            fg: 'green',
            bg: 'black'
        });
        _this.addLevel('notice', 3500, {
            fg: 'cyan',
            bg: 'black'
        });
        _this.addLevel('warn', 4000, {
            fg: 'black',
            bg: 'yellow'
        }, 'WARN');
        _this.addLevel('error', 5000, {
            fg: 'red',
            bg: 'black'
        }, 'ERR!');
        _this.addLevel('silent', Infinity);
        _this.on('error', function() {});
        return _this;
    }
    var _proto = Logger.prototype;
    _proto.useColor = function useColor() {
        var _this__stream;
        var _this__stream_isTTY;
        return this.colorEnabled != null ? this.colorEnabled : (_this__stream_isTTY = (_this__stream = this._stream) === null || _this__stream === undefined ? undefined : _this__stream.isTTY) !== null && _this__stream_isTTY !== undefined ? _this__stream_isTTY : false;
    };
    _proto.enableColor = function enableColor() {
        this.colorEnabled = true;
        this.gauge.setTheme({
            hasColor: this.colorEnabled,
            hasUnicode: this.unicodeEnabled
        });
    };
    _proto.disableColor = function disableColor() {
        this.colorEnabled = false;
        this.gauge.setTheme({
            hasColor: this.colorEnabled,
            hasUnicode: this.unicodeEnabled
        });
    };
    _proto.enableUnicode = function enableUnicode() {
        this.unicodeEnabled = true;
        this.gauge.setTheme({
            hasColor: this.useColor(),
            hasUnicode: this.unicodeEnabled
        });
    };
    _proto.disableUnicode = function disableUnicode() {
        this.unicodeEnabled = false;
        this.gauge.setTheme({
            hasColor: this.useColor(),
            hasUnicode: this.unicodeEnabled
        });
    };
    _proto.setGaugeThemeset = function setGaugeThemeset(themes) {
        this.gauge.setThemeset(themes);
    };
    _proto.setGaugeTemplate = function setGaugeTemplate(template) {
        this.gauge.setTemplate(template);
    };
    _proto.enableProgress = function enableProgress() {
        if (this.progressEnabled || this._paused) {
            return;
        }
        this.progressEnabled = true;
        this.tracker.on('change', this.showProgress.bind(this));
        this.gauge.enable();
    };
    _proto.disableProgress = function disableProgress() {
        if (!this.progressEnabled) {
            return;
        }
        this.progressEnabled = false;
        this.tracker.removeListener('change', this.showProgress.bind(this));
        this.gauge.disable();
    };
    _proto.clearProgress = function clearProgress(cb) {
        if (!this.progressEnabled) {
            return cb && process.nextTick(cb);
        }
        this.gauge.hide(cb);
    };
    _proto.showProgress = function showProgress(name, completed) {
        if (!this.progressEnabled) {
            return;
        }
        var values = {};
        if (name) {
            values.section = name;
        }
        var last = this.record[this.record.length - 1];
        if (last) {
            values.subsection = last.prefix;
            var disp = this.disp[last.level];
            var logline = this._format(disp, this.style[last.level]);
            if (last.prefix) {
                logline += ' ' + this._format(last.prefix, this.prefixStyle);
            }
            logline += ' ' + last.message.split(/\r?\n/)[0];
            values.logline = logline;
        }
        values.completed = completed || this.tracker.completed();
        this.gauge.show(values);
    };
    _proto.pause = function pause() {
        this._paused = true;
        if (this.progressEnabled) {
            this.gauge.disable();
        }
    };
    _proto.resume = function resume() {
        var _this = this;
        if (!this._paused) {
            return;
        }
        this._paused = false;
        var buffer = this._buffer;
        this._buffer = [];
        buffer.forEach(function(m) {
            return _this.emitLog(m);
        });
        if (this.progressEnabled) {
            this.gauge.enable();
        }
    };
    _proto.log = function log(lvl, prefix) {
        for(var _len = arguments.length, messageArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            messageArgs[_key - 2] = arguments[_key];
        }
        var l = this.levels[lvl];
        if (l === undefined) {
            this.emit('error', new Error(util.format('Undefined log level: %j', lvl)));
            return;
        }
        var stack = null;
        var a = messageArgs.map(function(arg) {
            if (_instanceof(arg, Error) && arg.stack) {
                Object.defineProperty(arg, 'stack', {
                    value: stack = arg.stack + '',
                    enumerable: true,
                    writable: true
                });
            }
            return arg;
        });
        if (stack) {
            a.unshift(stack + '\n');
        }
        var message = util.format.apply(undefined, _to_consumable_array$2(a));
        var m = {
            id: this.id++,
            level: lvl,
            prefix: String(prefix || ''),
            message: message,
            messageRaw: a
        };
        this.emit('log', m);
        this.emit("log.".concat(lvl), m);
        if (m.prefix) {
            this.emit(m.prefix, m);
        }
        this.record.push(m);
        var mrs = this.maxRecordSize;
        if (this.record.length > mrs) {
            this.record = this.record.slice(-Math.floor(mrs * 0.9));
        }
        this.emitLog(m);
    };
    _proto.emitLog = function emitLog(m) {
        var _this = this;
        var _m_message;
        if (this._paused) {
            this._buffer.push(m);
            return;
        }
        if (this.progressEnabled) {
            this.gauge.pulse(m.prefix);
        }
        var l = this.levels[m.level];
        if (l === undefined || l < this.levels[this.level] || l > 0 && !isFinite(l)) {
            return;
        }
        var disp = this.disp[m.level];
        this.clearProgress();
        (_m_message = m.message) === null || _m_message === undefined ? undefined : _m_message.split(/\r?\n/).forEach(function(line) {
            var heading = _this.heading;
            if (heading) {
                _this.write(heading, _this.headingStyle);
                _this.write(' ');
            }
            _this.write(disp, _this.style[m.level]);
            var p = m.prefix || '';
            if (p) {
                _this.write(' ');
            }
            _this.write(p, _this.prefixStyle);
            _this.write(' ' + line + '\n');
        });
        this.showProgress();
    };
    _proto._format = function _format(msg, style) {
        if (!this._stream) {
            return;
        }
        var output = '';
        if (this.useColor()) {
            style = style || {};
            var settings = [];
            if (style.fg) {
                settings.push(style.fg);
            }
            if (style.bg) {
                settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1));
            }
            if (style.bold) {
                settings.push('bold');
            }
            if (style.underline) {
                settings.push('underline');
            }
            if (style.inverse) {
                settings.push('inverse');
            }
            if (settings.length) {
                output += consoleControl.color(settings);
            }
            if (style.beep) {
                output += consoleControl.beep();
            }
        }
        output += msg;
        if (this.useColor()) {
            output += consoleControl.color('reset');
        }
        return output;
    };
    _proto.write = function write(msg, style) {
        if (!this._stream) {
            return;
        }
        this._stream.write(this._format(msg, style));
    };
    _proto.addLevel = function addLevel(lvl, n, style) {
        var disp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        if (disp == null) {
            disp = lvl;
        }
        this.levels[lvl] = n;
        this.style[lvl] = style;
        if (!this[lvl]) {
            var _this = this;
            this[lvl] = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var a = [
                    lvl
                ].concat(_to_consumable_array$2(args));
                return _this.log.apply(_this, a);
            };
        }
        this.disp[lvl] = disp;
    };
    _create_class$1(Logger, [
        {
            key: "stream",
            get: function get() {
                return this._stream;
            },
            set: function set(newStream) {
                this._stream = newStream;
                if (this.gauge) {
                    this.gauge.setWriteTo(this._stream, this._stream);
                }
            }
        }
    ]);
    return Logger;
}(EventEmitter$1.EventEmitter);
var log = new Logger();
var trackerConstructors = [
    'newGroup',
    'newItem',
    'newStream'
];
var mixinLog = function mixinLog1(tracker) {
    Array.from(new Set(_to_consumable_array$2(Object.keys(log)).concat(_to_consumable_array$2(Object.getOwnPropertyNames(Object.getPrototypeOf(log)))))).forEach(function(P) {
        if (P[0] === '_') {
            return;
        }
        if (trackerConstructors.filter(function(C) {
            return C === P;
        }).length) {
            return;
        }
        if (tracker[P]) {
            return;
        }
        if (typeof log[P] !== 'function') {
            return;
        }
        var func = log[P];
        tracker[P] = function() {
            return func.apply(log, arguments);
        };
    });
    if (_instanceof(tracker, TrackerGroup)) {
        trackerConstructors.forEach(function(C) {
            var func = tracker[C];
            tracker[C] = function() {
                return mixinLog(func.apply(tracker, arguments));
            };
        });
    }
    return tracker;
};
trackerConstructors.forEach(function(C) {
    log[C] = function() {
        return mixinLog(this.tracker[C].apply(this.tracker, arguments));
    };
});

function _array_like_to_array$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes$1(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$1(arr);
}
function _assert_this_initialized$1(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super$1(_this, derived, args) {
    derived = _get_prototype_of$1(derived);
    return _possible_constructor_return$1(_this, _is_native_reflect_construct$1() ? Reflect.construct(derived, args, _get_prototype_of$1(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct$1(Parent, args, Class) {
    if (_is_native_reflect_construct$1()) {
        _construct$1 = Reflect.construct;
    } else {
        _construct$1 = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of$1(instance, Class.prototype);
            return instance;
        };
    }
    return _construct$1.apply(null, arguments);
}
function _get_prototype_of$1(o) {
    _get_prototype_of$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$1(o);
}
function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$1(subClass, superClass);
}
function _is_native_function$1(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array$1(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$1(self, call) {
    if (call && (_type_of$1(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$1(self);
}
function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$1(o, p);
}
function _to_consumable_array$1(arr) {
    return _array_without_holes$1(arr) || _iterable_to_array$1(arr) || _unsupported_iterable_to_array$1(arr) || _non_iterable_spread$1();
}
function _type_of$1(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);
}
function _wrap_native_super$1(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super$1 = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function$1(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct$1(Class, arguments, _get_prototype_of$1(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of$1(Wrapper, Class);
    };
    return _wrap_native_super$1(Class);
}
function _is_native_reflect_construct$1() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$1 = function() {
        return !!result;
    })();
}
var ValidationError = /*#__PURE__*/ function(Error1) {
    _inherits$1(ValidationError, Error1);
    function ValidationError(prefix, message) {
        for(var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            rest[_key - 2] = arguments[_key];
        }
        var _log;
        _class_call_check$2(this, ValidationError);
        var _this;
        _this = _call_super$1(this, ValidationError, [
            message
        ]);
        _this.prefix = '';
        _this.name = 'ValidationError';
        _this.prefix = prefix;
        log.resume();
        (_log = log).error.apply(_log, [
            prefix,
            message
        ].concat(_to_consumable_array$1(rest)));
        return _this;
    }
    return ValidationError;
} 
(_wrap_native_super$1(Error));

function reportCycles(paths, rejectCycles) {
    if (!paths.length) {
        return;
    }
    var cycleMessage = [
        'Dependency cycles detected, you should fix these!'
    ].concat(paths).join('\n');
    if (rejectCycles) {
        throw new ValidationError('ECYCLE', cycleMessage);
    }
    log.warn('ECYCLE', cycleMessage);
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args, _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _get_prototype_of(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
var YARN_PATCH_PROTOCOL_REG_EXP = new RegExp("patch:(.*)@npm%3A(.*)#~\\/.yarn\\/patches\\/(.*).patch");
var PackageGraph = /*#__PURE__*/ function(Map1) {
    _inherits(PackageGraph, Map1);
    function PackageGraph(packages) {
        var graphType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'allDependencies', localDependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';
        _class_call_check$1(this, PackageGraph);
        var _this;
        if (localDependencies === true || localDependencies === 'forceLocal') {
            localDependencies = 'force';
        }
        _this = _call_super(this, PackageGraph, [
            packages.map(function(pkg) {
                var _pkg_name;
                return [
                    (_pkg_name = pkg === null || pkg === undefined ? undefined : pkg.name) !== null && _pkg_name !== undefined ? _pkg_name : '',
                    new PackageGraphNode(pkg)
                ];
            })
        ]);
        if (packages.length !== _this.size) {
            var seen = new Map();
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = packages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _step.value, name = _step_value.name, location = _step_value.location;
                    if (seen.has(name)) {
                        seen.get(name).push(location);
                    } else {
                        seen.set(name, [
                            location
                        ]);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = seen[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var _step_value1 = _sliced_to_array(_step1.value, 2), name1 = _step_value1[0], locations = _step_value1[1];
                    if (locations.length > 1) {
                        throw new ValidationError('ENAME', [
                            'Package name "'.concat(name1, '" used in multiple packages:')
                        ].concat(_to_consumable_array(locations)).join('\n\t'));
                    }
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
        }
        var _this_readWorkspaceCatalogConfig = _this.readWorkspaceCatalogConfig(), catalog = _this_readWorkspaceCatalogConfig.catalog, catalogs = _this_readWorkspaceCatalogConfig.catalogs;
        _this.forEach(function(currentNode, currentName) {
            var graphDependencies = graphType === 'dependencies' ? Object.assign({}, currentNode.pkg.optionalDependencies, currentNode.pkg.dependencies) : Object.assign({}, currentNode.pkg.devDependencies, currentNode.pkg.optionalDependencies, currentNode.pkg.peerDependencies, currentNode.pkg.dependencies);
            Object.keys(graphDependencies).forEach(function(depName) {
                var depNode = _this.get(depName);
                var spec = graphDependencies[depName].replace(/^link:/, 'file:');
                if (spec.startsWith('patch:')) {
                    spec = spec.replace(YARN_PATCH_PROTOCOL_REG_EXP, '$2');
                }
                var isCatalogSpec = /^catalog:/.test(spec);
                if (isCatalogSpec) {
                    var _catalogs_spec;
                    spec = spec.replace(/^catalog:/, '');
                    var catalogVersion = spec === '' || spec === 'default' ? catalog[depName] : (_catalogs_spec = catalogs[spec]) === null || _catalogs_spec === undefined ? undefined : _catalogs_spec[depName];
                    if (catalogVersion) {
                        spec = catalogVersion;
                    } else {
                        console.warn("Warning: No version found in ".concat(spec || 'default', " catalog for ").concat(depName));
                    }
                }
                var isWorkspaceSpec = /^workspace:/.test(spec);
                var fullWorkspaceSpec;
                if (isWorkspaceSpec) {
                    fullWorkspaceSpec = spec;
                    spec = spec.replace(/^workspace:/, '');
                    if (spec === '*' || spec === '^' || spec === '~') {
                        var depPkg = packages.find(function(pkg) {
                            return pkg.name === depName;
                        });
                        var version = depPkg === null || depPkg === undefined ? undefined : depPkg.version;
                        var specTarget = spec === '*' ? '' : spec;
                        spec = depPkg ? "".concat(specTarget).concat(version) : '';
                    }
                }
                var resolved = npa.resolve(depName, spec, currentNode.location);
                resolved.workspaceSpec = fullWorkspaceSpec;
                if (!depNode) {
                    return currentNode.externalDependencies.set(depName, resolved);
                }
                if (isWorkspaceSpec || localDependencies === 'force' || resolved.fetchSpec === depNode.location || localDependencies !== 'explicit' && depNode.satisfies(resolved)) {
                    currentNode.localDependencies.set(depName, resolved);
                    depNode.localDependents.set(currentName, currentNode);
                } else {
                    currentNode.externalDependencies.set(depName, resolved);
                }
            });
        });
        return _this;
    }
    var _proto = PackageGraph.prototype;
    _proto.addDependencies = function addDependencies(filteredPackages) {
        return this.extendList(filteredPackages, 'localDependencies');
    };
    _proto.addDependents = function addDependents(filteredPackages) {
        return this.extendList(filteredPackages, 'localDependents');
    };
    _proto.readWorkspaceCatalogConfig = function readWorkspaceCatalogConfig() {
        var workspaceConfigPath = require$$3.join(process.cwd(), 'pnpm-workspace.yaml');
        var _ref = fs.existsSync(workspaceConfigPath) ? distExports.parse(fs.readFileSync(workspaceConfigPath, 'utf8')) : {}, _ref_catalog = _ref.catalog, catalog = _ref_catalog === undefined ? {} : _ref_catalog, _ref_catalogs = _ref.catalogs, catalogs = _ref_catalogs === undefined ? {} : _ref_catalogs;
        return {
            catalog: catalog,
            catalogs: catalogs
        };
    };
    _proto.extendList = function extendList(packageList, nodeProp) {
        var _this = this;
        var search = new Set(packageList.map(function(param) {
            var name = param.name;
            return _this.get(name);
        }));
        var result = [];
        search.forEach(function(currentNode) {
            result.push(currentNode);
            currentNode[nodeProp].forEach(function(meta, depName) {
                var depNode = _this.get(depName);
                if (depNode && depNode !== currentNode && !search.has(depNode)) {
                    search.add(depNode);
                }
            });
        });
        return result.map(function(node) {
            return node.pkg;
        });
    };
    _proto.collapseCycles = function collapseCycles(rejectCycles) {
        var cyclePaths = [];
        var nodeToCycle = new Map();
        var cycles = new Set();
        var alreadyVisited = new Set();
        var walkStack = [];
        function visits(baseNode, dependentNode) {
            if (nodeToCycle.has(baseNode)) {
                return;
            }
            var topLevelDependent = dependentNode;
            while(nodeToCycle.has(topLevelDependent)){
                topLevelDependent = nodeToCycle.get(topLevelDependent);
            }
            var identifier = "".concat(baseNode.name, ":").concat(topLevelDependent.name);
            if (alreadyVisited.has(identifier)) {
                return;
            }
            alreadyVisited.add(identifier);
            if (topLevelDependent === baseNode || topLevelDependent.isCycle && topLevelDependent.has(baseNode.name)) {
                var cycle = new CyclicPackageGraphNode();
                walkStack.forEach(function(nodeInCycle) {
                    nodeToCycle.set(nodeInCycle, cycle);
                    cycle.insert(nodeInCycle);
                    cycles.delete(nodeInCycle);
                });
                cycles.add(cycle);
                cyclePaths.push(cycle.toString());
                return;
            }
            if (walkStack.indexOf(topLevelDependent) === -1) {
                visitWithStack(baseNode, topLevelDependent);
            }
        }
        function visitWithStack(baseNode) {
            var currentNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : baseNode;
            walkStack.push(currentNode);
            currentNode.localDependents.forEach(visits.bind(null, baseNode));
            walkStack.pop();
        }
        this.forEach(function(currentNode) {
            return visitWithStack(currentNode);
        });
        cycles.forEach(function(collapsedNode) {
            return visitWithStack(collapsedNode);
        });
        reportCycles(cyclePaths, rejectCycles);
        return cycles;
    };
    _proto.prune = function prune() {
        var _this = this;
        for(var _len = arguments.length, candidates = new Array(_len), _key = 0; _key < _len; _key++){
            candidates[_key] = arguments[_key];
        }
        if (candidates.length === this.size) {
            return this.clear();
        }
        candidates.forEach(function(node) {
            return _this.remove(node);
        });
    };
    _proto.remove = function remove(candidateNode) {
        this.delete(candidateNode.name);
        this.forEach(function(node) {
            node.localDependencies.delete(candidateNode.name);
            node.localDependents.delete(candidateNode.name);
        });
    };
    _create_class(PackageGraph, [
        {
            key: "rawPackageList",
            get: function get() {
                return Array.from(this.values()).map(function(node) {
                    return node.pkg;
                });
            }
        }
    ]);
    return PackageGraph;
} 
(_wrap_native_super(Map));

function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var QueryGraph = /*#__PURE__*/ function() {
    function QueryGraph(packages) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref_graphType = _ref.graphType, graphType = _ref_graphType === undefined ? 'allDependencies' : _ref_graphType, _ref_localDependencies = _ref.localDependencies, localDependencies = _ref_localDependencies === undefined ? 'auto' : _ref_localDependencies, rejectCycles = _ref.rejectCycles;
        _class_call_check(this, QueryGraph);
        this.graph = new PackageGraph(packages, graphType, localDependencies);
        this.cycles = this.graph.collapseCycles(rejectCycles);
    }
    var _proto = QueryGraph.prototype;
    _proto._getNextLeaf = function _getNextLeaf() {
        return Array.from(this.graph.values()).filter(function(node) {
            return node.localDependencies.size === 0;
        });
    };
    _proto._getNextCycle = function _getNextCycle() {
        var cycle = Array.from(this.cycles).find(function(cycleNode) {
            return cycleNode.localDependencies.size === 0;
        });
        if (!cycle) {
            return [];
        }
        this.cycles.delete(cycle);
        return cycle.flatten();
    };
    _proto.getAvailablePackages = function getAvailablePackages() {
        var availablePackages = this._getNextLeaf();
        if (availablePackages.length > 0) {
            return availablePackages;
        }
        return this._getNextCycle();
    };
    _proto.markAsTaken = function markAsTaken(name) {
        this.graph.delete(name);
    };
    _proto.markAsDone = function markAsDone(candidateNode) {
        this.graph.remove(candidateNode);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = this.cycles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var cycle = _step.value;
                cycle.unlink(candidateNode);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    QueryGraph.toposort = function toposort(packages, options) {
        var graph = new QueryGraph(packages, options);
        var result = [];
        var batch = graph.getAvailablePackages();
        while(batch.length){
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = batch[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var node = _step.value;
                    result.push(node.pkg);
                    graph.markAsDone(node);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            batch = graph.getAvailablePackages();
        }
        return result;
    };
    return QueryGraph;
} 
();

function runTopologically(packages, runner) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, concurrency = _ref.concurrency, graphType = _ref.graphType, rejectCycles = _ref.rejectCycles;
    var queue = new PQueue({
        concurrency: concurrency
    });
    var graph = new QueryGraph(packages, {
        graphType: graphType,
        rejectCycles: rejectCycles
    });
    return new Promise(function(resolve, reject) {
        var returnValues = [];
        var queueNextAvailablePackages = function() {
            return graph.getAvailablePackages().forEach(function(param) {
                var pkg = param.pkg, name = param.name;
                graph.markAsTaken(name);
                queue.add(function() {
                    return runner(pkg).then(function(value) {
                        return returnValues.push(value);
                    }).then(function() {
                        return graph.markAsDone(pkg);
                    }).then(function() {
                        return queueNextAvailablePackages();
                    });
                }).catch(reject);
            });
        };
        queueNextAvailablePackages();
        return queue.onIdle().then(function() {
            return resolve(returnValues);
        });
    });
}

exports.runTopologically = runTopologically;
/* CJS INTEROP */ if (exports.__esModule && exports.default) { try { Object.defineProperty(exports.default, '__esModule', { value: true }); for (var key in exports) { exports.default[key] = exports[key]; } } catch (_) { }; module.exports = exports.default; }
